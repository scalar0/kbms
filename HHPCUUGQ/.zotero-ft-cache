Professional CMake: A Practical Guide
14th Edition
ISBN 978-1-925904-22-2
© 2018-2023 by Craig Scott
This book or any portion thereof may not be reproduced in any manner or form without the express written permission of the author, with the following specific exceptions:
• The original purchaser may make personal copies exclusively for their own use on their electronic devices, provided that all reasonable steps are taken to ensure that only the original purchaser has access to such copies.
• Permission is given to use any of the code samples in this work without restriction. Attribution is not required.
The advice and strategies contained within this work may not be suitable for every situation. This work is sold with the understanding that the author is not held responsible for the results accrued from the advice in this book.
https://crascit.com


Table of Contents
Preface. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
Part I: Fundamentals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1. Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
2. Setting Up A Project . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
2.1. In-source Builds . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
2.2. Out-of-source Builds . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
2.3. Generating Project Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
2.4. Running The Build Tool . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
2.5. Recommended Practices. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
3. A Minimal Project . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
3.1. Managing CMake Versions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
3.2. The project() Command . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
3.3. Building A Basic Executable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
3.4. Commenting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
3.5. Recommended Practices. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
4. Building Simple Targets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
4.1. Executables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
4.2. Defining Libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
4.3. Linking Targets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
4.4. Linking Non-targets. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
4.5. Old-style CMake . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
4.6. Recommended Practices. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
5. Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
5.1. Variable Basics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
5.2. Environment Variables. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
5.3. Cache Variables. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
5.4. Scope Blocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
5.5. Potentially Surprising Behavior Of Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
5.6. Manipulating Cache Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
5.6.1. Setting Cache Values On The Command Line . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
5.6.2. CMake GUI Tools . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
5.7. Printing Variable Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
5.8. String Handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
5.9. Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
5.9.1. Problems With Unbalanced Square Brackets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
5.10. Math . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
5.11. Recommended Practices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41


6. Flow Control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
6.1. The if() Command . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
6.1.1. Basic Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
6.1.2. Logic Operators. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
6.1.3. Comparison Tests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
6.1.4. File System Tests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
6.1.5. Existence Tests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
6.1.6. Common Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
6.2. Looping. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
6.2.1. foreach() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
6.2.2. while() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
6.2.3. Interrupting Loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
6.3. Recommended Practices. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
7. Using Subdirectories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
7.1. add_subdirectory(). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
7.1.1. Source And Binary Directory Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
7.1.2. Scope . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
7.1.3. When To Call project(). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
7.2. include() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
7.3. Project-relative Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
7.4. Ending Processing Early . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
7.5. Recommended Practices. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67
8. Functions And Macros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
8.1. The Basics. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
8.2. Argument Handling Essentials . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
8.3. Keyword Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
8.4. Returning Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78
8.4.1. Returning Values From Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78
8.4.2. Returning Values From Macros. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
8.5. Overriding Commands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
8.6. Special Variables For Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
8.7. Other Ways Of Invoking CMake Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
8.8. Problems With Argument Handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
8.8.1. Parsing Arguments Robustly . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
8.8.2. Forwarding Command Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
8.8.3. Special Cases For Argument Expansion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
8.9. Recommended Practices. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
9. Properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
9.1. General Property Commands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
9.2. Global Properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
9.3. Directory Properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101


9.4. Target Properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
9.5. Source Properties. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
9.6. Cache Variable Properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
9.7. Other Property Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106
9.8. Recommended Practices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106
10. Generator Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108
10.1. Simple Boolean Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
10.2. Target Details . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
10.3. General Information . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
10.4. Path Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
10.5. Utility Expressions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
10.6. Recommended Practices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
11. Modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
11.1. Checking Existence And Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
11.2. Other Modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
11.3. Recommended Practices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
12. Policies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
12.1. Policy Control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
12.2. Policy Scope. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
12.3. Recommended Practices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
13. Debugging And Diagnostics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
13.1. Log Messages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
13.1.1. Log Levels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
13.1.2. Message Indenting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
13.1.3. Message Contexts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137
13.1.4. Check Messages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139
13.2. Color Diagnostics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
13.3. Print Helpers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142
13.4. Tracing Variable Access . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143
13.5. Debugging Generator Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143
13.6. Profiling CMake Calls . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
13.7. Discarding Previous Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
13.8. Recommended Practices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 146
Part II: Builds In Depth . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148
14. Build Type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149
14.1. Build Type Basics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149
14.1.1. Single Configuration Generators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150
14.1.2. Multiple Configuration Generators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150
14.2. Common Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
14.3. Custom Build Types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152


14.4. Recommended Practices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
15. Compiler And Linker Essentials. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158
15.1. Target Properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158
15.1.1. Compiler Flags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158
15.1.2. Linker Flags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
15.1.3. Sources . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 162
15.2. Target Property Commands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 162
15.2.1. Linking Libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 162
15.2.2. Linker Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163
15.2.3. Header Search Paths . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164
15.2.4. Compiler Defines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
15.2.5. Compiler Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
15.2.6. Source Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
15.3. Directory Properties And Commands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
15.4. De-duplicating Options. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170
15.5. Compiler And Linker Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171
15.5.1. Compiler And Linker Variables Are Single Strings, Not Lists . . . . . . . . . . . . . . . . . . . . . 173
15.5.2. Distinguish Between Cache And Non-cache Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . 173
15.5.3. Prefer Appending Over Replacing Flags. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 174
15.5.4. Understand When Variable Values Are Used . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 174
15.6. Language-specific Compiler Flags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175
15.7. Compiler Option Abstractions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176
15.7.1. Warnings As Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176
15.7.2. System Header Search Paths . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177
15.7.3. Runtime Library Selection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180
15.7.4. Debug Information Format Selection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181
15.8. Recommended Practices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183
16. Advanced Linking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186
16.1. Require Targets For Linking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186
16.2. Customize How Libraries Are Linked. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
16.2.1. Link Group Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188
16.2.2. Link Library Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188
16.2.3. Custom Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 190
16.2.4. Feature Validity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 190
16.3. Propagating Up Direct Link Dependencies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 190
16.3.1. Link Seaming Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191
16.3.2. Static Plugins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194
16.4. Recommended Practices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194
17. Language Requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195
17.1. Setting The Language Standard Directly . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195
17.2. Setting The Language Standard By Feature Requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . 198


17.2.1. Detection And Use Of Optional Language Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199
17.3. Recommended Practices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200
18. Target Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 202
18.1. Executables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 202
18.2. Libraries. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203
18.2.1. Basic Library Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203
18.2.2. Object Libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203
18.2.3. Imported Libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 204
18.2.4. Interface Libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 206
18.2.5. Interface Imported Libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 208
18.2.6. Library Aliases . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209
18.3. Promoting Imported Targets. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211
18.4. Recommended Practices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212
19. Custom Tasks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215
19.1. Custom Targets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215
19.2. Adding Build Steps To An Existing Target . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218
19.3. Commands That Generate Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219
19.4. Configure Time Tasks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 223
19.5. Platform Independent Commands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 226
19.6. Combining The Different Approaches . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 228
19.7. Recommended Practices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 230
20. Working With Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232
20.1. Manipulating Paths . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232
20.1.1. cmake_path() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232
20.1.2. Older Commands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 235
20.2. Copying Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 238
20.3. Reading And Writing Files Directly. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 246
20.4. File System Manipulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 250
20.5. File Globbing. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 252
20.6. Downloading And Uploading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 254
20.7. Recommended Practices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 256
21. Specifying Version Details . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 258
21.1. Project Version . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 258
21.2. Source Code Access To Version Details . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 260
21.3. Source Control Commits. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 263
21.4. Recommended Practices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 266
22. Libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 268
22.1. Build Basics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 268
22.2. Linking Static Libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 269
22.3. Shared Library Versioning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 269
22.4. Interface Compatibility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 271


22.5. Symbol Visibility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 276
22.5.1. Specifying Default Visibility . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 277
22.5.2. Specifying Individual Symbol Visibilities. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 277
22.6. Mixing Static And Shared Libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283
22.7. Recommended Practices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 286
23. Toolchains And Cross Compiling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 288
23.1. Toolchain Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 289
23.2. Defining The Target System . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290
23.3. Tool Selection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 291
23.4. System Roots . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 294
23.5. Compiler Checks. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 295
23.6. Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 296
23.6.1. Raspberry Pi . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 296
23.6.2. GCC With 32-bit Target On 64-bit Host . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 296
23.7. Android . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 297
23.7.1. Historical Context . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 297
23.7.2. Using The NDK . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 298
23.7.3. Android Studio . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299
23.7.4. ndk-build . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 300
23.7.5. Visual Studio Generators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 300
23.8. Recommended Practices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 300
24. Apple Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 302
24.1. CMake Generator Selection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 302
24.2. Application Bundles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 305
24.2.1. Bundle Structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 305
24.2.2. Bundle Info.plist Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 306
24.2.3. Sources, Resources And Other Files. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 309
24.3. Frameworks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 310
24.3.1. Framework Structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 311
24.3.2. Framework Info.plist Files. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 312
24.3.3. Headers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 313
24.4. Loadable Bundles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 314
24.5. Build Settings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 314
24.5.1. SDK Selection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 314
24.5.2. Deployment Target . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 315
24.5.3. Device Families. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 316
24.5.4. Compiler Test Workarounds . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 317
24.6. Code Signing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 318
24.6.1. Signing Identity And Development Team . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 318
24.6.2. Provisioning Profiles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 319
24.6.3. Entitlements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 320


24.7. Creating And Exporting Archives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 320
24.8. Universal Binaries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 322
24.8.1. Device-only Bundles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 323
24.8.2. Intel And Apple Silicon Binaries. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 324
24.8.3. Combined Device And Simulator Binaries. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 325
24.9. Linking Frameworks. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 326
24.10. Embedding Frameworks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327
24.11. Limitations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 330
24.12. Recommended Practices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 331
Part III: The Bigger Picture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333
25. Finding Things . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 334
25.1. Finding Files And Paths . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 334
25.1.1. Apple-specific Behavior . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 339
25.1.2. Cross-compilation Controls . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 339
25.1.3. Validators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 341
25.2. Finding Paths . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 341
25.3. Finding Programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 342
25.4. Finding Libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 343
25.5. Finding Packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 345
25.5.1. Package Registries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 353
25.5.2. FindPkgConfig. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 355
25.6. Ignoring Search Paths. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 358
25.7. Debugging find_...() Calls . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 359
25.8. Recommended Practices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 359
26. Testing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 363
26.1. Defining And Executing A Simple Test . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 363
26.2. Test Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 366
26.3. Pass / Fail Criteria And Other Result Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 368
26.4. Test Grouping And Selection. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 371
26.4.1. Regular Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 371
26.4.2. Test Numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 372
26.4.3. Labels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 373
26.4.4. Repeating Tests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 374
26.5. Parallel Execution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 375
26.6. Managing Test Resources. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 377
26.6.1. Defining Test Resource Requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 378
26.6.2. Specifying Available System Resources . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 379
26.6.3. Using Resources Allocated To A Test . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 381
26.7. Test Dependencies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 382
26.8. Cross-compiling And Emulators. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 385


26.9. Build And Test Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 386
26.10. CDash Integration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 388
26.10.1. Key CDash Concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 389
26.10.2. Executing Pipelines And Actions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 390
26.10.3. CTest Configuration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 392
26.10.4. Test Measurements And Results. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 396
26.11. Output Control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 398
26.12. GoogleTest . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 400
26.13. Recommended Practices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 405
27. Installing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 408
27.1. Directory Layout . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 409
27.1.1. Relative Layout . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 409
27.1.2. Base Install Location . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 411
27.2. Installing Project Targets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 413
27.2.1. Interface Properties. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 419
27.2.2. RPATH . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 420
27.2.3. Apple-specific Targets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 423
27.3. Installing Exports. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 426
27.4. Installing Imported Targets. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 430
27.5. Installing Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 431
27.5.1. File Sets. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 431
27.5.2. Explicit Public And Private Headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 434
27.5.3. Simple Files And Programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 435
27.5.4. Whole Directories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 436
27.6. Custom Install Logic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 439
27.7. Installing Dependencies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 440
27.7.1. Runtime Dependency Sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 440
27.7.2. InstallRequiredSystemLibraries Module . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 442
27.7.3. BundleUtilities And GetPrerequisites . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 443
27.8. Writing A Config Package File . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 443
27.8.1. Config Files For CMake Projects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 444
27.8.2. Config Files For Non-CMake Projects. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 452
27.9. Executing An Install . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 454
27.10. Recommended Practices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 454
28. Packaging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 458
28.1. Packaging Basics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 458
28.2. Components . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 463
28.3. Multi Configuration Packages. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 467
28.3.1. Multiple Build Directories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 467
28.3.2. Pass Multiple Configurations To cpack . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 468
28.4. Package Generators. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 469


28.4.1. Simple Archives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 470
28.4.2. Qt Installer Framework (IFW). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 471
28.4.3. WIX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 477
28.4.4. NSIS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 479
28.4.5. DragNDrop. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 481
28.4.6. productbuild . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 483
28.4.7. RPM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 485
28.4.8. DEB . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 489
28.4.9. FreeBSD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 490
28.4.10. Cygwin . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 490
28.4.11. NuGet . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 491
28.4.12. External . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 491
28.5. Recommended Practices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 491
29. ExternalProject . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 494
29.1. High Level Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 494
29.2. Directory Layout . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 496
29.3. Built-in Steps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 497
29.3.1. Archive Downloads . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 497
29.3.2. Repository Download Methods. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 499
29.3.3. Configuration Step . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 501
29.3.4. Build Step . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 502
29.3.5. Install Step . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 502
29.3.6. Test Step . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 503
29.4. Step Management . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 503
29.5. Miscellaneous Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 506
29.6. Common Issues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 508
29.7. ExternalData . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 511
29.8. Recommended Practices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 511
30. FetchContent. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 513
30.1. Comparison With ExternalProject. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 513
30.2. Basic Usage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 514
30.3. Resolving Dependencies. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 515
30.4. Integration With find_package() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 517
30.4.1. Try find_package() Before FetchContent . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 518
30.4.2. Redirect find_package() To FetchContent. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 520
30.4.3. Redirections Directory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 521
30.5. Developer Overrides . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 524
30.6. Other Uses For FetchContent. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 526
30.7. Restrictions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 528
30.8. Recommended Practices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 528
31. Making Projects Consumable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 530


31.1. Use Project-specific Names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 530
31.2. Don’t Assume A Top Level Build . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 532
31.3. Avoid Hard-coding Developer Choices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 533
31.4. Avoid Package Variables If Possible . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 534
31.5. Use Appropriate Methods To Obtain Dependencies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 535
31.6. Recommended Practices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 536
32. Dependency Providers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 537
32.1. Top Level Setup Injection Point . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 537
32.2. Dependency Provider Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 538
32.2.1. Accepting find_package() Requests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 539
32.2.2. Accepting FetchContent_MakeAvailable() Requests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 541
32.2.3. Accepting Multiple Request Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 542
32.2.4. Wrapping The Built-in Implementations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 543
32.2.5. Preserving Variable Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 543
32.2.6. Delegating Providers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 544
32.3. Recommended Practices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 545
33. Presets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 547
33.1. High Level Structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 547
33.2. Configure Presets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 549
33.2.1. Essential Fields . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 549
33.2.2. Inheritance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 550
33.2.3. Macros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 552
33.2.4. Environment Variables. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 553
33.2.5. Toolchains . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 553
33.2.6. Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 555
33.3. Build Presets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 557
33.4. Test Presets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 558
33.5. Package Presets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 559
33.6. Workflow Presets. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 560
33.7. Recommended Practices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 562
34. Project Organization. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 564
34.1. Superbuild Structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 564
34.2. Non-superbuild Structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 566
34.3. Common Top Level Subdirectories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 568
34.4. IDE Projects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 569
34.5. Defining Targets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 572
34.5.1. Building Up A Target Across Directories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 574
34.5.2. Target Output Locations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 576
34.6. Windows-specific Issues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 577
34.7. Cleaning Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 579
34.8. Re-running CMake On File Changes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 579


34.9. Injecting Files Into Projects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 580
34.10. Recommended Practices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 581
35. Build Performance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 584
35.1. Unity Builds. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 584
35.1.1. BATCH Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 585
35.1.2. GROUP Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 587
35.2. Precompiled Headers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 588
35.3. Build Parallelism . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 589
35.3.1. Makefiles Generators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 590
35.3.2. Ninja Generators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 590
35.3.3. Visual Studio Generators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 593
35.3.4. Xcode Generator. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 595
35.3.5. Optimizing Build Dependencies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 595
35.4. Compiler Caches. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 597
35.4.1. Ccache Configuration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 598
35.4.2. Makefiles And Ninja Generators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 599
35.4.3. Xcode Generator. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 600
35.4.4. Visual Studio Generators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 601
35.4.5. Combined Generator Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 602
35.5. Debug-related Improvements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 602
35.6. Alternative Linkers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 603
35.7. Recommended Practices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 604
36. Working With Qt . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 607
36.1. Basic Setup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 607
36.2. Build Details . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 609
36.2.1. Standard Library Implementation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 609
36.2.2. Position Independent Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 609
36.2.3. Windows GUI Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 610
36.3. Autogen . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 610
36.3.1. Moc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 611
36.3.2. Widgets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 615
36.3.3. Resources . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 616
36.4. Translations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 618
36.5. Deployment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 621
36.5.1. Qt Deployment Tools . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 621
36.5.2. Deploying Translation Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 623
36.5.3. Linux Considerations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 625
36.6. Transition To Qt 6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 625
36.7. Recommended Practices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 626
Appendix A: Timer Dependency Provider . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 628
Appendix B: Full Compiler Cache Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 629


Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 632


Preface
Back around 2016, I was surprised at the lack of published material for learning how to use CMake. The official reference documentation was a useful resource for those willing to go exploring, but as a way of learning CMake in a progressive, structured manner, it was not ideal. There were some wikis and personal websites that had some useful contents, but there were also many that contained out-of-date or questionable advice and examples. There was a distinct gap, which meant those new to CMake had a hard time learning good practices, leading to many becoming overwhelmed or frustrated.
At the time, I had been writing some blog articles to do something more productive with my spare time and to deepen my own technical knowledge around software development. I frequently wrote about areas that came up in my interaction with colleagues at work or in my own development activities and I found this to be both rewarding and useful to others. As that pattern repeated itself, the idea of writing a book was born. Fast-forward two and a half years and the result is this book.
Along the way, there was a classic pivotal moment which I now look back on with some degree of amusement. A colleague bemoaned a particular feature that he wished CMake had. It burrowed its way into my brain and sat there for a few months until one day I decided to explore how hard it would be to add that feature myself. That culminated in the test fixtures feature that is now a part of CMake. More importantly though, I was really struck by the positive experience I had while making that contribution. The people, the tools and the processes in place made working on the project truly a pleasure. From there, I became more deeply involved and now fulfill the role of volunteer co-maintainer.
Acknowledgments
It is only when you come to thank all those who have contributed to the process of getting your book released that you realize just how many people have been involved. A work like this doesn’t happen without the generosity, patience and insight of others, nor does it succeed without being challenged, tested and reworked. It relies on those who were kind enough to (sometimes unknowingly!) get involved in these activities as much as it does on the author. I cannot thank these people enough for their kindness and wisdom.
The CMake community wouldn’t be as strong and as vibrant as it is today without the ongoing support of Kitware and its staff, both past and present. I’d like to make special mention of Brad King, the CMake project leader, who through his inclusive and encouraging approach to handling new CMake contributors has made people like myself very welcome and feel empowered to get involved. I have personally learned much from him just by observing the way he interacts with developers and users, providing strong leadership and fostering an environment of respect for others. It also goes without saying that the many contributors to CMake over the years also deserve much praise for their efforts, often made on a purely voluntary basis. I’m humbled by the scale of contributions that have been made by so many and by the positive impact on the world of software development.
A number of people generously agreed to review the material in this book, without whom both technical accuracy and readability would have suffered. Any remaining errors and deficiencies are squarely my own. Fellow CMake developers Gregor Jasny and Christian Pfeiffer were valuable
1


contributors throughout the review process for the first publication. I am truly grateful for their suggestions and insights. Thanks also to Nils Gladitz for his input, especially at such short notice before the first publication. I’d also like to thank my past colleagues, Matt Bolger and Lachlan Hetherton, both of whom provided constructive feedback and reminded me of the importance of a fresh set of eyes.
A number of people have generously reviewed chapters for subsequent editions. Many of these people are also CMake contributors or maintainers, and I am grateful for both their time reviewing this book and in improving CMake itself. Thanks to Cristian Adam for reviewing Chapter 35, Build Performance and Chapter 36, Working With Qt, and to Tobias Hunger, Alexandru Croitor, Joerg Bornemann, Sebastian Holtermann and Burkhard Stubert, all of whom also reviewed the material on Qt at various stages. Alex Turbov provided valuable comments and suggestions for new and updated material in the 7th edition. Marc Chevrier was kind enough to review material for the 7th and 13th editions. Adriaan de Groot, Nagy-Egri Máté Ferenc, Michael Platings and Luis Caro Campos all provided feedback on the 13th edition at short notice, for which I am very thankful.
The helpful feedback received from readers is also much appreciated. I’d like to make particular mention of the efforts of Declan Moran and Ganesh A. Hegde, both of whom highlighted a number of improvements and corrections.
A special mention is deserved for my past colleague Mike Wake. Much of the material in this book was thrashed out and tested in real, actively developed production projects. There have been wrong turns and many technical discussions on how to improve things from both a usability and robustness perspective. His support in giving the space and encouragement to work through these things and his willingness to wear some short-term (and sometimes not-so-short-term) pain have been an instrumental part of distilling many processes and techniques down to what works in practice. I am also very grateful for the timely words of advice and encouragement delivered at just the right time during some of the more stressful and exhausting periods around the earlier editions.
I would also like to express my gratitude to the people behind Asciidoctor, the software used to compile and prepare this book. Despite the size, complexity and technical nature of the material, I have been constantly amazed at how it has made self-publishing not just a viable option, but also an enjoyable experience with surprisingly few practical limitations. The path from author to reader is now so much shorter and simpler than when I initially began work on this book. Thanks for the awesome tool!
The book’s cover and some supporting material on the website are the result of a better eye and understanding of graphical design than my own. To my friend and designer, V, the way you somehow managed to make sense of my random, disconnected ideas and conflicting snippets still baffles me. I don’t understand how you do it, but I do like the end result!
In every book’s acknowledgments section, the author invariably thanks family members and spouses, and there’s good reason for that. It takes a huge amount of understanding and sacrifice to tolerate your tiredness, your unavailability to do many of the things ordinary people get to do and your unreasonable decision to devote more time to a project than to them. I truly cannot express the depth of my gratitude to my wife for the way she has managed to be so supportive and patient throughout the process of getting this book written, published and regularly updated. I am indeed a very fortunate human being.
2


Part I: Fundamentals
Attempting to use any tool before understanding at least the basics of what it does and how it is meant to be used is most likely going to result in frustration. On the other hand, spending all one’s time learning the theory about something without getting hands-on makes for a rather boring experience and often leads to an overly idealistic understanding. This first part of the book follows a logical progression through CMake’s more fundamental features and concepts and is structured to enable the reader to immediately experiment and to do increasingly useful things with each chapter. The goal is to incrementally build up the base knowledge needed to use CMake effectively, with an emphasis on being able to put that knowledge into practice right away.
The initial focus in the first few chapters is on building a basic executable or library, covering just enough to give a new developer a quick introduction to CMake. Subsequent chapters expand that knowledge to demonstrate how to get the most out of what CMake has to offer. The techniques presented are aimed at real world use, with the intention of establishing good habits and teaching sound methods which scale to very large projects and can handle more complex scenarios.
The later parts of the book all rely heavily on the material covered in this first part. Those who have already been using CMake for some time may find the topics relatively familiar, but the material also includes hard-won knowledge from real world projects and interaction with the CMake community. Even experienced users should find at least the Recommended Practices section at the end of each chapter to be a useful read.
3


Chapter 1. Introduction
Whether a seasoned developer or just starting out in a software career, one cannot avoid the process of becoming familiar with a range of tools in order to turn a project’s source code into something an end user can actually use. Compilers, linkers, testing frameworks, packaging systems and more all contribute to the complexity of deploying high quality, robust software. While some platforms have a dominant IDE environment that simplifies some aspects of this (e.g. Xcode and Visual Studio), projects that need to support multiple platforms cannot always make use of their features. Having to support multiple platforms adds more complications that can affect everything from the set of available tools through to the different capabilities available and restrictions enforced. A typical developer could be forgiven for losing at least some of their sanity trying to keep on top of the whole picture.
Fortunately, there are tools that make taming the process more manageable. CMake is one such tool, or more accurately, CMake is a suite of tools which covers everything from setting up a build right through to producing packages ready for distribution. Not only does it cover the process from start to end, it also supports a wide range of platforms, tools and languages. When working with CMake, it helps to understand its view of the world. Loosely speaking, the start to end process according to CMake looks something like this:
CMake CTest CPack
Project File Generation
Build Test Package
Configure Generate
The first stage takes a generic project description and generates platform-specific project files suitable for use with the developer’s regular build tool of choice (e.g. make, Xcode, Visual Studio, etc.). While this setup stage is what CMake is best known for, the CMake suite of tools also includes CTest and CPack for managing the later testing and packaging stages respectively. The entire process from start to finish can be driven from CMake itself, with the testing and packaging steps available simply as additional targets in the build. Even the build tool can be invoked by CMake.
Before jumping in and getting their hands dirty with CMake, developers will first need to ensure CMake is installed on their system. Some platforms may typically come with CMake already installed (eg most Linux distributions have CMake available through their package manager), but these versions are often quite old. Where possible, it is recommended that developers work with a recent CMake release. This is particularly true when developing for Apple platforms where tools like Xcode and its SDKs change rapidly and where app store requirements evolve over time. The official CMake packages can be downloaded and unpacked to a directory on the developer’s machine without interfering with any system-wide CMake install. Developers are encouraged to take advantage of this and remain relatively close to the most recent stable CMake release.
4


These days, CMake also comes with fairly extensive reference documentation which is accessible from the official CMake site. This useful resource is very helpful for looking up the various commands, options, keywords, etc. and developers will likely want to bookmark it for quick reference. The CMake forum is also a great source of advice and is the recommended place for asking CMake-related questions where the documentation doesn’t provide sufficient guidance.
5


Chapter 2. Setting Up A Project
Without a build system, a project is just a collection of files. CMake brings some order to this, starting with a human-readable file called CMakeLists.txt that defines what should be built and how, what tests to run and what package(s) to create. This file is a platform-independent description of the whole project, which CMake then turns into platform specific build tool project files. As its name suggests, it is just an ordinary text file which developers edit in their favorite text editor or development environment. The contents of this file are covered in great detail in subsequent chapters, but for now, it is enough to know that this is what controls everything that CMake will do in setting up and performing the build.
A fundamental part of CMake is the concept of a project having both a source directory and a binary directory. The source directory is where the CMakeLists.txt file is located and the project’s source files and all other files needed for the build are organized under that location. The source directory is frequently under version control with a tool like git, subversion, or similar.
The binary directory is where everything produced by the build is created. It is often also called the build directory. For reasons that will become clear in later chapters, CMake generally uses the term binary directory, but among developers, the term build directory tends to be in more common use. This book tends to prefer the latter term since it is generally more intuitive. CMake, the chosen build tool (e.g. make, Visual Studio, etc.), CTest and CPack will all create various files within the build directory and subdirectories below it. Executables, libraries, test output and packages are all created within the build directory. CMake also creates a special file called CMakeCache.txt in the build directory to store various information for reuse on subsequent runs. Developers won’t normally need to concern themselves with the CMakeCache.txt file, but later chapters will discuss situations where this file is relevant. The build tool’s project files (e.g. Xcode or Visual Studio project files, Makefiles, etc.) are also created in the build directory and are not intended to be put under version control. The CMakeLists.txt files are the canonical description of the project and the generated project files should be considered part of the build output.
When a developer commences work on a project, they must decide where they want their build directory to be in relation to their source directory. There are essentially two approaches: in-source and out-of-source builds.
2.1. In-source Builds
It is possible, though discouraged, for the source and build directories to be the same. This arrangement is called an in-source build. Developers at the beginning of their career often start out using this approach because of the perceived simplicity. The main difficulty with in-source builds, however, is that all the build outputs are intermixed with the source files. This lack of separation causes directories to become cluttered with all sorts of files and subdirectories, making it harder to manage the project sources and running the risk of build outputs overwriting source files. It also makes working with version control systems more difficult, since there are lots of files created by the build which either the source control tool has to know to ignore or the developer has to manually exclude during commits. One other drawback to in-source builds is that it can be nontrivial to clear out all build output and start again with a clean source tree. For these reasons, developers are discouraged from using in-source builds where possible, even for simple projects.
6


2.2. Out-of-source Builds
The more preferable arrangement is for the source and build directories to be different, which is called an out-of-source build. This keeps the sources and the build outputs completely separate from each other, thus avoiding the intermixing problems experienced with in-source builds. Out-ofsource builds also have the advantage that the developer can create multiple build directories for the same source directory, which allows builds to be set up with different sets of options, such as debug and release versions, etc.
This book will always use out-of-source builds and will follow the pattern of the source and build directories being under a common parent. The build directory will be called build, or some variation thereof. For example:
A variation on this used by some developers is to make the build directory a subdirectory of the source directory. This offers most of the advantages of an out-of-source build, but it does still carry with it some of the disadvantages of an in-source arrangement. Unless there is a good reason to structure things that way, keeping the build directory completely outside of the source tree instead is recommended.
2.3. Generating Project Files
Once the choice of directory structure has been made, the developer runs CMake, which reads in the CMakeLists.txt file and creates project files in the build directory. The developer selects the type of project file to be created by choosing a particular project file generator. A range of different generators are supported, with the more commonly used ones listed in the table below.
Category Generator Examples Multi-config
Visual Studio Visual Studio 17 2022 Yes
Visual Studio 16 2019
⋮
Xcode Xcode Yes
Ninja Ninja No
Ninja Multi-Config Yes
Makefiles Unix Makefiles No
MSYS Makefiles
MinGW Makefiles
NMake Makefiles
7


Some generators produce projects which support multiple configurations (e.g. Debug, Release, etc.). These allow the developer to choose between different build configurations without having to rerun CMake, which is more suitable for generators creating projects for use in IDE environments like Xcode and Visual Studio. For generators which do not support multiple configurations, the developer has to re-run CMake to switch the build between Debug, Release, etc. These are simpler and often have good support in IDE environments not so closely associated with a particular compiler (CLion, Qt Creator, KDevelop, etc.).
The most basic way to run CMake is via the cmake command line utility. The simplest way to invoke it is to change to the build directory and pass options to cmake for the generator type and location of the source tree. For example:
mkdir build cd build cmake -G "Unix Makefiles" ../source
If the -G option is omitted, CMake will choose a default generator type based on the host platform. If using CMake 3.15 or later, this default can be overridden by setting the CMAKE_GENERATOR environment variable to the desired default instead. For all generator types, CMake will carry out a series of tests to determine how to set up the project files. This includes things like verifying that the compilers work, determining the set of supported compiler features and various other tasks. A variety of information will be logged before CMake finishes with lines like the following upon success:
-- Configuring done -- Generating done -- Build files have been written to: /some/path/build
The above highlights that project file creation actually involves two steps; configuring and generating. During the configuring phase, CMake reads in the CMakeLists.txt file and builds up an internal representation of the entire project. After this is done, the generation phase creates the project files. The distinction between configuring and generating doesn’t matter so much for basic CMake usage, but in later chapters the separation of configuration and generation becomes important. This is covered in more detail in Chapter 10, Generator Expressions.
When CMake has completed its run, it will have saved a CMakeCache.txt file in the build directory. CMake uses this file to save details so that if it is run again, it can re-use information computed the first time and speed up the project generation. As covered in later chapters, it also allows developer options to be saved between runs. A GUI application, cmake-gui, is available as an alternative to running the cmake command line tool, but the introduction of the GUI application is deferred to Chapter 5, Variables where its usefulness is more clearly evident.
2.4. Running The Build Tool
At this point, with project files now available, the developer can use their selected build tool in the way to which they are accustomed. The build directory will contain the necessary project files which can be loaded into an IDE, read by command line tools, etc. Alternatively, cmake can invoke the build tool on the developer’s behalf like so:
8


cmake --build /pathTo/build --config Debug --target MyApp
This works even for project types the developer may be more accustomed to using through an IDE like Xcode or Visual Studio. The --build option points to the build directory used by the CMake project generation step. For multi configuration generators, the --config option specifies which configuration to build, whereas single configuration generators will ignore the --config option and rely instead on information provided when the CMake project generation step was performed. Specifying the build configuration is covered in depth in Chapter 14, Build Type. The --target option can be used to tell the build tool what to build, or if omitted, the default target will be built. With CMake 3.15 or later, multiple targets can be listed after the --target option, separated by spaces.
While developers will typically invoke their selected build tool directly in day-to-day development, invoking it via the cmake command as shown above can be more useful in scripts driving an automated build. Using this approach, a simple scripted build might look something like this:
mkdir build cd build cmake -G "Unix Makefiles" ../source cmake --build . --config Release --target MyApp
If the developer wishes to experiment with different generators, all that needs to be done is change the argument given to the -G CMake option and the correct build tool will be automatically invoked. The build tool doesn’t even have to be on the user’s PATH for cmake --build to work (although it may need to be for the initial configuration step when cmake is first invoked).
2.5. Recommended Practices
Even when first starting out using CMake, it is advisable to make a habit of keeping the build directory completely separate from the source tree. A good way to get early experience of the benefits of such an arrangement is to set up two or more different builds for the same source directory. One build could be configured with Debug settings, the other for a Release build. Another option is to use different project generators for the different build directories, such as Unix Makefiles and Xcode. This can help to catch any unintended dependencies on a particular build tool or to check for differing compiler settings between generator types.
It can be tempting to focus on using one particular type of project generator in the early stages of a project, especially if the developer is not accustomed to writing cross-platform software. Projects do, however, have a habit of growing beyond their initial scope and it is relatively common to need to support additional platforms and generator types. Periodically checking the build with a different project generator than the one a developer usually uses can save considerable future pain by discouraging generator-specific code where it isn’t required. This also has the benefit of making the project well placed to take advantage of any new generator type in the future. A good strategy is to ensure the project builds with the default generator type on each platform of interest, plus one other type. The Ninja generator is an excellent choice for the latter, since it has the broadest platform support of all the generators and it also creates very efficient builds. If the project is being scripted, invoke the build tool via cmake --build instead of invoking the build tool directly. This allows the script to easily switch between generator types without having to be modified.
9


Chapter 3. A Minimal Project
All CMake projects start with a file called CMakeLists.txt and it is expected to be placed at the top of the source tree. Think of it as the CMake project file, defining everything about the build from sources and targets through to testing, packaging and other custom tasks. It can be as simple as a few lines or it can be quite complex and pull in more files from other directories. CMakeLists.txt is just an ordinary text file and is usually edited directly, just like any other source file in the project.
Continuing the analogy with sources, CMake defines its own language which has many things a programmer would be familiar with, such as variables, functions, macros, conditional logic, looping, code comments and so on. These various concepts and features are covered in the next few chapters, but for now, the goal is just to get a simple build working as a starting point. The following is a minimal, well-formed CMakeLists.txt file producing a basic executable.
cmake_minimum_required(VERSION 3.2) project(MyApp) add_executable(MyExe main.cpp)
Each line in the above example executes a built-in CMake command. In CMake, commands are similar to other languages’ function calls, except that while they support arguments, they do not return values directly (but a later chapter shows how to pass values back to the caller in other ways). Arguments are separated from each other by spaces and may be split across multiple lines:
add_executable(MyExe main.cpp src1.cpp src2.cpp )
Command names are also case insensitive, so the following are all equivalent:
add_executable(MyExe main.cpp) ADD_EXECUTABLE(MyExe main.cpp) Add_Executable(MyExe main.cpp)
Typical style varies, but the more common convention these days is to use all lowercase for command names (this is also the convention followed by the CMake documentation for built-in commands).
3.1. Managing CMake Versions
CMake is continually updated and extended to add support for new tools, platforms and features. The developers behind CMake are very careful to maintain backwards compatibility with each new release, so when users update to a newer version of CMake, projects should continue to build as they did before. Sometimes, a particular CMake behavior needs to change or more stringent checks and warnings may be introduced in newer versions. Rather than requiring all projects to
10


immediately deal with this, CMake provides policy mechanisms which allow the project to say “Behave like CMake version X.Y.Z”. This allows CMake to fix bugs internally and introduce new features, but still maintain the expected behavior of any particular past release.
The primary way a project specifies details about its expected CMake version behavior is with the cmake_minimum_required() command. This should be the first line of the CMakeLists.txt file so that the project’s requirements are checked and established before anything else. This command does two things:
• It specifies the minimum version of CMake the project needs. If the CMakeLists.txt file is processed with a CMake version older than the one specified, it will halt immediately with an error. This ensures that a particular minimum set of CMake functionality is available before proceeding.
• It enforces policy settings to match CMake behavior to the specified version.
Using this command is so important that CMake will issue a warning if the CMakeLists.txt file does not call cmake_minimum_required() before any other command. It needs to know how to set up the policy behavior for all subsequent processing. For most projects, it is enough to treat cmake_minimum_required() as simply specifying the minimum required CMake version, as its name suggests. The fact that it also implies CMake should behave the same as that particular version can be considered a useful side benefit. Chapter 12, Policies discusses policy settings in more detail and explains how to tailor this behavior as needed.
The typical form of the cmake_minimum_required() command is straightforward:
cmake_minimum_required(VERSION major.minor[.patch[.tweak]])
The VERSION keyword must always be present and the version details provided must have at least the major.minor part. In most projects, specifying the patch and tweak parts is not necessary, since new features typically only appear in minor version updates (this is the official CMake behavior from version 3.0 onward). Only if a specific bug fix is needed should a project specify a patch part. Furthermore, since no CMake release in the 3.x series has used a tweak number, projects should not need to specify one either.
Developers should think carefully about what minimum CMake version their project should require. Version 3.2 is perhaps the oldest any new project should consider, since it provides a reasonably complete feature set for modern CMake techniques. Version 2.8.12 has a reduced feature coverage, lacking a number of useful features but it may be workable for older projects. Versions before that lack substantial features that would make using many modern CMake techniques impossible. If working with fast-moving platforms such as iOS, quite recent versions of CMake may be needed in order to support the latest OS releases, etc.
As a general rule of thumb, choose the most recent CMake version that won’t present significant problems for those building the project. The greatest difficulty is typically experienced by projects that need to support older platforms where the system-provided version of CMake may be quite old. For such cases, if at all possible, developers should consider installing a more recent release rather than restricting themselves to very old CMake versions. On the other hand, if the project will itself be a dependency for other projects, then choosing a more recent CMake version may present
11


a hurdle for adoption. In such cases, it may be beneficial to instead require the oldest CMake version that still provides the minimum CMake features needed, but make use of features from later CMake versions if available (Chapter 12, Policies presents techniques for achieving this). This will prevent other projects from being forced to require a more recent version than their target environment typically allows or provides. Dependent projects can always require a more recent version if they so wish, but they cannot require an older one. The main disadvantage of using the oldest workable version is that it may result in more deprecation warnings, since newer CMake versions will warn about older behaviors to encourage projects to update themselves.
3.2. The project() Command
Every CMake project should contain a project() command and it should appear after cmake_minimum_required() has been called. The command with its most common options has the following form:
project(projectName [VERSION major[.minor[.patch[.tweak]]]] [LANGUAGES languageName ...] )
The projectName is required and may only contain letters, numbers, underscores (_) and hyphens (-), although typically only letters and perhaps underscores are used in practice. Since spaces are not permitted, the project name does not have to be surrounded by quotes. This name is used for the top level of a project with some project generators (eg Xcode and Visual Studio) and it is also used in various other parts of the project, such as to act as defaults for packaging and documentation metadata, to provide project-specific variables and so on. The name is the only mandatory argument for the project() command.
The optional VERSION details are only supported in CMake 3.0 and later. Like the projectName, the version details are used by CMake to populate some variables and as default package metadata, but other than that, the version details don’t have any other significance. Nonetheless, a good habit to establish is to define the project’s version here so that other parts of the project can refer to it. Chapter 21, Specifying Version Details covers this in depth and explains how to refer to this version information later in the CMakeLists.txt file.
The optional LANGUAGES argument defines the programming languages that should be enabled for the project. Supported values include C, CXX, Fortran, ASM, CUDA and others. If specifying multiple languages, separate each with a space. In some special situations, projects may want to indicate that no languages are used, which can be done using LANGUAGES NONE. Techniques introduced in later chapters take advantage of this particular form. If no LANGUAGES option is provided, CMake will default to C and CXX. CMake versions prior to 3.0 do not support the LANGUAGES keyword, but languages can still be specified after the project name using the older form of the command like so:
project(MyProj C CXX)
New projects are encouraged to specify a minimum CMake version of at least 3.0 and use the new form with the LANGUAGES keyword instead.
12


The project() command does much more than just populate a few variables. One of its important responsibilities is to check the compilers for each enabled language and ensure they are able to compile and link successfully. Problems with the compiler and linker setup are then caught very early. Once these checks have passed, CMake sets up a number of variables and properties which control the build for the enabled languages. Chapter 23, Toolchains And Cross Compiling discusses this area in much greater detail, including the various ways to influence toolchain selection and configuration. Chapter 7, Using Subdirectories also discusses additional considerations and requirements that affect the use of the project() command.
When the compiler and linker checks performed by CMake are successful, their results are cached so that they do not have to be repeated in subsequent CMake runs. These cached details are stored in the build directory in the CMakeCache.txt file. Additional details about the checks can be found in subdirectories within the build area, but developers would typically only need to look there if working with a new or unusual compiler or when setting up toolchain files for cross-compiling.
3.3. Building A Basic Executable
To complete our minimal example, the add_executable() command tells CMake to create an executable from a set of source files. The basic form of this command is:
add_executable(targetName source1 [source2 ...])
This creates an executable which can be referred to within the CMake project as targetName. This name may contain letters, numbers, underscores and hyphens. When the project is built, an executable will be created in the build directory with a platform-dependent name, the default name being based on the target name. Consider the following simple example command:
add_executable(MyApp main.cpp)
By default, the name of the executable would be MyApp.exe on Windows and MyApp on Unix-based platforms like macOS, Linux, etc. The executable name can be customized with target properties, a CMake feature introduced in Chapter 9, Properties. Multiple executables can also be defined within the one CMakeLists.txt file by calling add_executable() multiple times with different target names. If the same target name is used in more than one add_executable() command, CMake will fail and highlight the error.
3.4. Commenting
Before leaving this chapter, it will be useful to demonstrate how to add comments to a CMakeLists.txt file. Comments are used extensively throughout this book and developers are encouraged to also get into the habit of commenting their projects just as they would for ordinary source code. CMake follows similar commenting conventions as Unix shell scripts. Any line beginning with a # character is treated as a comment. Except within a quoted string, anything after a # on a line within a CMakeLists.txt file is also treated as a comment. The following shows a few comment examples and brings together the concepts introduced in this chapter:
13


cmake_minimum_required(VERSION 3.2)
# We don't use the C++ compiler, so don't let project() # test for it in case the platform doesn't have one project(MyApp VERSION 4.7.2 LANGUAGES C)
# Primary tool for this project add_executable(MainTool main.c debug.c # Optimized away for release builds )
# Helpful diagnostic tool for development and testing add_executable(TestTool testTool.c)
3.5. Recommended Practices
Ensure every CMake project has a cmake_minimum_required() command as the first line of its top level CMakeLists.txt file. When deciding the minimum required version number to specify, keep in mind that the later the version, the more CMake features the project will be able to use. It will also mean the project is likely to be better placed to adapt to new platform or operating system releases, which inevitably introduce new things for build systems to deal with. Conversely, if creating a project intended to be built and distributed as part of the operating system itself (common for Linux), the minimum CMake version is likely to be dictated by the version of CMake provided by that same distribution.
If the project can require CMake 3.0 or later, it is also good to force thinking about project version numbers early and start incorporating version numbering into the project() command as soon as possible. It can be very hard to overcome the inertia of existing processes and change how version numbers are handled later in the life of a project. Consider popular practices such as Semantic Versioning when deciding on a versioning strategy.
14


Chapter 4. Building Simple Targets
As shown in the previous chapter, it is relatively straightforward to define a simple executable in CMake. The simple example given previously required defining a target name for the executable and listing the source files to be compiled:
add_executable(MyApp main.cpp)
This assumes the developer wants a basic console executable to be built, but CMake also allows the developer to define other types of executables, such as app bundles on Apple platforms and Windows GUI applications. This chapter discusses additional options which can be given to add_executable() to specify these details.
In addition to executables, developers also frequently need to build and link libraries. CMake supports a few different kinds of libraries, including static, shared, modules and frameworks. CMake also offers very powerful features for managing dependencies between targets and how libraries are linked. This whole area of libraries and how to work with them in CMake forms the bulk of this chapter. The concepts covered here are used extensively throughout the remainder of this book. Some very basic use of variables and properties are also given to provide a flavor for how these CMake features relate to libraries and targets in general.
4.1. Executables
The more complete form of the basic add_executable() command is as follows:
add_executable(targetName [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] source1 [source2 ...] )
The only differences to the form shown previously are the new optional keywords.
WIN32
When building the executable on a Windows platform, this option instructs CMake to build the executable as a Windows GUI application. In practice, this means it will be created with a WinMain() entry point instead of just main() and it will be linked with the /SUBSYSTEM:WINDOWS option. On all other platforms, the WIN32 option is ignored.
MACOSX_BUNDLE
When present, this option directs CMake to build an app bundle when building on an Apple platform. Contrary to what the option name suggests, it applies not just to macOS, but also to other Apple platforms like iOS as well. The exact effects of this option vary somewhat between platforms. For example, on macOS, the app bundle layout has a very specific directory structure, whereas on iOS, the directory structure is flattened. CMake will also generate a basic Info.plist file for bundles. These and other details are covered in more detail in Section 24.2, “Application Bundles”. On non-Apple platforms, the MACOSX_BUNDLE keyword is ignored.
15


EXCLUDE_FROM_ALL
Sometimes, a project defines a number of targets, but by default only some of them should be built. When no target is specified at build time, the default ALL target is built (depending on the CMake generator being used, the name may be slightly different, such as ALL_BUILD for Xcode). If an executable is defined with the EXCLUDE_FROM_ALL option, it will not be included in that default ALL target. The executable will then only be built if it is explicitly requested by the build command or if it is a dependency for another target that is part of the default ALL build. A common situation where it can be useful to exclude a target from ALL is where the executable is a developer tool that is only needed occasionally.
In addition to the above, there are other forms of the add_executable() command which produce a kind of reference to an existing executable or target rather than defining a new one to be built. These alias executables are covered in detail in Chapter 18, Target Types.
4.2. Defining Libraries
Creating simple executables is a fundamental need of any build system. For many larger projects, the ability to create and work with libraries is also essential to keep the project manageable. CMake supports building a variety of different kinds of libraries, taking care of many of the platform differences, but still supporting the native idiosyncrasies of each. Library targets are defined using the add_library() command, of which there are a number of forms. The most basic of these is the following:
add_library(targetName [STATIC | SHARED | MODULE] [EXCLUDE_FROM_ALL] source1 [source2 ...] )
This form is analogous to how add_executable() is used to define a simple executable. The targetName is used within the CMakeLists.txt file to refer to the library, with the name of the built library on the file system being derived from this name by default. The EXCLUDE_FROM_ALL keyword has exactly the same effect as it does for add_executable(), namely to prevent the library from being included in the default ALL target. The type of library to be built is specified by one of the remaining three keywords
STATIC, SHARED or MODULE.
STATIC
Specifies a static library or archive. On Windows, the default library name would be targetName.lib, while on Unix-like platforms, it would typically be libtargetName.a.
SHARED
Specifies a shared or dynamically linked library. On Windows, the default library name would be targetName.dll, on Apple platforms it would be libtargetName.dylib and on other Unix-like platforms it would typically be libtargetName.so. On Apple platforms, shared libraries can also be marked as frameworks, a topic covered in Section 24.3, “Frameworks”.
MODULE
Specifies a library that is somewhat like a shared library, but is intended to be loaded
16


dynamically at run-time rather than being linked directly to a library or executable. These are typically plugins or optional components the user may choose to be loaded or not. On Windows platforms, no import library is created for the DLL.
It is possible to omit the keyword defining what type of library to build. Unless the project specifically requires a particular type of library, the preferred practice is to not specify it and leave the choice up to the developer when building the project. In such cases, the library will be either STATIC or SHARED, with the choice determined by the value of a CMake variable called BUILD_SHARED_LIBS. If BUILD_SHARED_LIBS has been set to true, the library target will be a shared library, otherwise it will be static. Working with variables is covered in detail in Chapter 5, Variables, but for now, one way to set this variable is by including a -D option on the cmake command line like so:
cmake -DBUILD_SHARED_LIBS=YES /path/to/source
It could be set in the CMakeLists.txt file instead with the following placed before any add_library() commands, but that would then require developers to modify it if they wanted to change it (i.e. it would be less flexible):
set(BUILD_SHARED_LIBS YES)
Just as for executables, library targets can also be defined to refer to some existing binary or target rather than being built by the project. Another type of pseudo-library is also supported for collecting together object files without going as far as creating a static library. These are all discussed in detail in Chapter 18, Target Types.
4.3. Linking Targets
When considering the targets that make up a project, developers are typically used to thinking in terms of library A needing library B, so A is linked to B. This is the traditional way of looking at library handling, where the idea of one library needing another is very simplistic. In reality, however, there are a few different types of dependency relationships that can exist between libraries:
PRIVATE
Private dependencies specify that library A uses library B in its own internal implementation. Anything else that links to library A doesn’t need to know about B because it is an internal implementation detail of A.
PUBLIC
Public dependencies specify that not only does library A use library B internally, it also uses B in its interface. This means that A cannot be used without B, so anything that uses A will also have a direct dependency on B. An example of this would be a function defined in library A which has at least one parameter of a type defined and implemented in library B, so code cannot call the function from A without providing a parameter whose type comes from B.
17


INTERFACE
Interface dependencies specify that in order to use library A, parts of library B must also be used. This differs from a public dependency in that library A doesn’t require B internally, it only uses B in its interface. An example of where this is useful is when working with library targets defined using the INTERFACE form of add_library(), such as when using a target to represent a header-only library’s dependencies (see Section 18.2.4, “Interface Libraries”).
CMake captures this richer set of dependency relationships with its target_link_libraries() command, not just the simplistic idea of needing to link. The general form of the command is:
target_link_libraries(targetName <PRIVATE|PUBLIC|INTERFACE> item1 [item2 ...] [<PRIVATE|PUBLIC|INTERFACE> item3 [item4 ...]] ... )
This allows projects to precisely define how one library depends on others. CMake then takes care of managing the dependencies throughout the chain of libraries linked in this fashion. For example, consider the following:
add_library(Collector src1.cpp) add_library(Algo src2.cpp) add_library(Engine src3.cpp) add_library(Ui src4.cpp) add_executable(MyApp main.cpp)
target_link_libraries(Collector PUBLIC Ui PRIVATE Algo Engine )
target_link_libraries(MyApp PRIVATE Collector)
In this example, the Ui library is linked to the Collector library as PUBLIC, so even though MyApp only directly links to Collector, MyApp will also be linked to Ui because of that PUBLIC relationship. The Algo and Engine libraries, on the other hand, are linked to Collector as PRIVATE, so MyApp will not be directly linked to them. Section 18.2, “Libraries” discusses additional behaviors for static libraries which may result in further linking to satisfy dependency relationships, including cyclic dependencies.
Later chapters present a few other target_...() commands which further enhance the dependency information carried between targets. These allow compiler/linker flags and header search paths to also carry through from one target to another when they are connected by target_link_libraries(). These features were added progressively from CMake 2.8.11 through to 3.2 and lead to considerably simpler and more robust CMakeLists.txt files.
Later chapters also discuss the use of more complex source directory hierarchies. In such cases, if using CMake 3.12 or earlier, the targetName used with target_link_libraries() must have been defined by an add_executable() or add_library() command in the same directory from which target_link_libraries() is being called (this restriction was removed in CMake 3.13).
18


4.4. Linking Non-targets
In the preceding section, all the items being linked to were existing CMake targets, but the target_link_libraries() command is more flexible than that. In addition to CMake targets, the following things can also be specified as items in a target_link_libraries() command:
Full path to a library file
CMake will add the library file to the linker command. If the library file changes, CMake will detect that change and re-link the target. Note that from CMake version 3.3, the linker command always uses the full path specified, but prior to version 3.3, there were some situations where CMake may ask the linker to search for the library instead (e.g. replace /usr/lib/libfoo.so with -lfoo). The reasoning and details of the pre-3.3 behavior are non-trivial and are largely historical, but for the interested reader, the full set of information is available in the CMake documentation under the CMP0060 policy.
Plain library name
If just the name of the library is given with no path, the linker command will search for that library (e.g. foo becomes -lfoo or foo.lib, depending on the platform). This would be common for libraries provided by the system.
Link flag
As a special case, items starting with a hyphen other than -l or -framework will be treated as flags to be added to the linker command. The CMake documentation warns that these should only be used for PRIVATE items, since they would be carried through to other targets if defined as PUBLIC or INTERFACE and this may not always be safe.
4.5. Old-style CMake
For historical reasons, any link item specified in target_link_libraries() may be preceded by one of the keywords debug, optimized or general. The effect of these keywords is to further refine when the item following it should be included based on whether the build is configured as a debug build (see Chapter 14, Build Type). If an item is preceded by the debug keyword, then it will only be added if the build is a debug build. If an item is preceded by the optimized keyword, it will only be added if the build is not a debug build. The general keyword specifies that the item should be added for all build configurations, which is the default behavior anyway if no keyword is used. The debug, optimized and general keywords should be avoided for new projects as there are clearer, more flexible and more robust ways to achieve the same thing with today’s CMake features.
The target_link_libraries() command also has a few other forms, some of which have been part of CMake from well before version 2.8.11. These forms are discussed here for the benefit of understanding older CMake projects, but their use is generally discouraged for new projects. The full form shown previously with PRIVATE, PUBLIC and INTERFACE sections should be preferred, as it expresses the nature of dependencies with more accuracy.
target_link_libraries(targetName item [item...])
19


The above form is generally equivalent to the items being defined as PUBLIC, but in certain situations, they may instead be treated as PRIVATE. In particular, if a project defines a chain of library dependencies with a mix of both old and new forms of the command, the old-style form will generally be treated as PRIVATE.
Another supported but deprecated form is the following:
target_link_libraries(targetName LINK_INTERFACE_LIBRARIES item [item...] )
This is a pre-cursor to the INTERFACE keyword of the newer form covered above, but its use is discouraged by the CMake documentation. Its behavior can affect different target properties, with the policy settings controlling that behavior. This is a potential source of confusion for developers which can be avoided by using the newer INTERFACE form instead.
target_link_libraries(targetName <LINK_PRIVATE|LINK_PUBLIC> lib [lib...] [<LINK_PRIVATE|LINK_PUBLIC> lib [lib...]] )
Similar to the previous old-style form, this one is a pre-cursor to the PRIVATE and PUBLIC keyword versions of the newer form. Again, the old-style form has the same confusion over which target properties it affects and the PRIVATE/PUBLIC keyword form should be preferred for new projects.
4.6. Recommended Practices
Target names need not be related to the project name. It is common to see tutorials and examples use a variable for the project name and reuse that variable for the name of an executable target:
# Poor practice, but very common set(projectName MyExample) project(${projectName}) add_executable(${projectName} ...)
This only works for the most basic of projects and encourages a number of bad habits. Consider the project name and executable name as being separate, even if initially they start out the same. Set the project name directly rather than via a variable, choose a target name according to what the target does rather than the project it is part of and assume the project will eventually need to define more than one target. This reinforces better habits which will be important when working on more complex multi-target projects.
When naming targets for libraries, resist the temptation to start or end the name with lib. On many platforms (i.e. just about all except Windows), a leading lib will be prefixed automatically when constructing the actual library name to make it conform to the platform’s usual convention. If the target name already begins with lib, the library file names end up with the form liblibsomething...., which people often assume to be a mistake.
20


Unless there are strong reasons to do so, try to avoid specifying the STATIC or SHARED keyword for a library until it is known to be needed. This allows greater flexibility in choosing between static or dynamic libraries as an overall project-wide strategy. The BUILD_SHARED_LIBS variable can be used to change the default in one place instead of having to modify every call to add_library().
Aim to always specify PRIVATE, PUBLIC and/or INTERFACE keywords when calling the target_link_libraries() command rather than following the old-style CMake syntax which assumed everything was PUBLIC. As a project grows in complexity, these three keywords have a stronger impact on how inter-target dependencies are handled. Using them from the beginning of a project also forces developers to think about the dependencies between targets, which can help to highlight structural problems within the project much earlier.
21


Chapter 5. Variables
The preceding chapters showed how to define basic targets and produce build outputs. On its own, this is already useful, but CMake comes with a whole host of other features which bring great flexibility and convenience. This chapter covers one of the most fundamental parts of CMake, namely the use of variables.
5.1. Variable Basics
Like any computing language, variables are a cornerstone of getting things done in CMake. The most basic way of defining a variable is with the set() command. A normal variable can be defined in a CMakeLists.txt file as follows:
set(varName value... [PARENT_SCOPE])
The name of the variable, varName, can contain letters, numbers and underscores, with letters being case-sensitive. The name may also contain the characters ./-+ but these are rarely seen in practice. Other characters are also possible via indirect means, but again, these are not typically seen in normal use.
In CMake, a variable has a particular scope, much like how variables in other languages have scope limited to a particular function, file, etc. A variable cannot be read or modified outside its own scope. Compared to other languages, variable scope is a little more flexible in CMake, but for now, consider the scope of a variable as being the file it is defined in. Section 5.4, “Scope Blocks” discusses how to define a local scope and pass information back up to enclosing scopes. Chapter 7, Using Subdirectories and Chapter 8, Functions And Macros introduce further situations where local scopes arise.
CMake treats all variables as strings. In various contexts, variables may be interpreted as a different type, but ultimately, they are just strings. When setting a variable’s value, CMake doesn’t require those values to be quoted unless the value contains spaces. If multiple values are given, the values will be joined together with a semicolon separating each value - the resultant string is how CMake represents lists. The following should help to demonstrate the behavior.
set(myVar a b c) # myVar = "a;b;c" set(myVar a;b;c) # myVar = "a;b;c" set(myVar "a b c") # myVar = "a b c" set(myVar a b;c) # myVar = "a;b;c" set(myVar a "b c") # myVar = "a;b c"
The value of a variable is obtained with ${myVar}, which can be used anywhere a string or variable is expected. CMake is particularly flexible in that it is also possible to use this form recursively or to specify the name of another variable to set. In addition, CMake doesn’t require variables to be defined before using them. Use of an undefined variable simply results in an empty string being substituted, similar to the way Unix shell scripts behave. By default, no warning is issued for use of an undefined variable, but the --warn-uninitialized option can be given to the cmake command to
22


enable such warnings. Be aware, however, that such use is very common and is not necessarily a symptom of a problem, so the option’s usefulness may be limited.
set(foo ab) # foo = "ab" set(bar ${foo}cd) # bar = "abcd" set(baz ${foo} cd) # baz = "ab;cd" set(myVar ba) # myVar = "ba" set(big "${${myVar}r}ef") # big = "${bar}ef" = "abcdef" set(${foo} xyz) # ab = "xyz" set(bar ${notSetVar}) # bar = ""
Strings are not restricted to being a single line, they can contain embedded newline characters. They can also contain quotes, which require escaping with backslashes.
set(myVar "goes here") set(multiLine "First line ${myVar} Second line with a \"quoted\" word")
If using CMake 3.0 or later, an alternative to quotes is to use the lua-inspired bracket syntax where the start of the content is marked by [=[ and the end with ]=]. Any number of = characters can appear between the square brackets, including none at all, but the same number of = characters must be used at the start and the end. If the opening brackets are immediately followed by a newline character, that first newline is ignored, but subsequent newlines are not. Furthermore, no further transformation of the bracketed content is performed (i.e. no variable substitution or escaping).
# Simple multi-line content with bracket syntax, # no = needed between the square bracket markers set(multiLine [[ First line Second line ]])
# Bracket syntax prevents unwanted substitution set(shellScript [=[ #!/bin/bash
[[ -n "${USER}" ]] && echo "Have USER" ]=])
# Equivalent code without bracket syntax set(shellScript "#!/bin/bash
[[ -n \"\${USER}\" ]] && echo \"Have USER\" ")
As the above example shows, bracket syntax is particularly well suited to defining content like Unix shell scripts. Such content uses the ${...} syntax for its own purpose and frequently contains quotes, but using bracket syntax means these things do not have to be escaped, unlike the traditional
23


quoting style of defining CMake content. The flexibility to use any number of = characters between the [ and ] markers also means embedded square brackets do not get misinterpreted as markers. Chapter 20, Working With Files includes further examples which highlight situations where bracket syntax can be a better alternative.
A variable can be unset either by calling unset() or by calling set() with no value for the named variable. The following are equivalent, with no error or warning if myVar does not already exist:
set(myVar) unset(myVar)
In addition to variables defined by the project for its own use, the behavior of many of CMake’s commands can be influenced by the value of specific variables at the time the command is called. This is a common pattern used by CMake to tailor command behavior or to modify defaults so they don’t have to be repeated for every command, target definition, etc. The CMake reference documentation for each command typically lists any variables which can affect that command’s behavior. Later chapters of this book also highlight a number of useful variables and the way they affect or give information about the build.
5.2. Environment Variables
CMake also allows the value of environment variables to be retrieved and set using a modified form of the CMake variable notation. The value of an environment variable is obtained using the special form $ENV{varName} and this can be used anywhere a regular ${varName} form can be used. Setting an environment variable can be done in a similar way to a CMake variable, except with ENV{varName} instead of just varName as the variable to set. For example:
set(ENV{PATH} "$ENV{PATH}:/opt/myDir")
Note, however, that setting an environment variable like this only affects the currently running CMake instance. As soon as the CMake run is finished, the change to the environment variable is lost. In particular, the change to the environment variable will not be visible at build time. Therefore, setting environment variables within the CMakeLists.txt file like this is rarely useful.
5.3. Cache Variables
In addition to normal variables discussed above, CMake also supports cache variables. Unlike normal variables which have a lifetime limited to the processing of the CMakeLists.txt file, cache variables are stored in the special file called CMakeCache.txt in the build directory and they persist between CMake runs. Once set, cache variables remain set until something explicitly removes them from the cache. The value of a cache variable is retrieved in exactly the same way as a normal variable (i.e. with the ${myVar} form), but the set() command is different when used to set a cache variable:
set(varName value... CACHE type "docstring" [FORCE])
24


When the CACHE keyword is present, the set() command will apply to a cache variable named varName instead of a normal variable. Cache variables have more information attached to them than a normal variable, including a nominal type and a documentation string. Both must be provided when setting a cache variable, although the docstring can be empty. The documentation string does not affect how CMake treats the variable, it is used only by GUI tools to provide things like help details, tooltips, etc.
CMake will always treat the variable as a string during processing. The type is used mostly to improve the user experience in GUI tools, with some important exceptions discussed in Section 5.5, “Potentially Surprising Behavior Of Variables”. The type must be one of the following:
BOOL
The cache variable is a boolean on/off value. GUI tools use a checkbox or similar to represent the variable. The underlying string value held by the variable will conform to one of the ways CMake represents booleans as strings (ON/OFF, TRUE/FALSE, 1/0, etc. - see Section 6.1.1, “Basic Expressions” for full details).
FILEPATH
The cache variable represents a path to a file on disk. GUI tools present a file dialog to the user for modifying the variable’s value.
PATH
Like FILEPATH, but GUI tools present a dialog that selects a directory rather than a file.
STRING
The variable is treated as an arbitrary string. By default, GUI tools use a single-line text edit widget for manipulating the value of the variable. Projects may use cache variable properties to provide a pre-defined set of values for GUI tools to present as a combobox or similar instead (see Section 9.6, “Cache Variable Properties”).
INTERNAL
The variable is not intended to be made available to the user. Internal cache variables are sometimes used to persistently record internal information by the project, such as caching the result of an intensive query or computation. GUI tools do not show INTERNAL variables. INTERNAL also implies FORCE (see further below).
GUI tools typically use the docstring as a tooltip for the cache variable or as a short one line description when the variable is selected. The docstring should be short and consist of plain text (i.e. no HTML markup, etc.).
Setting a boolean cache variable is such a common need that CMake provides a separate command for it. Rather than the somewhat verbose set() command, developers can use option() instead:
option(optVar helpString [initialValue])
If initialValue is omitted, the default value OFF will be used. If provided, the initialValue must conform to one of the boolean values accepted by the set() command. For reference, the above can be thought of as more or less equivalent to:
25


set(optVar initialValue CACHE BOOL helpString)
Compared to set(), the option() command more clearly expresses the behavior for boolean cache variables, so it would generally be the preferred command to use. Be aware, however, that the effect of the two commands can be different in certain situations (see Section 5.5, “Potentially Surprising Behavior Of Variables”).
An important difference between normal and cache variables is that the set() command will only overwrite a cache variable if the FORCE keyword is present, unlike normal variables where the set() command will always overwrite a pre-existing value. The set() command acts more like set-if-notset when used to define cache variables, as does the option() command (which has no FORCE capability). The main reason for this is that cache variables are primarily intended as a customization point for developers. Rather than hard-coding the value in the CMakeLists.txt file as a normal variable, a cache variable can be used so that the developer can override the value without having to edit the CMakeLists.txt file. The variable can be modified by interactive GUI tools or by scripts without having to change anything in the project itself.
5.4. Scope Blocks
As mentioned in Section 5.1, “Variable Basics”, a variable has a scope. Cache variables have global scope, so they are always accessible. In the material presented so far, a non-cache variable’s scope is the CMakeLists.txt file in which the variable is defined. This is often called the directory scope. Subdirectories and functions inherit variables from their parent scope (covered in Section 7.1.2, “Scope” and Section 8.4, “Returning Values” respectively).
With CMake 3.25 or later, the block() and endblock() commands can be used to define a local variable scope. Upon entering the block, it receives a copy of all the variables defined in the surrounding scope at that point in time. Any changes to variables in the block are performed on the block’s copies, leaving the surrounding scope’s variables unchanged. Upon leaving the block, all variables that were copied into the block or that were created in the block are discarded. This can be a useful way of isolating a particular set of commands from the main logic.
set(x 1)
block() set(x 2) # Shadows outer "x" set(y 3) # Local, not visible outside the block endblock()
# Here, x still equals 1, y is not defined
A block may not always want to be completely isolated from its caller. It may want to selectively modify some variables in the surrounding scope. The PARENT_SCOPE of the set() and unset() commands can be used to modify a variable in the enclosing scope instead of the current scope:
26


set(x 1) set(y 3) block() set(x 2 PARENT_SCOPE) unset(y PARENT_SCOPE) # x still has the value 1 here # y still exists and has the value 3 endblock() # x has the value 2 here and y is no longer defined
When PARENT_SCOPE is used, the variable being set or unset is the one in the parent scope, not the one in the current scope. Importantly, it does not mean to set or unset the variable in both the parent and the current scope. This can make PARENT_SCOPE awkward to use, since it often means repeating the same command for the two different scopes when a change needs to affect both. The block() command supports a PROPAGATE keyword which can be used to provide that behavior in a more robust and concise way. When control flow leaves the block, the value of every variable listed after the PROPAGATE keyword is propagated from the block to its surrounding scope. If a propagated variable is unset inside the block, it is unset in the surrounding scope upon leaving the block.
set(x 1) set(z 5) block(PROPAGATE x z) set(x 2) # Gets propagated back out to the outer "x" set(y 3) # Local, not visible outside the block unset(z) # Unsets the outer "z" too endblock() # Here, x equals 2, y and z are undefined
The block() command can be used to control more than just variable scopes. The command’s full signature is specified as:
block([SCOPE_FOR [VARIABLES] [POLICIES]] [PROPAGATE var...])
The SCOPE_FOR keyword can be used to specify what kind of scope(s) the block should create. When SCOPE_FOR is omitted, block() creates a new local scope for both variables and policies (see Section 12.2, “Policy Scope” for discussion of the latter). The following has the same effect as the previous example, but it only creates a variable scope, leaving the policy scope unchanged:
set(x 1) set(z 5) block(SCOPE_FOR VARIABLES PROPAGATE x z) set(x 2) # Gets propagated back out to the outer "x" set(y 3) # Local variable, not visible outside the block unset(z) # Unsets the outer "z" too endblock() # Here, x equals 2, y and z are undefined
27


While SCOPE_FOR VARIABLES is likely to be what the project needs most of the time, it will often be harmless to allow a new policy scope to be created as well. Using block() rather than block(SCOPE_FOR VARIABLES) may be slightly less efficient, but may still be preferred for its simplicity.
See Section 6.2.3, “Interrupting Loops”, Section 7.4, “Ending Processing Early” and Section 8.4, “Returning Values” for how the block() command interacts with other control flow structures.
5.5. Potentially Surprising Behavior Of Variables
A point that is often not well understood is that normal and cache variables are two separate things. It is possible to have a normal variable and a cache variable with the same name, but holding different values. In such cases, CMake will retrieve the normal variable’s value rather than the cache variable when using ${myVar}. Put another way, normal variables take precedence over cache variables. The exception to this is that when setting a cache variable’s value, any normal variable of the same name is removed from the current scope in the following situations (subject to policy settings discussed further below):
• The cache variable did not exist before the call to set() or option().
• The cache variable existed before the call to set() or option(), but it did not have a defined type (see Section 5.6.1, “Setting Cache Values On The Command Line” for how this can occur).
• The FORCE or INTERNAL option was used in the call to set().
In the first two cases above, this means it is possible to get different behavior between the first and subsequent CMake runs. In the first run, the cache variable won’t exist or won’t have a defined type, but in subsequent runs it will. Therefore, in the first run, a normal variable would be hidden, but in subsequent runs, it would not. An example should help illustrate the problem:
set(myVar foo) # Local myVar set(result ${myVar}) # result = foo set(myVar bar CACHE STRING "") # Cache myVar
set(result ${myVar}) # First run: result = bar # Subsequent runs: result = foo
set(myVar fred) set(result ${myVar}) # result = fred
Chapter 7, Using Subdirectories and Chapter 8, Functions And Macros contain further discussions of how a variable’s scope can influence the value that ${myVar} would return.
In CMake 3.13, the behavior of option() was changed such that if a normal variable already exists with the same name, the command does nothing. This newer behavior is typically what developers intuitively expect. A similar change was made for the set() command in CMake 3.21, but note the following differences in the new behavior for both commands:
• For set(), the cache variable is still set if it didn’t exist previously, but for option() it is not.
• If INTERNAL or FORCE is used with set(), the cache variable will always be set or updated.
28


Developers should be mindful of these inconsistencies and the different CMake versions that provide the new behaviors. Policies CMP0077 and CMP0126 control the actual behavior (see Chapter 12, Policies for an understanding of how these can be manipulated).
The interaction between cache and non-cache variables can also lead to other potentially unexpected behavior. Consider the following three commands:
unset(foo) set(foo) set(foo "")
One might be tempted to think that the evaluation of ${foo} would always give an empty string after any of these three cases, but only the last is guaranteed to do so. Both unset(foo) and set(foo) remove a non-cache variable from the current scope. If there is also a cache variable called foo, that cache variable is left alone and ${foo} would provide the value of that cache variable. In this sense, unset(foo) and set(foo) both effectively unmask the foo cache variable, if one exists. On the other hand, set(foo "") doesn’t remove a non-cache variable, it explicitly sets it to an empty value, so ${foo} will always then evaluate to an empty string regardless of whether there is also a cache variable called foo. Therefore, setting a variable to an empty string rather than removing it is likely to be the more robust way of achieving the developer’s intention.
For those rare situations where a project may need to get the value of a cache variable and ignore any non-cache variable of the same name, CMake 3.13 added documentation for the $CACHE{someVar} form. Projects should not generally make use of this other than for temporary debugging, since it breaks the long-established expectation that normal variables will override values set in the cache.
5.6. Manipulating Cache Variables
Using set() and option(), a project can build up a useful set of customization points for its developers. Different parts of the build can be turned on or off, paths to external packages can be set, flags for compilers and linkers can be modified and so on. Later chapters cover these and other uses of cache variables, but first, the ways to manipulate such variables need to be understood. There are two primary ways developers can do this, either from the cmake command line or using a GUI tool.
5.6.1. Setting Cache Values On The Command Line
CMake allows cache variables to be manipulated directly via command line options passed to cmake. The primary workhorse is the -D option, which is used to define the value of a cache variable.
cmake -D myVar:type=someValue ...
someValue will replace any previous value of the myVar cache variable. The behavior is essentially as though the variable was being assigned using the set() command with the CACHE and FORCE options. The command line option only needs to be given once, since it is stored in the cache for subsequent runs and therefore does not need to be provided every time cmake is run. Multiple -D options can be provided to set more than one variable at a time on the cmake command line.
29


When defining cache variables this way, they do not have to be set within the CMakeLists.txt file (i.e. no corresponding set() command is required). Cache variables defined on the command line have an empty docstring. The type can also be omitted, in which case the variable will have an undefined type, or more accurately, it is given a special type that is similar to INTERNAL but which CMake interprets to mean undefined. The following shows various examples of setting cache variables via the command line.
cmake -D foo:BOOL=ON ... cmake -D "bar:STRING=This contains spaces" ... cmake -D hideMe=mysteryValue ... cmake -D helpers:FILEPATH=subdir/helpers.txt ... cmake -D helpDir:PATH=/opt/helpThings ...
Note how the entire value given with the -D option should be quoted if setting a cache variable with a value containing spaces.
There is a special case for handling values initially declared without a type on the cmake command line. If the project’s CMakeLists.txt file then tries to set the same cache variable and specifies a type of FILEPATH or PATH, then if the value of that cache variable is a relative path, CMake will treat it as being relative to the directory from which cmake was invoked and automatically convert it to an absolute path. This is not particularly robust, since cmake could be invoked from any directory, not just the build directory. Therefore, developers are advised to always include a type if specifying a variable on the cmake command line for a variable that represents some kind of path. It is a good habit to always specify the type of the variable on the command line in general anyway so that it is likely to be shown in GUI applications in the most appropriate form. It will also prevent one of the scenarios mentioned earlier in Section 5.5, “Potentially Surprising Behavior Of Variables”.
It is also possible to remove variables from the cache with the -U option, which can be repeated as necessary to remove more than one variable. Note that the -U option supports * and ? wildcards, but care needs to be taken to avoid deleting more than was intended and leaving the cache in an unbuildable state. In general, it is recommended to only remove specific entries without wildcards unless it is absolutely certain the wildcards used are safe.
cmake -U 'help*' -U foo ...
5.6.2. CMake GUI Tools
Setting cache variables via the command line is an essential part of automated build scripts and anything else driving CMake via the cmake command. For everyday development, however, the GUI tools provided by CMake often present a better user experience. CMake provides two equivalent GUI tools, cmake-gui and ccmake, which allow developers to manipulate cache variables interactively. cmake-gui is a fully functional GUI application supported on all major desktop platforms, whereas ccmake uses a curses-based interface which can be used in text-only environments such as over a ssh connection. cmake-gui is included in the official CMake release packages for all platforms, ccmake is included for all platforms except Windows. If using system-provided packages on Linux rather than the official releases, note that many distributions split cmake-gui out into its own package.
30


The cmake-gui user interface is shown in the figure below. The top section allows the project’s source and build directories to be defined. The middle section is where the cache variables can be viewed and edited. At the bottom are the Configure and Generate buttons, followed by a log area that shows the output from those operations.
The source directory must be set to the directory containing the CMakeLists.txt file at the top of the project’s source tree. The build directory is where CMake will generate all build output (recommended directory layouts were discussed in Chapter 2, Setting Up A Project). For new projects, both must be set, but for existing projects, setting the build directory will also update the source directory, since the source location is stored in the build directory’s cache.
CMake’s two-stage setup process was introduced in Section 2.3, “Generating Project Files”. In the first stage, the CMakeLists.txt file is read and a representation of the project is built up in memory. This is called the configure stage. If the configure stage is successful, the generate stage can then be executed to create the build tool’s project files in the build directory. When running cmake from the command line, both stages are executed automatically, but in the GUI application, they are triggered separately with the Configure and Generate buttons.
Each time the configure step is initiated, the cache variables shown in the middle of the UI are updated. Any variables which were newly added or which changed value from the previous run will be highlighted in red (when a project is first loaded, all variables are shown highlighted). Good practice is to re-run the configure stage until there are no changes. This ensures robust behavior for more complex projects where enabling some options may add further options which could require another configure pass.
31


Once all cache variables are shown without red highlighting, the generate stage can be run. The example in the previous screenshot shows typical log output after the configure stage has been run and no changes were made to any of the cache variables.
Hovering the mouse over any cache variable will show a tooltip containing the docstring for that variable. New cache variables can also be added with the Add Entry button, which is equivalent to issuing a set() command with an empty docstring. Cache variables can be removed with the Remove Entry button, although CMake will most likely recreate that variable on the next run.
Clicking on a variable allows its value to be edited in a widget tailored to the variable type. Booleans are shown as a checkbox, files and paths have a browse filesystem button and strings are usually presented as a text line edit. As a special case, cache variables of type STRING can be given a set of values to show in a combobox in CMake GUI instead of showing a simple text entry widget. This is achieved by setting a cache variable’s STRINGS property (covered in detail in Section 9.6, “Cache Variable Properties”, but shown here for convenience):
set(TRAFFIC_LIGHT Green CACHE STRING "Status of something") set_property(CACHE TRAFFIC_LIGHT PROPERTY STRINGS Red Orange Green)
In the above, the TRAFFIC_LIGHT cache variable will initially have the value Green. When the user attempts to modify TRAFFIC_LIGHT in cmake-gui, they will be given a combobox containing the three values Red, Orange and Green instead of a simple line edit widget which would otherwise have allowed them to enter any arbitrary text. Note that setting the STRINGS property on the variable doesn’t prevent that variable from having other values assigned to it, it only affects the widget used by cmake-gui when editing it. The variable can still be given other values via set() commands in the CMakeLists.txt file or by other means such as manually editing the CMakeCache.txt file.
Cache variables can also have a property marking them as advanced or not. This too only affects the way the variable is displayed in cmake-gui, it does not in any way affect how CMake uses the variable during processing. By default, cmake-gui only shows non-advanced variables, which typically presents just the main variables a developer would be interested in viewing or modifying. Enabling the Advanced option shows all cache variables except those marked INTERNAL (the only way to see INTERNAL variables is to edit the CMakeCache.txt file with a text editor, since they are not intended to be manipulated directly by developers). Variables can be marked as advanced with the
mark_as_advanced() command within the CMakeLists.txt file:
mark_as_advanced([CLEAR|FORCE] var1 [var2...])
The CLEAR keyword ensures the variables are not marked as advanced, while the FORCE keyword ensures the variables are marked advanced. Without either keyword, the variables will only be marked as advanced if they don’t already have an advanced/non-advanced state set.
Selecting the Grouped option can make viewing advanced variables easier by grouping variables together based on the start of the variable name up to the first underscore. Another way to filter the list of variables shown is to enter text in the Search area, which results in only showing variables with the specified text in their name or value.
32


When the configure stage is run for the first time on a new project, the developer is presented with a dialog similar to that shown in the next screenshot:
This dialog is where the CMake generator and toolchain are specified. The choice of generator is usually up to the developer’s personal preference, with available options provided in the combobox. Depending on the project, the choice of generator may be more restricted than what the combobox options allow, such as if the project relies on generator-specific functionality. A common example of this is a project that requires the Xcode generator due to the Apple platform’s unique features, such as code signing and iOS/tvOS/watchOS support. Once a generator has been selected for a project, it cannot be changed without deleting the cache and starting again, which can be done from the File menu if required.
For the toolchain options presented, each one requires progressively more information from the developer. Using the default native compilers is the usual choice for ordinary desktop development and selecting that option requires no further details. If more control is required, developers can instead override the native compilers, with the paths to the compilers being given in a follow-up dialog. If a separate toolchain file is available, that can be used to customize not just the compilers but also the target environment, compiler flags and various other things. Using a toolchain file is typical when cross-compiling, which is covered in detail in Chapter 23, Toolchains And Cross Compiling. Lastly, for ultimate control, developers can specify the full set of options for crosscompiling, but this is not recommended for normal use. A toolchain file can provide the same information but has the advantage that it can be re-used as needed.
The ccmake tool offers most of the same functionality as the cmake-gui application, but it does so through a text-based interface:
33


Rather than selecting the source and build directories like with cmake-gui, the source or build directory has to be specified on the ccmake command line, just like for the cmake command.
A minor drawback of the ccmake interface is that there is no ability to filter the variables shown. The methods for editing a variable are also not as rich as with cmake-gui. Nevertheless, the ccmake tool is a useful alternative when the full cmake-gui application is not practical or not available, such as over a terminal connection that cannot support UI forwarding.
5.7. Printing Variable Values
As projects get more complicated or when investigating unexpected behavior, it can be useful to print out diagnostic messages and variable values during a CMake run. This is generally achieved using the message() command, which is covered in detail in Chapter 13, Debugging And Diagnostics. For now, it is enough to know that in its simplest form, all the message() command does is print its arguments to CMake’s output. It adds no separator between arguments if more than one argument is given and a newline is automatically appended to the end of the message. Newlines can also be explicitly included using the common \n notation. A variable’s value can be included in the message by using the usual ${myVar} notation.
set(myVar HiThere) message("The value of myVar = ${myVar}\nAnd this " "appears on the next line")
This will give the following output:
The value of myVar = HiThere And this appears on the next line
5.8. String Handling
As project complexity grows, in many cases so too does the need to implement more involved logic for how variables are managed. A core tool CMake provides for this is the string() command, which
34


provides a wide range of useful string handling functionality. This command enables projects to perform find and replace operations, regular expression matching, upper/lower case transformations, strip whitespace and other common tasks. Some of the more frequently used functionality is presented below, but the CMake reference documentation should be considered the canonical source of all available operations and their behavior.
The first argument to string() defines the operation to be performed and subsequent arguments depend on the operation being requested. These arguments will generally require at least one input string and since CMake commands cannot return a value, an output variable for the result of the operation. In the material below, this output variable will generally be named outVar.
string(FIND inputString subString outVar [REVERSE])
FIND searches for subString in inputString and stores the index of the found subString in outVar (the first character is index 0). The first occurrence is found unless REVERSE is specified, in which case the last occurrence will be found instead. If subString does not appear in inputString, then outVar will be given the value -1.
string(FIND abcdefabcdef def fwdIndex) string(FIND abcdefabcdef def revIndex REVERSE)
message("fwdIndex = ${fwdIndex}\n" "revIndex = ${revIndex}")
This results in the following output:
fwdIndex = 3 revIndex = 9
Replacing a simple substring follows a similar pattern:
string(REPLACE matchString replaceWith outVar input...)
The REPLACE operation will replace every occurrence of matchString in the input strings with replaceWith and store the result in outVar. When multiple input strings are given, they are joined together without any separator between each string before searching for substitutions. This can sometimes lead to unexpected matches and typically developers would provide just the one input string in most situations.
Regular expressions are also well supported by the REGEX operation, with a few different variants available as determined by the second argument:
string(REGEX MATCH regex outVar input...) string(REGEX MATCHALL regex outVar input...) string(REGEX REPLACE regex replaceWith outVar input...)
35


The regular expression to match, regex, can make use of typical basic regular expression syntax (see the CMake reference documentation for the full specification), although some common features such as negation are not supported. The input strings are concatenated before substitution. The MATCH operation finds just the first match and stores it in outVar. MATCHALL finds all matches and stores them in outVar as a list. REPLACE will return the entire input string with each match replaced by replaceWith. Matches can be referred to in replaceWith using the usual notation \1, \2, etc., but note that the backslashes themselves must be escaped unless bracket notation is used. The following example and its output demonstrate the above points:
string(REGEX MATCH "[ace]" matchOne abcdefabcdef) string(REGEX MATCHALL "[ace]" matchAll abcdefabcdef) string(REGEX REPLACE "([de])" "X\\1Y" replVar1 abc def abcdef) string(REGEX REPLACE "([de])" [[X\1Y]] replVar2 abcdefabcdef)
message("matchOne = ${matchOne}\n" "matchAll = ${matchAll}\n" "replVar1 = ${replVar1}\n" "replVar2 = ${replVar2}")
matchOne = a matchAll = a;c;e;a;c;e replVar1 = abcXdYXeYfabcXdYXeYf replVar2 = abcXdYXeYfabcXdYXeYf
Extracting a substring is also possible:
string(SUBSTRING input index length outVar)
The index is an integer defining the start of the substring to extract from input. Up to length characters will be extracted, or if length is -1, the returned substring will contain all characters up to the end of the input string. Note that in CMake 3.1 and earlier, an error was reported if length pointed past the end of the string.
String length can be trivially obtained and strings can easily be converted to upper or lower case. It is also straightforward to strip whitespace from the start and end of a string. The syntax for these operations all share the same form:
string(LENGTH input outVar) string(TOLOWER input outVar) string(TOUPPER input outVar) string(STRIP input outVar)
In the case of LENGTH, for historical reasons the command counts bytes rather than characters. For strings containing multi-byte characters, this means the reported length will be different to the number of characters.
36


CMake provides other operations, such as string comparison, hashing, timestamps, JSON handling and more, but their use is less common in everyday CMake projects. The interested reader should consult the CMake reference documentation for the string() command for full details.
5.9. Lists
Lists are used heavily in CMake. Ultimately, lists are just a single string with list items separated by semicolons (with one exception, which is covered in Section 5.9.1, “Problems With Unbalanced Square Brackets” further below). This can make it less convenient to manipulate individual list items. CMake provides the list() command to facilitate such tasks. Like for the string() command, list() expects the operation to perform as its first argument. The second argument is always the list to operate on and it must be a variable (i.e. passing a raw list like a;b;c is not permitted).
The most basic list operations are counting the number of items and retrieving one or more items from the list:
list(LENGTH listVar outVar) list(GET listVar index [index...] outVar)
Example usage:
set(myList a b c) # Creates the list "a;b;c"
list(LENGTH myList len) message("length = ${len}")
list(GET myList 2 1 letters) message("letters = ${letters}")
The output of the above example would be:
length = 3 letters = c;b
Inserting, appending and prepending items is also a common task:
list(INSERT listVar index item [item...]) list(APPEND listVar item [item...]) list(PREPEND listVar item [item...]) # Requires CMake 3.15 or later
Unlike the LENGTH and GET cases, INSERT, APPEND and PREPEND act directly on the listVar and modify it in-place, as demonstrated by the following example:
set(myList a b c)
list(INSERT myList 2 X Y Z) message("myList (first) = ${myList}")
37


list(APPEND myList d e f) message("myList (second) = ${myList}")
list(PREPEND myList P Q R) message("myList (third) = ${myList}")
Which gives the following output:
myList (first) = a;b;X;Y;Z;c myList (second) = a;b;X;Y;Z;c;d;e;f myList (third) = P;Q;R;a;b;X;Y;Z;c;d;e;f
Finding a particular item in the list follows the expected pattern:
list(FIND myList value outVar)
Example usage:
set(myList a b c d e) list(FIND myList d index) message("index = ${index}")
Resultant output:
index = 3
Three operations are provided for removing items, all of which modify the list directly:
list(REMOVE_ITEM myList value [value...]) list(REMOVE_AT myList index [index...]) list(REMOVE_DUPLICATES myList)
The REMOVE_ITEM operation can be used to remove all instances of one or more items from a list. If the item is not in the list, it is not an error. REMOVE_AT on the other hand, specifies one or more indices to remove and CMake will halt with an error if any of the specified indices are past the end of the list. REMOVE_DUPLICATES will ensure the list contains only unique items.
CMake 3.15 added support for popping items from the front or back of a list and optionally storing the popped items:
# Requires CMake 3.15 or later list(POP_FRONT myList [outVar1 [outVar2...]]) list(POP_BACK myList [outVar1 [outVar2...]])
38


When no outVar is given, a single item is popped from the front or back and discarded. If one or more outVar names are given, popped items will be stored in those variables, with the number of items popped equal to the number of variable names provided.
List items can also be reordered with REVERSE or SORT operations:
list(REVERSE myList) list(SORT myList [COMPARE method] [CASE case] [ORDER order])
All of the optional keywords for list(SORT) are only available with CMake 3.13 or later. If the COMPARE option is present, the method must be one of the following:
STRING
Sort alphabetically. This is the default behavior when the COMPARE option is not given.
FILE_BASENAME
Sort by assuming that each item is a path and that items should be ordered according to the basename part of the path only.
NATURAL
Similar to STRING, except contiguous digits within an item are sorted numerically. This is most useful for sorting strings that contain embedded version numbers. The sorting rules are the same as for the strverscmp() C function (a GNU extension). This sorting method is only available with CMake 3.18 or later.
The CASE keyword requires SENSITIVE or INSENSITIVE for the case, while the ORDER keyword requires
either ASCENDING or DESCENDING for the order.
For all list operations taking an index, a negative index indicates that counting starts from the end of the list. When used this way, the last item in the list has index -1, the second last -2, and so on.
The above describes most of the available list() sub-commands. Those mentioned are all supported since at least CMake 3.0 unless otherwise noted, so projects should generally be able to expect them to be available. For the full list of supported sub-commands, the reader should consult the CMake documentation.
5.9.1. Problems With Unbalanced Square Brackets
There is one exception to the way CMake usually treats semicolons as list separators. For historical reasons, if a list item contains an opening square bracket [, it must also have a matching closing square bracket ]. CMake will consider any semicolon between these square brackets to be part of the list item instead of as a list separator. If one tries to construct a list with unbalanced square brackets, the list won’t be interpreted as expected. The following demonstrates the behavior:
set(noBrackets "a_a" "b_b") set(withBrackets "a[a" "b]b")
list(LENGTH noBrackets lenNo) list(LENGTH withBrackets lenWith)
39


list(GET noBrackets 0 firstNo) list(GET withBrackets 0 firstWith)
message("No brackets: Length=${lenNo} --> First_element=${firstNo}") message("With brackets: Length=${lenWith} --> First_element=${firstWith}")
The output from the above would be:
No brackets: Length=2 --> First_element=a_a With brackets: Length=1 --> First_element=a[a;b]b
Discussion in Section 8.8.3, “Special Cases For Argument Expansion” covers further aspects of this peculiarity.
5.10. Math
One other common form of variable manipulation is math computation. CMake provides the math() command for performing basic mathematical evaluation:
math(EXPR outVar mathExpr [OUTPUT_FORMAT format])
The first argument must be the keyword EXPR, while mathExpr defines the expression to be evaluated and the result will be stored in outVar. The expression may use any of the following operators which all have the same meaning as they would in C code: + - * / % | & ^ ~ << >>. Parentheses are also supported and have their usual mathematical meaning. Variables can be referenced in the mathExpr with the usual ${myVar} notation.
If using CMake 3.13 or later, the OUTPUT_FORMAT keyword can be given to control how the result is stored in outVar. The format should be either DECIMAL, which is the default behavior, or HEXADECIMAL.
set(x 3) set(y 7) math(EXPR zDec "(${x}+${y}) * 2") message("decimal = ${zDec}")
# Requires CMake 3.13 or later for HEXADECIMAL math(EXPR zHex "(${x}+${y}) * 2" OUTPUT_FORMAT HEXADECIMAL) message("hexadecimal = ${zHex}")
The above produces the following output:
decimal = 20 hexadecimal = 0x14
40


5.11. Recommended Practices
Where the development environment allows it, the CMake GUI tool is a useful way to quickly and easily understand the build options for a project and to modify them as needed during development. A little bit of time spent getting familiar with it will simplify working with more complex projects later. It also gives developers a good base to work from should they need to experiment with things like compiler settings, since these are easily found and modified within the GUI environment.
Prefer to provide cache variables for controlling whether to enable optional parts of the build instead of encoding the logic in build scripts outside of CMake. This makes it trivial to turn them on and off in the CMake GUI and other tools which understand how to work with the CMake cache (a growing number of IDE environments are acquiring this capability).
Try to avoid relying on environment variables being defined, apart from perhaps the ubiquitous PATH or similar operating system level variables. The build should be predictable, reliable and easy to set up, but if it relies on environment variables being set for things to work correctly, this can be a point of frustration for new developers as they wrestle to get their build environment set up. Furthermore, the environment at the time CMake is run can change compared to when the build itself is invoked. Therefore, prefer to pass information directly to CMake through cache variables instead wherever possible.
Try to establish a variable naming convention early. For cache variables, consider grouping related variables under a common prefix followed by an underscore to take advantage of how CMake GUI groups variables based on the same prefix automatically. Also consider that the project may one day become a sub-part of some larger project, so a name beginning with the project name or something closely associated with the project may be desirable.
Try to avoid defining non-cache variables in the project which have the same name as cache variables. The interaction between the two types of variables can be unexpected for developers new to CMake. Later chapters also highlight other common errors and misuses of regular variables that share the same name as cache variables.
CMake provides a large number of pre-defined variables that provide details about the system or influence certain aspects of CMake’s behavior. Some of these variables are heavily used by projects, such as those that are only defined when building for a particular platform (WIN32, APPLE, UNIX, etc.). It is therefore recommended for developers to occasionally make a quick scan through the CMake documentation page listing the pre-defined variables to help become familiar with what is available.
41


Chapter 6. Flow Control
A common need for most CMake projects is to apply some steps only in certain circumstances. Projects may want to use certain compiler flags only with a particular compiler or when building for a particular platform, for example. In other cases, the project may need to iterate over a set of values or to keep repeating some set of steps until a certain condition is met. These examples of flow control are well-supported by CMake in ways which should be familiar to most software developers. The ubiquitous if() command provides the expected if-then-else behavior and looping is provided through the foreach() and while() commands. All three commands provide the traditional behavior as implemented by most programming languages, but they also have added features specific to CMake.
6.1. The if() Command
The modern form of the if() command is as follows (multiple elseif() clauses can be provided):
if(expression1) # commands ... elseif(expression2) # commands ... else() # commands ... endif()
Very early versions of CMake required expression1 to be repeated as an argument to the else() and endif() clauses, but this has not been required since CMake 2.8.0. While it is still not unusual to encounter projects and example code using that older form, it is discouraged for new projects since it can be somewhat confusing to read. New projects should leave the else() and endif() arguments empty, as shown above.
The expressions in if() and elseif() commands can take a variety of different forms. CMake offers the traditional boolean logic as well as various other conditions such as file system tests, version comparison and testing for the existence of things.
6.1.1. Basic Expressions
The most basic of all expressions is a single constant value:
if(value)
CMake’s logic for what it considers true and false is a little more involved than most programming languages. For a single unquoted value, the rules are as follows:
• If value is a quoted or unquoted constant with value ON, YES, TRUE or Y, it is treated as true. The test is case-insensitive.
• If value is a quoted or unquoted constant with value OFF, NO, FALSE, N, IGNORE, NOTFOUND, an empty string or a string that ends in -NOTFOUND, it is treated as false. Again, the test is case-insensitive.
42


• If value is a (possibly floating-point) number, it will be converted to a bool following usual C rules, although values other than 0 or 1 are not often used in this context.
• If none of the above cases apply, it will be treated as a variable name (or possibly as a string) and evaluated further as described below.
In the following examples, only the if(...) part of the command is shown for illustration purposes, the corresponding body and endif() is omitted:
# Examples of quoted and unquoted constants if(YES) if("True") if(0) if(TRUE)
# These are also treated as unquoted constants because the # variable evaluation occurs before if() sees the values set(A YES) set(B 0) if(${A}) # Evaluates to true if(${B}) # Evaluates to false
# Does not match any of the true or false constants, so proceed # to testing as a variable name in the fall-through case below if(someLetters)
# Quoted value that doesn't match any of the true or false constants, # so again fall through to testing as a variable name or string if("someLetters")
The CMake documentation refers to the fall through case as the following form:
if(<variable|string>)
What this means in practice is the if-expression is either:
• An unquoted name of a (possibly undefined) variable.
• A quoted string.
When an unquoted variable name is used, the variable’s value is compared against the false constants. If none of those match the value, the result of the expression is true. An undefined variable will evaluate to an empty string, which matches one of the false constants and will therefore yield a result of false.
# Common pattern, often used with variables defined # by commands such as option(enableSomething "...") if(enableSomething) # ... endif()
43


Note that environment variables do not count as variables in this discussion. A statement like if(ENV{some_var}) will always evaluate to false, regardless of whether an environment variable called some_var exists or not.
When the if-expression is a quoted string, the behavior is more involved:
• A quoted string that doesn’t match any of the defined true constants always evaluates to false in CMake 3.1 or later, regardless of the string’s value (but this can be overridden with policy setting CMP0054, see Chapter 12, Policies).
• Before CMake 3.1, if the value of the string matched the name of an existing variable, then the quoted string is effectively replaced by that variable name (unquoted) and the test is then repeated.
Both of the above can be a surprise to developers, but at least the CMake 3.1 behavior is always predictable. The pre-3.1 behavior would occasionally lead to unexpected string substitutions when the string value happened to match a variable name, possibly one defined somewhere quite far from that part of the project. The potential confusion around quoted values means it is generally advisable to avoid using quoted arguments with the if(something) form. There are usually better comparison expressions that handle strings more robustly, which are covered in Section 6.1.3, “Comparison Tests” further below.
6.1.2. Logic Operators
CMake supports the usual AND, OR and NOT logical operators, as well as parentheses to control order of precedence.
# Logical operators if(NOT expression) if(expression1 AND expression2) if(expression1 OR expression2)
# Example with parentheses if(NOT (expression1 AND (expression2 OR expression3)))
Following usual conventions, expressions inside parentheses are evaluated first, beginning with the innermost parentheses.
6.1.3. Comparison Tests
CMake separates comparison tests into distinct categories: numeric, string, version numbers and path, but the syntax forms all follow the same pattern:
if(value1 OPERATOR value2)
The two operands, value1 and value2, can be either variable names or (possibly quoted) values. If a value is the same as the name of a defined variable, it will be treated as a variable. Otherwise, it is treated as a string or value directly. Once again though, quoted values have ambiguous behavior similar to that in basic unary expressions. Prior to CMake 3.1, a quoted string with a value that
44


matched a variable name would be replaced by that variable’s value. The behavior of CMake 3.1 and later uses the quoted value without substitution, which is what developers intuitively expect.
All of the comparison categories support the same set of operations, but the OPERATOR names are different for each category. The following table summarizes the supported operators:
Numeric String Version numbers Path
LESS STRLESS VERSION_LESS
GREATER STRGREATER VERSION_GREATER
EQUAL STREQUAL VERSION_EQUAL PATH_EQUAL2
LESS_EQUAL1 STRLESS_EQUAL1 VERSION_LESS_EQUAL1
GREATER_EQUAL1 STRGREATER_EQUAL1 VERSION_GREATER_EQUAL1
1 Only available with CMake 3.7 and later. 2 Only available with CMake 3.24 and later.
Numeric comparison works as one would expect, comparing the value of the left against the right. Note, however, that CMake does not typically raise an error if either operand is not a number and its behavior does not fully conform to the official documentation when values contain more than just digits. Depending on the mix of digits and non-digits, the result of the expression may be true or false.
# Valid numeric expressions, all evaluating as true if(2 GREATER 1) if("23" EQUAL 23) set(val 42) if(${val} EQUAL 42) if("${val}" EQUAL 42)
# Invalid expression that evaluates as true with at # least some CMake versions. Do not rely on this behavior. if("23a" EQUAL 23)
Version number comparisons are somewhat like an enhanced form of numerical comparisons. Version numbers are assumed to be in the form major[.minor[.patch[.tweak]]] where each component is expected to be a non-negative integer. When comparing two version numbers, the major part is compared first. Only if the major components are equal will the minor parts be compared (if present) and so on. A missing component is treated as zero. In all of the following examples, the expression evaluates to true:
if(1.2 VERSION_EQUAL 1.2.0) if(1.2 VERSION_LESS 1.2.3) if(1.2.3 VERSION_GREATER 1.2 ) if(2.0.1 VERSION_GREATER 1.9.7) if(1.8.2 VERSION_LESS 2 )
45


The version number comparisons have the same robustness caveats as numeric comparisons. Each version component is expected to be an integer, but the comparison result is essentially undefined if this restriction does not hold.
For strings, values are compared lexicographically. No assumptions are made about the contents of the strings, but be mindful of the potential for the variable/string substitution situation described earlier. String comparisons are one of the most common situations where such unexpected substitutions occur.
The PATH_EQUAL operator is much like a special case of STREQUAL. The operands are assumed to be paths in CMake’s native path form (i.e. forward slashes for directory separators). A key difference for PATH_EQUAL is that it uses a component-wise comparison. Multiple consecutive directory separators are collapsed to a single separator, which is the primary practical difference to STREQUAL. The following example from the official CMake documentation demonstrates the difference:
# comparison is TRUE if ("/a//b/c" PATH_EQUAL "/a/b/c") ... endif()
# comparison is FALSE if ("/a//b/c" STREQUAL "/a/b/c") ... endif()
In addition to the operator forms above, a string can also be tested against a regular expression:
if(value MATCHES regex)
The value again follows the variable-or-string rules defined above and is compared against the regex regular expression. If the value matches, the expression evaluates to true. While the CMake documentation doesn’t define the supported regular expression syntax for if() commands, it does define it elsewhere for other commands (e.g. see the string() command documentation). Essentially, CMake supports basic regular expression syntax only.
Parentheses can be used to capture parts of the matched value. The command will set variables with names of the form CMAKE_MATCH_<n> where <n> is the group to match. The entire matched string is stored in group 0.
if("Hi from ${who}" MATCHES "Hi from (Fred|Barney).*") message("${CMAKE_MATCH_1} says hello") endif()
6.1.4. File System Tests
CMake also includes a set of tests which can be used to query the file system:
46


if(EXISTS pathToFileOrDir) if(IS_DIRECTORY pathToDir) if(IS_SYMLINK fileName) if(IS_ABSOLUTE path) if(file1 IS_NEWER_THAN file2)
Unlike most other if() expressions, none of the above operators perform any variable/string substitution without ${}, regardless of any quoting.
Each of the above operators should be self-explanatory, except for IS_NEWER_THAN. Unfortunately, IS_NEWER_THAN is an inaccurate name for what that operator does. It also returns true if both files have the same timestamp, not just if the timestamp of file1 is newer than that of file2. This becomes especially important on file systems that only have timestamps with a resolution of one second, such as the HFS+ file system on macOS 10.12 and earlier. On such systems, it is very common to encounter scenarios where files have the same timestamp, even when those files are created by separate commands. Another less intuitive behavior is that it also returns true if either file is missing. Furthermore, if either file is not specified as an absolute path, the behavior is undefined. It will often therefore be necessary to use IS_NEWER_THAN in a negated way to obtain the desired condition.
Consider a scenario where secondFile is generated from firstFile. If firstFile is updated or secondFile is missing, then secondFile needs to be recreated. If firstFile does not exist, it should be a fatal error. Such logic would need to be expressed like so:
set(firstFile "/full/path/to/somewhere") set(secondFile "/full/path/to/another/file")
if(NOT EXISTS ${firstFile}) message(FATAL_ERROR "${firstFile} is missing") elseif(NOT EXISTS ${secondFile} OR NOT ${secondFile} IS_NEWER_THAN ${firstFile}) # ... commands to recreate secondFile endif()
One might naively think that the condition could be expressed like this instead:
# WARNING: Very likely to be wrong if(${firstFile} IS_NEWER_THAN ${secondFile}) # ... commands to recreate secondFile endif()
Although the words might express the desired condition, it doesn’t do what it appears to because it also returns true if the two files have the same timestamp. If the operation to recreate secondFile is fast and the file system only has second timestamp resolution, it is very likely that secondFile would be recreated every time CMake is run. If build steps depend on secondFile, the build would also end up rebuilding those things after every CMake run.
47


6.1.5. Existence Tests
The last category of if() expressions support testing whether various CMake entities exist. They can be particularly useful in larger, more complex projects where some parts might or might not be present or be enabled.
if(DEFINED name) if(COMMAND name) if(POLICY name) if(TARGET name) if(TEST name) # Available since CMake 3.4 if(value IN_LIST listVar) # Available since CMake 3.3
All but the last of the above will return true if an entity of the specified name exists at the point where the if() command is issued.
DEFINED
Returns true if a variable of the specified name exists. The value of the variable is irrelevant, only its existence is tested. The variable can be a regular CMake variable or it can be a cache variable. From CMake 3.14, it is possible to check for a cache variable only using the CACHE{name} form. All CMake versions also support testing for the existence of an environment variable using the ENV{name} form, even though this was only officially documented as supported from CMake 3.13.
if(DEFINED SOMEVAR) # Checks for a CMake variable (regular or cache) if(DEFINED CACHE{SOMEVAR}) # Checks for a CMake cache variable if(DEFINED ENV{SOMEVAR}) # Checks for an environment variable
COMMAND
Tests whether a CMake command, function or macro with the specified name exists. This can be useful for checking whether something is defined before trying to use it. For CMake-provided commands, prefer to test the CMake version instead, but for project-supplied functions and macros (see Chapter 8, Functions And Macros), this can be an appropriate check.
POLICY
Tests whether a particular policy is known to CMake. Policy names are usually of the form CMPxxxx, where xxxx is a four-digit number. See Chapter 12, Policies for details on this topic.
TARGET
Returns true if a CMake target of the specified name has been defined by one of the commands
add_executable(), add_library() or add_custom_target(). The target could have been defined in any directory, as long as it is known at the point where the if() test is performed. This test is particularly useful in complex project hierarchies that pull in other external projects and where those projects may share common dependent subprojects (i.e. this sort of if() test can be used to check if a target is already defined before trying to create it).
TEST
Returns true if a CMake test with the specified name has been previously defined by the add_test() command (covered in detail in Chapter 26, Testing).
48


The IN_LIST form returns true if listVar contains the specified value, where value follows the usual variable-or-string rules. listVar must be the name of a list variable, it cannot be a string.
# Correct set(things A B C) if("B" IN_LIST things) ... endif()
# WRONG: Right hand side must be the name of a variable if("B" IN_LIST "A;B;C") ... endif()
Also note that IN_LIST can only be used if policy CMP0057 is NEW (see Chapter 12, Policies).
6.1.6. Common Examples
A few uses of if() are so common, they deserve special mention. Many of these rely on predefined CMake variables for their logic, especially variables relating to the compiler and target platform. Unfortunately, it is common to see such expressions based on the wrong variables. For example, consider a project which has two C++ source files, one for building with Visual Studio compilers or those compatible with them (e.g. Intel) and another for building with all other compilers. Such logic is frequently implemented like so:
if(WIN32) set(platformImpl source_win.cpp) else() set(platformImpl source_generic.cpp) endif()
While this will likely work for the majority of projects, it doesn’t actually express the right constraint. Consider, for example, a project built on Windows but using the MinGW compiler. For such cases, source_generic.cpp may be the more appropriate source file. The above could be more accurately implemented as follows:
if(MSVC) set(platformImpl source_msvc.cpp) else() set(platformImpl source_generic.cpp) endif()
Another example involves conditional behavior based on the CMake generator being used. In particular, CMake offers additional features when building with the Xcode generator which no other generators support. Projects sometimes make the assumption that building for macOS means the Xcode generator will be used, but this doesn’t have to be the case (and often isn’t). The following incorrect logic is sometimes used:
49


if(APPLE) # Some Xcode-specific settings here... else() # Things for other platforms here... endif()
Again, this may seem to do the right thing, but if a developer tries to use a different generator (e.g. Ninja or Unix Makefiles) on macOS, the logic fails. Testing the platform with the expression APPLE doesn’t express the right condition, the CMake generator should be tested instead:
if(CMAKE_GENERATOR STREQUAL "Xcode") # Some Xcode-specific settings here... else() # Things for other CMake generators here... endif()
The above examples are both cases of testing the platform instead of the entity the constraint actually relates to. This is understandable, since the platform is one of the simplest things to understand and test, but using it instead of the more accurate constraint can unnecessarily limit the generator choices available to developers, or it may result in the wrong behavior entirely.
Another common example, this time used appropriately, is the conditional inclusion of a target based on whether or not a particular CMake option has been set.
option(BUILD_MYLIB "Enable building the MyLib target") if(BUILD_MYLIB) add_library(MyLib src1.cpp src2.cpp) endif()
More complex projects often use the above pattern to conditionally include subdirectories or perform a variety of other tasks based on a CMake option or cache variable. Developers can then turn that option on/off or set the variable to non-default values without having to edit the CMakeLists.txt file directly. This is especially useful for scripted builds driven by continuous integration systems, etc. which may want to enable or disable certain parts of the build.
6.2. Looping
Another common need in many CMake projects is to perform some action on a list of items or for a range of values. Alternatively, some action may need to be performed repeatedly until a particular condition is met. These needs are well covered by CMake, offering the traditional behavior with some additions to make working with CMake features a little easier.
6.2.1. foreach()
CMake provides the foreach() command to enable projects to iterate over a set of items or values. There are a few different forms of foreach(), the most basic of which is:
50


foreach(loopVar arg1 arg2 ...) # ... endforeach()
In the above form, for each argN value, loopVar is set to that argument and the loop body is executed. No variable/string test is performed, the arguments are used exactly as the values are specified. Rather than listing out each item explicitly, the arguments can also be specified by one or more list variables using the more general form of the command:
foreach(loopVar IN [LISTS listVar1 ...] [ITEMS item1 ...]) # ... endforeach()
In this more general form, individual arguments can still be specified using the ITEMS keyword, but the LISTS keyword allows one or more list variables to be specified. Either ITEMS or LISTS (or both) must be provided when using this more general form. When both are provided, the ITEMS must appear after the LISTS. It is permitted for the listVarN list variables to hold an empty list. An example should help clarify this more general form’s usage.
set(list1 A B) set(list2) set(foo WillNotBeShown)
foreach(loopVar IN LISTS list1 list2 ITEMS foo bar) message("Iteration for: ${loopVar}") endforeach()
The output from the above would be:
Iteration for: A Iteration for: B Iteration for: foo Iteration for: bar
CMake 3.17 added a more specialized form for looping over multiple lists at once:
foreach(loopVar... IN ZIP_LISTS listVar...) # ... endforeach()
If only one loopVar is given, then the command will set variables of the form loopVar_N at each iteration, where N corresponds to the listVarN variable. Numbering starts from 0. If there is one loopVar for each listVar, then the command maps them one-to-one instead of creating loopVar_N variables. The following example demonstrates the two cases:
51


set(list0 A B) set(list1 one two)
foreach(var0 var1 IN ZIP_LISTS list0 list1) message("Vars: ${var0} ${var1}") endforeach()
foreach(var IN ZIP_LISTS list0 list1) message("Vars: ${var_0} ${var_1}") endforeach()
Both foreach() loops will print the same output:
Vars: A one Vars: B two
The lists to be "zipped" in this way do not have to be the same length. The associated iteration variable will be undefined when iteration moves past the end of the shorter list. Taking the value of an undefined variable results in an empty string. The next example demonstrates the behavior:
set(long A B C) set(short justOne)
foreach(varLong varShort IN ZIP_LISTS long short) message("Vars: ${varLong} ${varShort}") endforeach()
Vars: A justOne Vars: B Vars: C
The foreach() command also supports the more C-like iteration over a range of numerical values:
foreach(loopVar RANGE start stop [step])
When using the RANGE form of foreach(), the loop is executed with loopVar set to each value in the range start to stop (inclusive). If the step option is provided, then this value is added to the previous one after each iteration and the loop stops when the result of that is greater than stop. The RANGE form also accepts just one argument like so:
foreach(loopVar RANGE value)
This is equivalent to foreach(loopVar RANGE 0 value), which means the loop body will execute (value + 1) times. This is unfortunate, since the more intuitive expectation is probably that the loop body executes value times. For this reason, it is likely to be clearer to avoid using this second RANGE form and explicitly specify both the start and stop values instead.
52


Similar to the situation for the if() and endif() commands, in very early versions of CMake (i.e. prior to 2.8.0), all forms of the foreach() command required that the loopVar also be specified as an argument to endforeach(). Again, this harms readability and offers little benefit, so specifying the loopVar with endforeach() is discouraged for new projects.
6.2.2. while()
The other looping command offered by CMake is while():
while(condition) # ... endwhile()
The condition is tested and if it evaluates to true (following the same rules as the expression in if() statements), then the loop body is executed. This is repeated until condition evaluates to false or the loop is exited early (see next section). Again, in CMake versions prior to 2.8.0, the condition had to be repeated in the endwhile() command, but this is no longer necessary and is actively discouraged for new projects.
6.2.3. Interrupting Loops
Both while() and foreach() loops support the ability to exit the loop early with break() or to skip to the start of the next iteration with continue(). These commands behave just like their similarly named C language counterparts and both operate only on the inner-most enclosing loop. The following example illustrates the behavior.
foreach(outerVar IN ITEMS a b c) unset(s)
foreach(innerVar IN ITEMS 1 2 3) # Stop inner loop once string s gets long list(APPEND s "${outerVar}${innerVar}") string(LENGTH "${s}" length) if(length GREATER 5) # End the innerVar foreach loop early break() endif()
# Do no more processing if outerVar is "b" if(outerVar STREQUAL "b") # End current innerVar iteration and move on to next innerVar item continue() endif()
message("Processing ${outerVar}-${innerVar}") endforeach()
message("Accumulated list: ${s}") endforeach()
53


The output from the above example would be:
Processing a-1 Processing a-2 Accumulated list: a1;a2;a3 Accumulated list: b1;b2;b3 Processing c-1 Processing c-2 Accumulated list: c1;c2;c3
The break() and continue() commands are also permitted within a block defined by the block() and endblock() commands (see Section 5.4, “Scope Blocks”). Leaving a block via break() or continue() ends that block’s local scope. The following contrived example demonstrates the behavior:
set(log "Value: ") set(values one two skipMe three stopHere four) set(didSkip FALSE)
while(NOT values STREQUAL "") list(POP_FRONT values next)
# Modifications to "log" will be discarded block(PROPAGATE didSkip) string(APPEND log "${next}") if(next MATCHES "skip") set(didSkip TRUE) continue() elseif(next MATCHES "stop") break() elseif(next MATCHES "t") string(APPEND log ", has t") endif() message("${log}") endblock()
endwhile()
message("Did skip: ${didSkip}") message("Remaining values: ${values}")
Value: one Value: two, has t Value: three, has t Did skip: TRUE Remaining values: four
54


6.3. Recommended Practices
Minimize opportunities for strings to be unintentionally interpreted as variables in if(), foreach() and while() commands. Avoid unary expressions with quotes, prefer to use a string comparison operation instead. Strongly prefer to set a minimum CMake version of at least 3.1 to disable the old behavior that allowed implicit conversion of quoted string values to variable names.
When regular expression matching in if(xxx MATCHES regex) commands and the group capture variables are needed, it is generally advisable to store the CMAKE_MATCH_<n> match results in ordinary variables as soon as possible. These variables will be overwritten by the next command that does any sort of regular expression operation.
Prefer to use looping commands which avoid ambiguous or misleading code. If using the RANGE form of foreach(), always specify both the start and end values. If iterating over items, consider whether using the IN LISTS or IN ITEMS forms communicate more clearly what is being done rather
than a bare foreach(loopVar item1 item2 ...) form.
55


Chapter 7. Using Subdirectories
Keeping everything in one directory is fine for simple projects, but most real world projects split their files across multiple directories. It is common to find different file types or individual modules grouped under their own directories, or for files belonging to logical functional groupings to be in their own part of the project’s directory hierarchy. While the directory structure may be driven by how developers think of the project, the way the project is structured also impacts the build system.
Two fundamental CMake commands in any multi-directory project are add_subdirectory() and include(). These commands bring content from another file or directory into the build, allowing the build logic to be distributed across the directory hierarchy rather than forcing everything to be defined at the top-most level. This offers a number of advantages:
• Build logic is localized, meaning that characteristics of the build can be defined in the directory where they have the most relevance.
• Builds can be composed of subcomponents which are defined independently from the top level project consuming them. This is especially important if a project makes use of things like git submodules or embeds third party source trees.
• Because directories can be self-contained, it becomes relatively trivial to turn parts of the build on or off simply by choosing whether or not to add in that directory.
add_subdirectory() and include() have quite different characteristics, so it is important to understand the strengths and weaknesses of both.
7.1. add_subdirectory()
The add_subdirectory() command allows a project to bring another directory into the build. That directory must have its own CMakeLists.txt file which will be processed at the point where add_subdirectory() is called. A corresponding directory will be created in the project’s build tree.
add_subdirectory(sourceDir [binaryDir] [EXCLUDE_FROM_ALL] [SYSTEM] # Requires CMake 3.25 or later )
The sourceDir does not have to be a subdirectory within the source tree, although it usually is. Any directory can be added, with sourceDir being specified as either an absolute or relative path, the latter being relative to the current source directory. Absolute paths are typically only needed when adding directories that are outside the main source tree.
Normally, the binaryDir does not need to be specified. When omitted, CMake creates a directory in the build tree with the same name as the sourceDir. If sourceDir contains any path components, these will be mirrored in the binaryDir created by CMake. Alternatively, the binaryDir can be explicitly specified as either an absolute or relative path, with the latter being evaluated relative to the current binary directory (discussed in more detail shortly). If sourceDir is a path outside the source tree, CMake requires the binaryDir to be specified since a corresponding relative path can no longer be constructed automatically.
56


The optional EXCLUDE_FROM_ALL keyword is intended to control whether targets defined in the subdirectory being added should be included in the project’s ALL target by default. Unfortunately, for some CMake versions and project generators, it doesn’t always act as expected and can even result in broken builds. The SYSTEM keyword would not normally be used directly by projects and is discussed in Section 15.7.2, “System Header Search Paths”.
7.1.1. Source And Binary Directory Variables
Sometimes a developer needs to know the location of the build directory corresponding to the current source directory, such as when copying files needed at run time or to perform a custom build task. With add_subdirectory(), both the source and the build trees’ directory structures can be arbitrarily complex. There could even be multiple build trees being used with the same source tree. The developer therefore needs some assistance from CMake to determine the directories of interest. To that end, CMake provides a number of variables which keep track of the source and binary directories for the CMakeLists.txt file currently being processed. The following read-only variables are updated automatically as each file is processed by CMake. They always contain absolute paths.
CMAKE_SOURCE_DIR
The top-most directory of the source tree (i.e. where the top-most CMakeLists.txt file resides). This variable never changes its value.
CMAKE_BINARY_DIR
The top-most directory of the build tree. This variable never changes its value.
CMAKE_CURRENT_SOURCE_DIR
The directory of the CMakeLists.txt file currently being processed by CMake. It is updated each time a new file is processed as a result of an add_subdirectory() call and is restored back again when processing of that directory is complete.
CMAKE_CURRENT_BINARY_DIR
The build directory corresponding to the CMakeLists.txt file currently being processed by CMake. It changes for every call to add_subdirectory() and is restored again when add_subdirectory() returns.
An example should help demonstrate the behavior:
Top level CMakeLists.txt
cmake_minimum_required(VERSION 3.0) project(MyApp)
message("top: CMAKE_SOURCE_DIR = ${CMAKE_SOURCE_DIR}") message("top: CMAKE_BINARY_DIR = ${CMAKE_BINARY_DIR}") message("top: CMAKE_CURRENT_SOURCE_DIR = ${CMAKE_CURRENT_SOURCE_DIR}") message("top: CMAKE_CURRENT_BINARY_DIR = ${CMAKE_CURRENT_BINARY_DIR}")
add_subdirectory(mysub)
message("top: CMAKE_CURRENT_SOURCE_DIR = ${CMAKE_CURRENT_SOURCE_DIR}") message("top: CMAKE_CURRENT_BINARY_DIR = ${CMAKE_CURRENT_BINARY_DIR}")
57


mysub/CMakeLists.txt
message("mysub: CMAKE_SOURCE_DIR = ${CMAKE_SOURCE_DIR}") message("mysub: CMAKE_BINARY_DIR = ${CMAKE_BINARY_DIR}") message("mysub: CMAKE_CURRENT_SOURCE_DIR = ${CMAKE_CURRENT_SOURCE_DIR}") message("mysub: CMAKE_CURRENT_BINARY_DIR = ${CMAKE_CURRENT_BINARY_DIR}")
For the above example, if the top level CMakeLists.txt file was in the directory /somewhere/src and the build directory was /somewhere/build, the following output would be generated:
top: CMAKE_SOURCE_DIR = /somewhere/src top: CMAKE_BINARY_DIR = /somewhere/build top: CMAKE_CURRENT_SOURCE_DIR = /somewhere/src top: CMAKE_CURRENT_BINARY_DIR = /somewhere/build mysub: CMAKE_SOURCE_DIR = /somewhere/src mysub: CMAKE_BINARY_DIR = /somewhere/build mysub: CMAKE_CURRENT_SOURCE_DIR = /somewhere/src/mysub mysub: CMAKE_CURRENT_BINARY_DIR = /somewhere/build/mysub top: CMAKE_CURRENT_SOURCE_DIR = /somewhere/src top: CMAKE_CURRENT_BINARY_DIR = /somewhere/build
7.1.2. Scope
In Section 5.4, “Scope Blocks”, the concept of scope was discussed. One of the effects of calling add_subdirectory() is that CMake creates a new scope for processing that subdirectory’s CMakeLists.txt file. That new scope acts like a child of the calling scope, in a similar way to how the block() command creates a local child scope. The effects are very similar:
• All variables defined in the calling scope are copied into the subdirectory’s child scope upon entry.
• Any new variable created in the subdirectory’s child scope will not be visible to the calling scope.
• Any change to a variable in the subdirectory’s child scope is local to that child scope.
• Unsetting a variable in the subdirectory’s child scope does not unset it in the calling scope.
CMakeLists.txt
set(myVar foo)
message("Parent (before): myVar = ${myVar}") message("Parent (before): childVar = ${childVar}")
add_subdirectory(subdir)
message("Parent (after): myVar = ${myVar}") message("Parent (after): childVar = ${childVar}")
58


subdir/CMakeLists.txt
message("Child (before): myVar = ${myVar}") message("Child (before): childVar = ${childVar}")
set(myVar bar) set(childVar fuzz)
message("Child (after): myVar = ${myVar}") message("Child (after): childVar = ${childVar}")
This produces the following output:
Parent (before): myVar = foo 1 Parent (before): childVar = 2 Child (before): myVar = foo 3 Child (before): childVar = 4 Child (after): myVar = bar 5 Child (after): childVar = fuzz 6 Parent (after): myVar = foo 7 Parent (after): childVar = 8
1 myVar is defined at the parent level.
2 childVar is not defined at the parent level, so it evaluates to an empty string.
3 myVar is still visible in the child scope.
4 childVar is still undefined in the child scope before it is set.
5 myVar is modified in the child scope.
6 childVar is set in the child scope.
7 When processing returns to the parent scope, myVar still has the value from before the call to add_subdirectory(). The modification to myVar in the child scope is not visible to the parent.
8 childVar was defined in the child scope, so it is not visible to the parent and evaluates to an empty string.
The above behavior of scoping for variables highlights one of the important characteristics of add_subdirectory(). It allows the added directory to change whatever variables it wants without affecting variables in the calling scope. This helps keep the calling scope isolated from potentially unwanted changes.
As discussed in Section 5.4, “Scope Blocks”, the PARENT_SCOPE keyword can be used with the set() or unset() commands to change or unset a variable in a parent scope instead of the current scope. This works the same way for a child scope created by add_subdirectory():
CMakeLists.txt
set(myVar foo) message("Parent (before): myVar = ${myVar}") add_subdirectory(subdir) message("Parent (after): myVar = ${myVar}")
59


subdir/CMakeLists.txt
message("Child (before): myVar = ${myVar}") set(myVar bar PARENT_SCOPE) message("Child (after): myVar = ${myVar}")
This produces the following output:
Parent (before): myVar = foo Child (before): myVar = foo Child (after): myVar = foo 1 Parent (after): myVar = bar 2
1 The myVar in the child scope is not affected by the set() call because the PARENT_SCOPE keyword tells CMake to modify the parent’s myVar, not the local one.
2 The parent’s myVar has been modified by the set() call in the child scope.
Because the use of PARENT_SCOPE prevents any local variable of the same name from being modified by the command, it can be less misleading if the local scope does not reuse the same variable name as one from the parent. In the above example, a clearer set of commands would be:
subdir/CMakeLists.txt
set(localVar bar) set(myVar ${localVar} PARENT_SCOPE)
Obviously the above is a trivial example, but for real world projects, there may be many commands which contribute to building up the value of localVar before finally setting the parent’s myVar variable.
It’s not just variables that are affected by scope, policies and some properties also have similar behavior to variables in this regard. In the case of policies, each add_subdirectory() call creates a new scope in which policy changes can be made without affecting the policy settings of the parent. Similarly, there are directory properties which can be set in the child directory’s CMakeLists.txt file which will have no effect on the parent’s directory properties. Both of these are covered in more detail in their own respective chapters: Chapter 12, Policies and Chapter 9, Properties.
7.1.3. When To Call project()
A question that sometimes arises is whether to call project() in the CMakeLists.txt files of subdirectories. In most cases, it is not necessary or desirable to do so, but it is permitted. The only place where project() must be called is the top-most CMakeLists.txt file. Upon reading the top level CMakeLists.txt file, CMake scans that file’s contents looking for a call to project(). If no such call is found, CMake will issue a warning and insert an internal call to project() with the default C and C++ languages enabled. Projects should never rely on this mechanism, they should always explicitly call project() themselves. Note that it is not enough to call project() through a wrapper function or via a file read in via add_subdirectory() or include(), the top level CMakeLists.txt file must call
project() directly.
60


Calling project() in subdirectories typically does no harm, but it may result in CMake having to generate extra files. For the most part, these extra project() calls and generated files are just noise, but in some cases they can be useful. When using a Visual Studio project generator, each project() command results in the creation of an associated solution file. Normally, the developer would load the solution file corresponding to the top-most project() call (that solution file will be at the top of the build directory). This top level solution file contains all the targets in the project. The solution files generated for any project() calls within subdirectories will contain a more trimmed down view, containing just the targets from that directory scope and below, plus any other targets from the rest of the build that they depend on. Developers can load these sub-solutions instead of the top level one for a more trimmed-down view of the project, allowing them to focus on a smaller subset of the set of targets. For very large projects with many targets, this can be especially useful.
The Xcode generator behaves in a similar way, creating an Xcode project for each project() call. These Xcode projects can be loaded for a similar trimmed down view, but unlike for Visual Studio generators, they do not include the logic for building targets from outside of that directory scope or below. The developer is responsible for ensuring that anything required from outside of that trimmed down view has been built already. In practice, this means the top level project likely needs to be loaded and built first before switching to the trimmed down Xcode project.
7.2. include()
The other method CMake provides for pulling in content from other directories is the include() command, which has the following two forms:
include(fileName [OPTIONAL] [RESULT_VARIABLE myVar] [NO_POLICY_SCOPE]) include(module [OPTIONAL] [RESULT_VARIABLE myVar] [NO_POLICY_SCOPE])
The first form is somewhat analogous to add_subdirectory(), but there are important differences:
• include() expects the name of a file to read in, whereas add_subdirectory() expects a directory and will look for a CMakeLists.txt file within that directory. The file name passed to include() typically has the extension .cmake, but it can be anything.
• include() does not introduce a new variable scope, whereas add_subdirectory() does.
• Both commands introduce a new policy scope by default, but the include() command can be told not to do so with the NO_POLICY_SCOPE option (add_subdirectory() has no such option). See Chapter 12, Policies for further details on policy scope handling.
• The value of the CMAKE_CURRENT_SOURCE_DIR and CMAKE_CURRENT_BINARY_DIR variables do not change when processing the file named by include(), whereas they do change for add_subdirectory(). This will be discussed in more detail shortly.
The second form of the include() command serves an entirely different purpose. It is used to load the named module, a topic covered in depth in Chapter 11, Modules. All but the first of the above points also hold true for this second form.
Since the value of CMAKE_CURRENT_SOURCE_DIR does not change when include() is called, it may seem difficult for the included file to work out the directory in which it resides. CMAKE_CURRENT_SOURCE_DIR will contain the location of the file from where include() was called, not the directory containing
61


the included file. Furthermore, unlike add_subdirectory() where the fileName will always be CMakeLists.txt, the name of the file can be anything when using include(), so it can be difficult for the included file to determine its own name. To address situations like these, CMake provides an additional set of variables:
CMAKE_CURRENT_LIST_DIR
Analogous to CMAKE_CURRENT_SOURCE_DIR except it will be updated when processing the included file. This is the variable to use where the directory of the current file being processed is required, no matter how it has been added to the build. It will always hold an absolute path.
CMAKE_CURRENT_LIST_FILE
Always gives the name of the file currently being processed. It always holds an absolute path to the file, not just the file name.
CMAKE_CURRENT_LIST_LINE
Holds the line number of the file currently being processed. This variable is rarely needed, but may prove useful in some debugging scenarios.
Note that the above three variables work for any file being processed by CMake, not just those pulled in by an include() command. They have the same values as described above even for a
CMakeLists.txt file pulled in via add_subdirectory(), in which case CMAKE_CURRENT_LIST_DIR would have the same value as CMAKE_CURRENT_SOURCE_DIR. The following example demonstrates the behavior:
CMakeLists.txt
add_subdirectory(subdir) message("") include(subdir/CMakeLists.txt)
subdir/CMakeLists.txt
message("CMAKE_CURRENT_SOURCE_DIR = ${CMAKE_CURRENT_SOURCE_DIR}") message("CMAKE_CURRENT_BINARY_DIR = ${CMAKE_CURRENT_BINARY_DIR}") message("CMAKE_CURRENT_LIST_DIR = ${CMAKE_CURRENT_LIST_DIR}") message("CMAKE_CURRENT_LIST_FILE = ${CMAKE_CURRENT_LIST_FILE}") message("CMAKE_CURRENT_LIST_LINE = ${CMAKE_CURRENT_LIST_LINE}")
This produces output like the following:
CMAKE_CURRENT_SOURCE_DIR = /somewhere/src/subdir CMAKE_CURRENT_BINARY_DIR = /somewhere/build/subdir CMAKE_CURRENT_LIST_DIR = /somewhere/src/subdir CMAKE_CURRENT_LIST_FILE = /somewhere/src/subdir/CMakeLists.txt CMAKE_CURRENT_LIST_LINE = 5
CMAKE_CURRENT_SOURCE_DIR = /somewhere/src CMAKE_CURRENT_BINARY_DIR = /somewhere/build CMAKE_CURRENT_LIST_DIR = /somewhere/src/subdir CMAKE_CURRENT_LIST_FILE = /somewhere/src/subdir/CMakeLists.txt CMAKE_CURRENT_LIST_LINE = 5
62


The above example also highlights another interesting characteristic of the include() command. It can be used to include content from a file which has already been included in the build previously. If different subdirectories of a large, complex project both want to make use of CMake code in some file in a common area of the project, they may both include() that file independently.
7.3. Project-relative Variables
As will be seen in later chapters, various scenarios require paths relative to a location in the source or build directory. Consider one such example where a project needs a path to a file that resides in its top level source directory. From Section 7.1.1, “Source And Binary Directory Variables”,
CMAKE_SOURCE_DIR seems to be a natural fit, allowing a path like ${CMAKE_SOURCE_DIR}/someFile to be used. But consider what happens if that project is later incorporated into another parent project by bringing it into the parent build via add_subdirectory(). It could be used as a git submodule or fetched on demand using techniques like those discussed in Chapter 30, FetchContent. What used to be the top of the original project’s source tree is now a subdirectory within the parent project’s source tree. CMAKE_SOURCE_DIR now points to the top of the parent project, so the file path will be pointing to the wrong directory. A similar trap exists for CMAKE_BINARY_DIR.
The above scenario is encountered surprisingly often in online tutorials and older projects, but it can easily be avoided. The project() command sets some variables that provide a much more robust way of defining paths relative to locations in the directory hierarchy. The following variables will be available after project() has been called at least once:
PROJECT_SOURCE_DIR
The source directory of the most recent call to project() in the current scope or any parent scope. The project name (i.e. the first argument given to the project() command) is not relevant.
PROJECT_BINARY_DIR
The build directory corresponding to the source directory defined by PROJECT_SOURCE_DIR.
projectName_SOURCE_DIR
The source directory of the most recent call to project(projectName) in the current scope or any parent scope. This is tied to a specific project name and therefore to a particular call to project().
projectName_BINARY_DIR
The build directory corresponding to the source directory defined by projectName_SOURCE_DIR.
The following example demonstrates how these variables can be used (the ..._BINARY_DIR variables follow a similar pattern to the ..._SOURCE_DIR variables shown).
CMakeLists.txt
cmake_minimum_required(VERSION 3.0) project(topLevel)
message("Top level:") message(" PROJECT_SOURCE_DIR = ${PROJECT_SOURCE_DIR}") message(" topLevel_SOURCE_DIR = ${topLevel_SOURCE_DIR}") add_subdirectory(child)
63


child/CMakeLists.txt
message("Child:") message(" PROJECT_SOURCE_DIR (before) = ${PROJECT_SOURCE_DIR}")
project(child)
message(" PROJECT_SOURCE_DIR (after) = ${PROJECT_SOURCE_DIR}") message(" child_SOURCE_DIR = ${child_SOURCE_DIR}")
add_subdirectory(grandchild)
child/grandchild/CMakeLists.txt
message("Grandchild:") message(" PROJECT_SOURCE_DIR = ${PROJECT_SOURCE_DIR}") message(" child_SOURCE_DIR = ${child_SOURCE_DIR}") message(" topLevel_SOURCE_DIR = ${topLevel_SOURCE_DIR}")
Running cmake on the top level of this project hierarchy would give output similar to the following:
Top level: PROJECT_SOURCE_DIR = /somewhere/src topLevel_SOURCE_DIR = /somewhere/src Child: PROJECT_SOURCE_DIR (before) = /somewhere/src PROJECT_SOURCE_DIR (after) = /somewhere/src/child child_SOURCE_DIR = /somewhere/src/child Grandchild: PROJECT_SOURCE_DIR = /somewhere/src/child child_SOURCE_DIR = /somewhere/src/child topLevel_SOURCE_DIR = /somewhere/src
The above example shows the versatility of the project-related variables. They can be used from any part of the directory hierarchy to robustly refer to any other directory in the project. For the scenario discussed at the start of this section, using ${PROJECT_SOURCE_DIR}/someFile or perhaps
${projectName_SOURCE_DIR}/someFile instead of ${CMAKE_SOURCE_DIR}/someFile would ensure that the path to someFile would be correct, regardless of whether the project is being built stand-alone or being incorporated into a larger project hierarchy.
Some hierarchical build arrangements allow a project to be built either stand-alone or as part of a larger parent project (see Chapter 30, FetchContent). Some parts of the project might only make sense if it is the top of the build, such as setting up packaging support. A project can detect whether it is the top level by comparing the value of CMAKE_SOURCE_DIR with CMAKE_CURRENT_SOURCE_DIR. If they are the same, then the current directory scope must be the top level of the source tree.
if(CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR) add_subdirectory(packaging) endif()
64


The above technique is supported by all versions of CMake and is a very common pattern. With CMake 3.21 or later, a dedicated PROJECT_IS_TOP_LEVEL variable is provided which can achieve the same result, but is clearer in its intent:
# Requires CMake 3.21 or later if(PROJECT_IS_TOP_LEVEL) add_subdirectory(packaging) endif()
The value of PROJECT_IS_TOP_LEVEL will be true if the most recent call to project() in the current directory scope or above was in the top level CMakeLists.txt file. A similar variable, <projectName>_IS_TOP_LEVEL, is also defined by CMake 3.21 or later for every call to project(). It is created as a cache variable, so it can be read from any directory scope. <projectName> corresponds to the name given to the project() command of interest. This alternative variable is useful when there may be intervening calls to project() between the current scope and the scope of the project of interest.
7.4. Ending Processing Early
There can be occasions where a project may want to stop processing the remainder of the current file and return control back to the caller. The return() command can be used for this purpose. If not called from inside a function, return() ends processing of the current file regardless of whether it was brought in via include() or add_subdirectory(). The effect of calling return() inside a function is covered in Section 8.4, “Returning Values”, including special attention for a common mistake that can result in returning from the current file unintentionally.
With CMake 3.24 and earlier, the return() command cannot return any values to the caller. Starting with CMake 3.25, return() accepts a PROPAGATE keyword which has similarities to the same keyword of the block() command. Variables listed after the PROPAGATE keyword will be updated in the scope that control returns to. Historically, the return() command used to ignore all arguments given to it. Therefore, if using the PROPAGATE keyword, the CMP0140 policy must be set to NEW to indicate that the old behavior is not applicable (Chapter 12, Policies discusses policies in depth).
CMakeLists.txt
set(x 1) set(y 2) add_subdirectory(subdir) # Here, x will have the value 3 and y will be unset
subdir/CMakeLists.txt
# This ensures that we have a version of CMake that supports # PROPAGATE and that the CMP0140 policy is set to NEW. cmake_minimum_required(VERSION 3.25)
set(x 3) unset(y) return(PROPAGATE x y)
65


Two cases involving variable propagation and interaction with the block() command are worth highlighting. Both are consequences of the fact that the return() command updates variables in the scope it returns to. For the first of the two cases, if that returned-to scope is within a block, then that block’s scope is the one that gets updated.
CMakeLists.txt
set(x 1) set(y 2)
block() add_subdirectory(subdir) # Here, x will have the value 3 and y will be unset endblock() # Here, x is 1 and y is 2
The other case to highlight is more interesting. If the return() statement is itself inside a block, that block doesn’t affect the propagation of variables to the returned-to scope.
CMakeLists.txt
set(x 1) set(y 2) add_subdirectory(subdir) # Here, x will have the value 3 and y will be unset
subdir/CMakeLists.txt
cmake_minimum_required(VERSION 3.25)
# This block does not affect the propagation of x and y to # the parent CMakeLists.txt file's scope block() set(x 3) unset(y) return(PROPAGATE x y) endblock()
A word of caution is in order regarding the use of return(PROPAGATE) with directory scopes. While it may seem like an attractive way to pass information back to a parent scope, such usage is not consistent with the more target-centered approach of CMake best practice. Propagating variables to parent scopes drives the project structure to be more like the old-style variable-based methods. Those are known to be fragile, and they lack the power and expressiveness of target-centered methods. Variable propagation with return() is potentially appropriate when returning from functions though, as discussed in Section 8.4, “Returning Values”.
The return() command isn’t the only way to end processing of a file early. As noted in the previous section, different parts of a project may include the same file from multiple places. It can sometimes be desirable to check for this and only include the file once, returning early for subsequent inclusions to prevent reprocessing the file multiple times. This is very similar to the situation for C and C++ headers. It is therefore common to see a similar form of include guard used:
66


if(DEFINED cool_stuff_include_guard) return() endif()
set(cool_stuff_include_guard 1) # ...
With CMake 3.10 or later, this can be expressed more succinctly and robustly with a dedicated command whose behavior is analogous to the #pragma once of C and C++:
include_guard()
Compared to manually writing out the if-endif code, this is more robust because it handles the name of the guard variable internally. The command also accepts an optional keyword argument DIRECTORY or GLOBAL to specify a different scope within which to check for the file having been processed previously. These keywords are unlikely to be needed in most situations though. With neither argument specified, variable scope is assumed and the effect is exactly equivalent to the ifendif code above. GLOBAL ensures the command ends processing of the file if it has been processed before anywhere else in the project (i.e. variable scope is ignored). DIRECTORY checks for previous processing only within the current directory scope and below.
7.5. Recommended Practices
The best choice between using add_subdirectory() or include() to bring another directory into the build is not always obvious. On the one hand, add_subdirectory() is simpler and does a better job of keeping directories relatively self-contained because it creates its own scope. On the other, some CMake commands have restrictions which only allow them to operate on things defined within the current file scope, so include() works better for those cases. Section 15.2.6, “Source Files” and Section 34.5.1, “Building Up A Target Across Directories” discuss aspects of this topic.
As a general guide, most simple projects are probably better off preferring to use add_subdirectory() over include(). It promotes cleaner definition of the project and allows the CMakeLists.txt for a given directory to focus more on just what that directory needs to define. Following this strategy will promote better locality of information throughout the project and will also tend to introduce complexity only where it is needed and where it brings useful benefits. It’s not that include() itself is any more complicated than add_subdirectory(), but the use of include() tends to result in paths to files needing to be more explicitly spelled out, since what CMake considers the current source directory is not that of the included file. Many of the restrictions associated with calling certain commands from different directories have been removed in more recent CMake versions too, which further strengthens the argument to prefer add_subdirectory().
Irrespective of whether using add_subdirectory(), include() or a combination of both, the CMAKE_CURRENT_LIST_DIR variable is generally going to be a better choice than
CMAKE_CURRENT_SOURCE_DIR. By establishing the habit of using CMAKE_CURRENT_LIST_DIR early, it is much easier to switch between add_subdirectory() and include() as a project grows in complexity and to move entire directories to restructure a project.
67


Where possible, avoid using the CMAKE_SOURCE_DIR and CMAKE_BINARY_DIR variables, as these typically break the ability of the project to be incorporated into a larger project hierarchy. In the vast majority of cases, PROJECT_SOURCE_DIR and PROJECT_BINARY_DIR, or their project-specific equivalents
projectName_SOURCE_DIR and projectName_BINARY_DIR are more appropriate variables to use.
Avoid using the PROPAGATE keyword with return() statements that end processing of the current file. Propagating variables to the parent file violates the best practice of preferring to attach information to targets rather than passing details around in variables. Chapter 15, Compiler And Linker Essentials covers a lot of relevant material related to preferring target-centered practices.
If the project requires CMake 3.10 or later, prefer to use the include_guard() command without arguments instead of an explicit if-endif block in cases where multiple inclusion of a file must be prevented.
Avoid the practice of arbitrarily calling project() in the CMakeLists.txt of every subdirectory. Only consider putting a project() command in a subdirectory’s CMakeLists.txt file if that subdirectory can be treated as a more or less standalone project. Unless the whole build has a very high number of targets, there is little need to call project() anywhere other than in the top level CMakeLists.txt file.
68


Chapter 8. Functions And Macros
Looking back on the material covered in this book so far, CMake’s syntax is already starting to look a lot like a programming language in its own right. It supports variables, if-then-else logic, looping and inclusion of other files to be processed. It should be no surprise to learn that CMake also supports the common programming concepts of functions and macros too. Much like their role in other programming languages, functions and macros are the primary mechanism for projects and developers to extend CMake’s functionality and to encapsulate repetitive tasks in a natural way. They allow the developer to define reusable blocks of CMake code which can be called just like regular built-in CMake commands. They are also a cornerstone of CMake’s own module system (covered separately in Chapter 11, Modules).
8.1. The Basics
Functions and macros in CMake have very similar characteristics to their same-named counterparts in C/C++. Functions introduce a new scope and the function arguments become variables accessible inside the function body. Macros, on the other hand, effectively paste their body into the point of the call and the macro arguments are substituted as simple string replacements. These behaviors mirror the way functions and #define macros work in C/C++. A CMake function or macro is defined as follows:
function(name [arg1 [arg2 [...]]]) # Function body (i.e. commands) ... endfunction()
macro(name [arg1 [arg2 [...]]]) # Macro body (i.e. commands) ... endmacro()
Once defined, the function or macro is called in exactly the same way as any other CMake command. The function or macro’s body is then executed at the point of the call. For example:
function(print_me) message("Hello from inside a function") message("All done") endfunction()
# Called like so: print_me()
As shown above, the name argument defines the name used to call the function or macro and it should only contain letters, numbers and underscores. The name will be treated case-insensitively, so upper/lowercase conventions are more a matter of style (the CMake documentation follows the convention that command names are all lowercase with words separated by underscores). Very early versions of CMake required the name to be repeated as an argument to endfunction() or endmacro(), but new projects should avoid this as it only adds unnecessary clutter.
69


8.2. Argument Handling Essentials
The argument handling of functions and macros is the same except for one very important difference. For functions, each argument is a CMake variable and has all the usual behaviors of a CMake variable. For example, they can be tested in if() statements as variables. In comparison, macro arguments are string replacements, so whatever was used as the argument to the macro call is essentially pasted into wherever that argument appears in the macro body. If a macro argument is used in an if() statement, it would be treated as a string rather than a variable. The following example and its output demonstrate the difference:
function(func arg) if(DEFINED arg) message("Function arg is a defined variable") else() message("Function arg is NOT a defined variable") endif() endfunction()
macro(macr arg) if(DEFINED arg) message("Macro arg is a defined variable") else() message("Macro arg is NOT a defined variable") endif() endmacro()
func(foobar) macr(foobar)
Function arg is a defined variable Macro arg is NOT a defined variable
Aside from that difference, functions and macros both support the same features when it comes to argument processing. Each argument in the function definition serves as a case-sensitive label for the argument it represents. For functions, that label acts like a variable, whereas for macros it acts like a string substitution. The value of that argument can be accessed in the function or macro body using the usual variable notation, even though macro arguments are not technically variables.
function(func myArg) message("myArg = ${myArg}") endfunction()
macro(macr myArg) message("myArg = ${myArg}") endmacro()
func(foobar) macr(foobar)
70


Both the call to func() and the call to macr() print the same thing:
myArg = foobar
In addition to the named arguments, functions and macros come with a set of automatically defined variables (or variable-like names in the case of macros) which allow processing of arguments in addition to or instead of the named ones:
ARGC
This will be set to the total number of arguments passed to the function. It counts the named arguments plus any additional unnamed arguments that were given.
ARGV
This is a list containing each of the arguments passed to the function, including both the named arguments and any additional unnamed arguments that were given.
ARGN
Like ARGV, except this only contains arguments beyond the named ones (i.e. the optional, unnamed arguments).
In addition to the above, each individual argument can be referenced with a name of the form ARGVx where x is the number of the argument (e.g. ARGV0, ARGV1, etc.). This includes the named arguments, so the first named argument could also be referenced via ARGV0, etc. Note that it should be considered undefined behavior to use ARGVx with x >= ARGC.
Typical situations where the ARG... names are used include supporting optional arguments and implementing a command which can take an arbitrary number of items to be processed. Consider a function that defines an executable target, links that target to some library and defines a test case for it. Such a function is frequently encountered when writing test cases (a topic covered in Chapter 26, Testing). Rather than repeating the steps for every test case, the function allows the steps to be defined once and then each test case becomes a simple one-line definition.
# Use a named argument for the target and treat all other # (unnamed) arguments as the source files for the test case function(add_mytest targetName) add_executable(${targetName} ${ARGN})
target_link_libraries(${targetName} PRIVATE foobar)
add_test(NAME ${targetName} COMMAND ${targetName}) endfunction()
# Define some test cases using the above function add_mytest(smallTest small.cpp) add_mytest(bigTest big.cpp algo.cpp net.cpp)
The above example shows the usefulness of ARGN in particular. It allows a function or macro to take a varying number of arguments, yet still specify a set of named arguments which must be provided.
71


There is, however, a specific case to be aware of which can result in unexpected behavior. Because macros treat their arguments as string substitutions rather than as variables, if they use ARGN in a place where a variable name is expected, the variable it will refer to will be in the scope from which the macro is called, not the ARGN from the macro’s own arguments. The following example highlights the situation:
# WARNING: This macro is misleading macro(dangerous) # Which ARGN? foreach(arg IN LISTS ARGN) message("Argument: ${arg}") endforeach() endmacro()
function(func) dangerous(1 2) endfunction()
func(3)
The output from the above would be:
Argument: 3
When using the LISTS keyword with foreach(), a variable name has to be given, but the ARGN provided for a macro is not a variable name. When the macro is called from inside another function, the macro ends up using the ARGN variable from that enclosing function, not the ARGN from the macro itself. The situation becomes clear when pasting the contents of the macro body directly into the function where it is called (which is effectively what CMake will do with it):
function(func) # Now it is clear, ARGN here will use the arguments from func foreach(arg IN LISTS ARGN) message("Argument: ${arg}") endforeach() endfunction()
In such cases, consider making the macro a function instead, or if it must remain a macro then avoid treating arguments as variables. For the above example, the implementation of dangerous() could be changed to use foreach(arg IN ITEMS ${ARGN}) instead, but see Section 8.8, “Problems With Argument Handling” for some potential caveats.
8.3. Keyword Arguments
The previous section illustrated how the ARG... variables can be used to handle a varying set of arguments. That functionality is sufficient for the simple case where only one set of varying or optional arguments is needed, but if multiple optional or variable sets of arguments must be supported, the processing becomes quite tedious. Furthermore, the basic argument handling
72


described above is quite rigid compared to many of CMake’s own built-in commands which support keyword-based arguments and flexible argument ordering.
Consider the target_link_libraries() command:
target_link_libraries(targetName <PRIVATE|PUBLIC|INTERFACE> item1 [item2 ...] [<PRIVATE|PUBLIC|INTERFACE> item3 [item4 ...]] ... )
The targetName is required as the first argument, but after that, callers can provide any number of PRIVATE, PUBLIC or INTERFACE sections in any order, with each section permitted to contain any number of items. User-defined functions and macros can support a similar level of flexibility by using the cmake_parse_arguments() command, of which there are two forms. The first form is supported by all CMake versions and works for both functions and macros:
# Needed only for CMake 3.4 and earlier include(CMakeParseArguments)
cmake_parse_arguments( prefix valuelessKeywords singleValueKeywords multiValueKeywords argsToParse... )
The cmake_parse_arguments() command used to be provided by the CMakeParseArguments module, but it became a built-in command in CMake 3.5. The include(CMakeParseArguments) line will do nothing in CMake 3.5 and later, while for earlier versions of CMake it will define the cmake_parse_arguments() command (see Chapter 11, Modules for more on this sort of usage of include()).
The second form was introduced in CMake 3.7 and can only be used in functions, not macros:
# Available with CMake 3.7 or later, do not use in macros cmake_parse_arguments( PARSE_ARGV startIndex prefix valuelessKeywords singleValueKeywords multiValueKeywords )
Both forms of the command are similar, differing only in the way they take in the set of arguments to parse. With the first form, argsToParse will typically be given as ${ARGN} without quotes. This provides all arguments given to the enclosing function or macro beyond the named arguments, except for a few specific corner cases that don’t apply in most situations (see Section 8.8, “Problems With Argument Handling”).
In the second form, the PARSE_ARGV option tells cmake_parse_arguments() to read the arguments directly from the set of ${ARGVx} variables, with x ranging from startIndex to (ARGC - 1). Because it reads variables directly, it does not support being used inside macros. As already explained in
73


Section 8.2, “Argument Handling Essentials”, macros use string replacement rather than variables for its arguments. The main advantage of the second form is that for functions, it robustly handles the corner cases that the first form does not. If there are no named arguments for the enclosing function, then passing ${ARGV} or ${ARGN} to the first form is equivalent to giving PARSE_ARGV 0 to the second form when none of the corner cases apply.
The rest of the behavior of the two forms of the command is the same. Each of the ...Keywords is a list of keyword names to search for during parsing. Because they are a list, they need to be surrounded by quotes to ensure they are handled correctly. The valuelessKeywords define standalone keyword arguments which act like boolean switches. The keyword being present means one thing, its absence another. The singleValueKeywords each require exactly one additional argument after the keyword when they are used, whereas multiValueKeywords require zero or more additional arguments after the keyword. While not required, the prevailing convention is for keywords to be all uppercase, with words separated by underscores if required. Note that keywords should not be too long or they can be cumbersome to use.
When cmake_parse_arguments() returns, variables may be defined whose names consist of the specified prefix, an underscore and the name of the keyword they are associated with. For example, with a prefix of ARG, the variable corresponding to a keyword named FOO would be ARG_FOO. For each of the valuelessKeywords, the corresponding variable will be defined with the value TRUE if the keyword is present or FALSE if it is not. For each of the singleValueKeywords and multiValueKeywords, the corresponding variable will only be defined if that keyword is present and a value is provided after the keyword.
The following example illustrates how the three different keyword types are defined and handled:
function(func) # Define the supported set of keywords set(prefix ARG) set(noValues ENABLE_NET COOL_STUFF) set(singleValues TARGET) set(multiValues SOURCES IMAGES)
# Process the arguments passed in include(CMakeParseArguments) cmake_parse_arguments( ${prefix} "${noValues}" "${singleValues}" "${multiValues}" ${ARGN} )
# Log details for each supported keyword message("Option summary:")
foreach(arg IN LISTS noValues) if(${prefix}_${arg}) message(" ${arg} enabled") else() message(" ${arg} disabled") endif() endforeach()
74


foreach(arg IN LISTS singleValues multiValues) # Single argument values will print as a string # Multiple argument values will print as a list message(" ${arg} = ${${prefix}_${arg}}") endforeach() endfunction()
# Examples of calling with different combinations # of keyword arguments
func(SOURCES foo.cpp bar.cpp TARGET MyApp ENABLE_NET )
func(COOL_STUFF TARGET dummy IMAGES here.png there.png gone.png )
The corresponding output would look like this:
Option summary: ENABLE_NET enabled COOL_STUFF disabled TARGET = MyApp SOURCES = foo.cpp;bar.cpp IMAGES = Option summary: ENABLE_NET disabled COOL_STUFF enabled TARGET = dummy SOURCES = IMAGES = here.png;there.png;gone.png
The call to cmake_parse_arguments() in the above example could also have been written using the second form like so:
cmake_parse_arguments( PARSE_ARGV 0 ${prefix} "${noValues}" "${singleValues}" "${multiValues}" )
Arguments can be given to a command such that there are leftover arguments not associated with any keyword. The cmake_parse_arguments() command provides all leftover arguments as a list in the variable <prefix>_UNPARSED_ARGUMENTS. An advantage of the PARSE_ARGV form is that if any unparsed arguments are themselves a list, their embedded semicolons will be escaped. This preserves the original structure of the arguments, unlike the other form of the command which doesn’t. The following reduced example demonstrates this more clearly:
75


function(demoArgs) set(noValues "") set(singleValues SPECIAL) set(multiValues EXTRAS) cmake_parse_arguments( PARSE_ARGV 0 ARG "${noValues}" "${singleValues}" "${multiValues}" )
message("Left-over args: ${ARG_UNPARSED_ARGUMENTS}") foreach(arg IN LISTS ARG_UNPARSED_ARGUMENTS) message("${arg}") endforeach() endfunction()
demoArgs(burger fries "cheese;tomato" SPECIAL secretSauce)
Left-over args: burger;fries;cheese\;tomato burger fries cheese;tomato
Inside the demoArgs() function, the call to cmake_parse_arguments() will define the variable ARG_SPECIAL with the value secretSauce. The burger, fries and cheese;tomato arguments do not correspond to any recognized keywords, so they are treated as leftover arguments. As the above output shows, the original cheese;tomato list is preserved because the PARSE_ARGV form was used. This important point is revisited in Section 8.8.2, “Forwarding Command Arguments”.
In the above example, the SPECIAL keyword expects a single argument to follow it. If the call had omitted the value, cmake_parse_arguments() would not raise an error. With CMake 3.14 or earlier, the project would not be able to detect this situation, but with later versions, it can. With CMake 3.15 or later, the <prefix>_KEYWORDS_MISSING_VALUES variable will be populated with a list containing all single- or multi-value keywords that were present but which did not have any value following them. This can be demonstrated by modifying the previous example:
function(demoArgs) set(noValues "") set(singleValues SPECIAL) set(multiValues ORDINARY EXTRAS) cmake_parse_arguments( PARSE_ARGV 0 ARG "${noValues}" "${singleValues}" "${multiValues}" )
message("Keywords missing values: ${ARG_KEYWORDS_MISSING_VALUES}") endfunction()
demoArgs(burger fries SPECIAL ORDINARY EXTRAS high low)
76


In the above, SPECIAL and ORDINARY are each immediately followed by another keyword, so they have no values associated with them. Both can or should have values, so they will both be present in the
ARG_KEYWORDS_MISSING_VALUES variable populated by cmake_parse_arguments(). In the case of SPECIAL, it is probably an error, but for ORDINARY, it may still be valid since multi-value keywords can legitimately have no values. Projects should therefore be careful how they make use of
<prefix>_KEYWORDS_MISSING_VALUES.
The cmake_parse_arguments() command provides considerable flexibility. While the first form of the command usually takes ${ARGN} as the set of arguments to parse, other arguments can be given. One can take advantage of this to do things like multi-level argument parsing:
function(libWithTest) # First level of arguments set(groups LIB TEST) cmake_parse_arguments(GRP "" "" "${groups}" ${ARGN})
# Second level of arguments set(args SOURCES PRIVATE_LIBS PUBLIC_LIBS) cmake_parse_arguments(LIB "" "TARGET" "${args}" ${GRP_LIB}) cmake_parse_arguments(TEST "" "TARGET" "${args}" ${GRP_TEST})
add_library(${LIB_TARGET} ${LIB_SOURCES}) target_link_libraries(${LIB_TARGET} PUBLIC ${LIB_PUBLIC_LIBS} PRIVATE ${LIB_PRIVATE_LIBS} )
add_executable(${TEST_TARGET} ${TEST_SOURCES}) target_link_libraries(${TEST_TARGET} PUBLIC ${TEST_PUBLIC_LIBS} PRIVATE ${LIB_TARGET} ${TEST_PRIVATE_LIBS} )
endfunction()
libWithTest( LIB TARGET Algo SOURCES algo.cpp algo.h PUBLIC_LIBS SomeMathHelpers TEST TARGET AlgoTest SOURCES algoTest.cpp PRIVATE_LIBS gtest_main )
In the above example, the first level of arguments parsed by cmake_parse_arguments() is the usual ${ARGN}. The only keywords at this first level are the two multi-value keywords LIB and TEST. These define which target the sub-options following it should be applied to. The second level of parsing is fed either ${GRP_LIB} or ${GRP_TEST} as the set of arguments to parse rather than ${ARGN}. There is no conflict as a result of sub-options appearing more than once in the original set of ARGN arguments, since each target’s sub-options are parsed separately.
77


Compared to basic argument handling using named arguments or using the ARG... variables, the advantages of cmake_parse_arguments() are numerous:
• Being keyword-based, the calling site has improved readability, since the arguments essentially become self-documenting. Other developers reading the call site usually won’t need to look at the function implementation or its documentation to understand what each of the arguments mean.
• The caller gets to choose the order in which the arguments are given.
• The caller can simply omit those arguments which don’t need to be provided.
• Since each of the supported keywords has to be passed to cmake_parse_arguments() and it is typically called near the top of the function, it is generally very clear what arguments the function supports.
• Since parsing of the keyword based arguments is handled by the cmake_parse_arguments() command rather than from an ad hoc, manually coded parser, argument parsing bugs are virtually eliminated.
While these capabilities are quite powerful, the command still has some limitations. Built-in commands are able to support keywords being repeated. For example, commands like
target_link_libraries() allow the PRIVATE, PUBLIC and INTERFACE keywords to be used more than once in the same command. The cmake_parse_arguments() command does not support this to the same extent. It will only return the values associated with the last occurrence of a keyword and discard the earlier ones. A keyword can only be repeated if using a multi-level set of keywords and the keyword only appears once in any given set of arguments being processed.
8.4. Returning Values
A fundamental difference between functions and macros is that functions introduce a new variable scope, whereas macros do not. Functions receive a copy of all variables from the calling scope. Variables defined or modified inside a function have no effect on variables of the same name outside the function (unless explicitly propagated, as discussed below). As far as variables are concerned, the function is essentially its own self-contained sandbox, much like a scope created by the block() command (see Section 5.4, “Scope Blocks”). Macros, on the other hand, share the same variable scope as their caller and can therefore modify the caller’s variables directly. Note that functions do not introduce a new policy scope (see Section 12.3, “Recommended Practices” for further discussion of this).
8.4.1. Returning Values From Functions
With CMake 3.25 or later, a function can effectively return values by specifying variables to propagate to the caller. This is achieved using the PROPAGATE keyword with the return() command, similar to the behavior described previously in Section 7.4, “Ending Processing Early”. For each variable name listed after PROPAGATE, that variable will be updated in the calling scope to have the same value as in the function at the point of the return() call. If a propagated variable is unset in the function scope, it will also be unset in the calling scope. The CMP0140 policy must be set to NEW when the function is defined if the PROPAGATE keyword is used (Chapter 12, Policies discusses policies in depth).
78


# This ensures that we have a version of CMake that supports # PROPAGATE and that the CMP0140 policy is set to NEW cmake_minimum_required(VERSION 3.25)
function(doSomething outVar) set(${outVar} 42) return(PROPAGATE ${outVar}) endfunction()
doSomething(result) # Here, a variable named result now holds the value 42
A function should not normally dictate the name of variables to be set in the calling scope. Instead, function arguments should be used to tell the function the names of variables to be set in the calling scope. This ensures the caller is in full control of what the function does and that the function won’t overwrite variables the caller does not expect. CMake’s own built-in commands generally follow this pattern. The above example follows this recommendation by allowing the caller to specify the name of the result variable as the first argument to the function.
The return() statement propagates variables to the calling scope. This means any block() statements within the function do not prevent propagation to the function’s caller, but they will affect the value of the variable(s) being propagated. The previous example can be modified slightly to demonstrate this:
cmake_minimum_required(VERSION 3.25)
function(doSomething outVar) set(${outVar} 42) block() set(${outVar} 27) return(PROPAGATE ${outVar}) endblock() endfunction()
doSomething(result) # Here, a variable named result now holds the value 27
With CMake 3.24 and earlier, functions do not support returning a value directly. Since functions introduce their own variable scope, it may seem that there is no easy way to pass information back to the caller, but this is not the case. As discussed previously in Section 5.4, “Scope Blocks” and Section 7.1.2, “Scope”, the set() and unset() commands support a PARENT_SCOPE keyword, which can be used to modify a variable in the caller’s scope rather than a local variable within the function. While this isn’t the same as returning values from the function, it does allow values to be passed back to the calling scope to achieve a similar effect.
function(func resultVar1 resultVar2) set(${resultVar1} "First result" PARENT_SCOPE) set(${resultVar2} "Second result" PARENT_SCOPE) endfunction()
79


func(myVar otherVar)
message("myVar: ${myVar}") message("otherVar: ${otherVar}")
myVar: First result otherVar: Second result
8.4.2. Returning Values From Macros
Macros can "return" specific variables in the same way as functions, specifying the names of variables to be set by passing them in as arguments. The only difference is that the PARENT_SCOPE keyword should not be used within the macro when calling set() because the macro already modifies the variables in the caller’s scope. In fact, about the only reason one would use a macro instead of a function is if many variables need to be set in the calling scope. A macro will affect the calling scope with every set() or unset() call, whereas a function only affects the calling scope when
PARENT_SCOPE is explicitly given to set() or unset().
The last example of the previous section could be implemented equivalently as a macro like so:
macro(func resultVar1 resultVar2) set(${resultVar1} "First result") set(${resultVar2} "Second result") endmacro()
The behavior of return() within a macro is very different to a function. Because a macro does not introduce a new scope, the behavior of the return() statement is dependent on where the macro is called. Recall that a macro effectively pastes its commands at the call site. That being the case, any return() statement from a macro will actually be returning from the scope of whatever called the macro, not from the macro itself. Consider the following example:
macro(inner) message("From inner") return() # Usually dangerous within a macro message("Never printed") endmacro()
function(outer) message("From outer before calling inner") inner() message("Also never printed") endfunction()
outer()
The output from the above would be:
80


From outer before calling inner From inner
To highlight why the second message in the function body is never printed, paste the contents of the macro body into where it is called:
function(outer) message("From outer before calling inner")
# === Pasted macro body === message("From inner") return() message("Never printed") # === End of macro body ===
message("Also never printed") endfunction()
outer()
It is now much clearer why the return() statement causes processing to leave the function, even though it was originally called from inside the macro. This highlights the danger of using return() within macros. Because macros do not create their own scope, the result of a return() statement is often not what was expected.
8.5. Overriding Commands
When function() or macro() is called to define a new command, if a command already exists with that name, the undocumented CMake behavior is to make the old command available using the same name except with an underscore prepended. This applies whether the old name is for a builtin command or a custom function or macro. Developers who are aware of this behavior are sometimes tempted to exploit it to try to create a wrapper around an existing command like so:
function(someFunc) # Do something... endfunction()
# Later in the project... function(someFunc) if(...) # Override the behavior with something else... else() # WARNING: Intended to call the original command, but it is not safe _someFunc() endif() endfunction()
81


If the command is only ever overridden like this once, it appears to work, but if it is overridden again, then the original command is no longer accessible. The prepending of one underscore to "save" the previous command only applies to the current name, it is not applied recursively to all previous overrides. This has the potential to lead to infinite recursion, as the following contrived example demonstrates:
function(printme) message("Hello from first") endfunction()
function(printme) message("Hello from second") _printme() endfunction()
function(printme) message("Hello from third") _printme() endfunction()
printme()
One would naively expect the output to be as follows:
Hello from third Hello from second Hello from first
But instead, the first implementation is never called because the second one ends up calling itself in an infinite loop. When CMake processes the above, here’s what occurs:
1. The first implementation of printme is created and made available as a command of that name. No command by that name previously existed, so no further action is required.
2. The second implementation of printme is encountered. CMake finds an existing command by that name, so it defines the name _printme to point to the old command and sets printme to point to the new definition.
3. The third implementation of printme is encountered. Again, CMake finds an existing command by that name, so it redefines the name _printme to point to the old command (which is the second implementation) and sets printme to point to the new definition.
When printme() is called, execution enters the third implementation, which calls _printme(). This enters the second implementation which also calls _printme(), but _printme() points back at the second implementation again and infinite recursion results. Execution never reaches the first implementation.
In general, it is fine to override a function or macro as long as it does not try to call the previous implementation like in the above discussion. Projects should simply assume that the new implementation replaces the old one, with the old one considered to be no longer available.
82


8.6. Special Variables For Functions
CMake 3.17 added support for a number of variables to assist with debugging and implementing functions. The following variables will be available during execution of a function:
CMAKE_CURRENT_FUNCTION
Holds the name of the function currently being executed.
CMAKE_CURRENT_FUNCTION_LIST_FILE
Contains the full path to the file that defined the function currently being executed.
CMAKE_CURRENT_FUNCTION_LIST_DIR
Holds the absolute directory containing the file that defined the function currently being executed.
CMAKE_CURRENT_FUNCTION_LIST_LINE
Holds the line number at which the currently executing function was defined within the file that defined it.
The CMAKE_CURRENT_FUNCTION_LIST_DIR variable is particularly useful when a function needs to refer to a file that is an internal implementation detail of the function. The value of CMAKE_CURRENT_LIST_DIR would contain the directory of the file where the function is called, whereas CMAKE_CURRENT_FUNCTION_LIST_DIR holds the directory where the function is defined. To see how this can be used, consider the following example. It demonstrates a common pattern where a function uses the configure_file() command to copy a file from the same directory as the file defining the function (see Section 20.2, “Copying Files” for further discussion):
function(writeSomeFile toWhere) configure_file(${CMAKE_CURRENT_FUNCTION_LIST_DIR}/template.cpp.in ${toWhere} @ONLY) endfunction()
Before CMake 3.17, the above would typically be implemented something like the following instead (CMake’s own modules used this technique prior to CMake 3.17):
set(__writeSomeFile_DIR ${CMAKE_CURRENT_LIST_DIR})
function(writeSomeFile toWhere) configure_file(${__writeSomeFile_DIR}/template.cpp.in ${toWhere} @ONLY) endfunction()
This second example relies on the __writeSomeFile_DIR variable remaining visible at the point of the call to the function. Normally, that should be a reasonable assumption, but because functions have global scope visibility, projects can technically define a function in one place and call it in an unrelated variable scope. While that is technically legal, it is not a recommended practice. Extra care must also be taken with this technique when include guards are used in files that define functions (see Section 7.4, “Ending Processing Early”).
83


The CMAKE_CURRENT_FUNCTION... variables are only updated for functions, they are not modified inside macros. When executing code for a macro, these variables will hold whatever values they had when the macro was called.
8.7. Other Ways Of Invoking CMake Code
Functions and macros provide powerful ways of defining code to be executed at some later time. They are an essential part of re-using common logic for similar or repetitive tasks. Nevertheless, there are situations where projects may want to define CMake code to be executed in a way that functions and macros alone cannot capture.
CMake 3.18 added the cmake_language() command which can be used to invoke arbitrary CMake code directly without having to define a function or macro. This functionality isn’t designed to replace functions or macros, but rather to complement them by enabling more concise code and the ability to express logic in ways that were not previously possible. The two sub-commands provided by CMake 3.18 are CALL and EVAL CODE:
cmake_language(CALL command [args...]) cmake_language(EVAL CODE code...)
The CALL sub-command invokes a single CMake command, with arguments if required. It provides the ability to parameterize the command to be invoked without having to hard-code all available choices. Certain built-in commands cannot be invoked this way, specifically those commands that
start or end a block like if(), endif(), foreach(), endforeach() and so on.
The following example demonstrates how a generic wrapper can be defined around a set of functions that include a version number in their name:
function(qt_generate_moc) set(cmd qt${QT_DEFAULT_MAJOR_VERSION}_generate_moc)
cmake_language(CALL ${cmd} ${ARGV}) endfunction()
The above example assumes the QT_DEFAULT_MAJOR_VERSION variable has been set previously. As future Qt major versions are released, the above would continue to work as long as the appropriate versioned command was still provided. The alternative would be to implement an ever-expanding set of if() tests for each version individually.
The CALL sub-command is fairly limited in its usefulness. The EVAL CODE sub-command is much more powerful, as it supports executing any valid CMake script. One advantage of this is that it does not interfere with variables that get updated inside a function invocation, such as ARGV, CMAKE_CURRENT_FUNCTION and so on. The following example takes advantage of this behavior to implement a form of call tracing for functions:
84


set(myProjTraceCall [=[ message("Called ${CMAKE_CURRENT_FUNCTION}") set(__x 0) while(__x LESS ${ARGC}) message(" ARGV${__x} = ${ARGV${__x}}") math(EXPR __x "${__x} + 1") endwhile() unset(__x) ]=])
function(func) cmake_language(EVAL CODE "${myProjTraceCall}") # ... endfunction()
func(one two three)
Called func ARGV0 = one ARGV1 = two ARGV2 = three
Note how the code stored in myProjTraceCall makes use of the various ARG* variables and also the CMAKE_CURRENT_FUNCTION variable. Bracket syntax [=[ and ]=] is used to prevent the evaluation of these variables when myProjTraceCall is set. The variables will be evaluated only when cmake_language() is called, so they will reflect the details of the enclosing function. Because of this delayed evaluation, the tracing code won’t work as expected inside a macro, so only use it from inside a function.
See Section 8.8.2, “Forwarding Command Arguments” for another particularly interesting example of the EVAL CODE sub-command.
CMake 3.19 added the DEFER set of sub-commands. These allow a command to be queued for execution at a later time and to manage the set of currently queued commands. Creating a deferred command is accomplished with the following form:
cmake_language(DEFER [DIRECTORY dir] [ID id | ID_VAR outVar] CALL command [args...] 1 )
1 Evaluation of variables within command and args doesn’t follow the usual behavior of most other CMake commands. See Section 8.8.3, “Special Cases For Argument Expansion” for a discussion of the important differences.
The command and its arguments will be queued for execution at the end of the current directory scope. The DIRECTORY option can be given to specify a different directory scope instead. In that case, the dir directory must already be known to CMake and it must not already have finished being processed. In practice, this means it must be either the current directory or one of the parent directory scopes.
85


cmake_language(DEFER CALL message "End of current scope processing" )
cmake_language(DEFER DIRECTORY ${CMAKE_SOURCE_DIR} CALL message "End of top level processing" )
Each queued command has an identifier associated with it. Multiple commands can be associated with the same identifier to allow them to be manipulated as a group (see further below). Normally, the project would let CMake automatically assign a new identifier when queueing a new deferred command. The ID_VAR option can be used to capture the assigned identifier, which can then be reused in later calls with the ID option to add more commands to the same identifier.
cmake_language(DEFER ID_VAR deferredId CALL message "First deferred command" )
cmake_language(DEFER ID ${deferredId} CALL message "Second deferred command" )
Other DEFER sub-commands can query and cancel deferred commands based on identifiers:
cmake_language(DEFER [DIRECTORY dir] GET_CALL_IDS outVar) cmake_language(DEFER [DIRECTORY dir] GET_CALL id outVar) cmake_language(DEFER [DIRECTORY dir] CANCEL_CALL ids...)
The GET_CALL_IDS form returns a list of the identifiers for all commands currently queued for the specified directory scope, or the current directory scope if no DIRECTORY option is given. The GET_CALL form returns the first command and its arguments associated with the specified id. It is not possible to retrieve the second or later commands for a given identifier, nor a count of how many commands are associated with an identifier. The CANCEL_CALL form will discard all deferred commands associated with any of the specified identifiers.
At this point, it would be natural to start thinking of different ways one might put the DEFER functionality to use. Before doing so, consider the following observations:
• Special rules apply to variable expansion within deferred commands and their arguments (see Section 8.8.3, “Special Cases For Argument Expansion”). These can lead to subtle problems that can be difficult to trace.
• Deferred commands make it harder for developers to follow the flow of execution. This is especially true when deferred commands are created inside functions or macros and their creation isn’t made obvious.
• In deferring commands, the project may be making assumptions about what can happen between the deferral and the execution of the commands. It may be quite difficult to guarantee
86