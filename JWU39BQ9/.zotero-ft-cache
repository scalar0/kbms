Zero to Monero: Second Edition
a technical guide to a private digital currency;
for beginners, amateurs, and experts
Published April 4, 2020 (v2.0.0)
koe1, Kurt M. Alonso2, Sarang Noether3
License: Zero to Monero: Second Edition is released into the public domain.
1 ukoe@protonmail.com 2 kurt@oktav.se 3 sarang.noether@protonmail.com


Abstract
Cryptography. It may seem like only mathematicians and computer scientists have
access to this obscure, esoteric, powerful, elegant topic. In fact, many kinds of
cryptography are simple enough that anyone can learn their fundamental concepts.
It is common knowledge that cryptography is used to secure communications,
whether they be coded letters or private digital interactions. Another application is
in so-called cryptocurrencies. These digital moneys use cryptography to assign and
transfer ownership of funds. To ensure that no piece of money can be duplicated
or created at will, cryptocurrencies usually rely on ‘blockchains’, which are public,
distributed ledgers containing records of currency transactions that can be verified
by third parties [97].
It might seem at first glance that transactions need to be sent and stored in
plain text format to make them publicly verifiable. In fact, it is possible to conceal
a transaction’s participants, as well as the amounts involved, using cryptographic
tools that nevertheless allow transactions to be verified and agreed upon by
observers [136]. This is exemplified in the cryptocurrency Monero.
We endeavor here to teach anyone who knows basic algebra and simple com
puter science concepts like the ‘bit representation’ of a number not only how
Monero works at a deep and comprehensive level, but also how useful and beautiful
cryptography can be.
For our experienced readers: Monero is a standard one-dimensional distributed
acyclic graph (DAG) cryptocurrency blockchain [97] where transactions are based
on elliptic curve cryptography using curve Ed25519 [38], transaction inputs are
signed with Schnorr-style multilayered linkable spontaneous anonymous group
signatures (MLSAG) [108], and output amounts (communicated to recipients
via ECDH [52]) are concealed with Pedersen commitments [88] and proven in a
legitimate range with Bulletproofs [43]. Much of the first part of this report is
spent explaining these ideas.


Contents
1 Introduction 1
1.1 Objectives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
1.2 Readership . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.3 Origins of the Monero cryptocurrency . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.4 Outline . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
1.4.1 Part 1: ‘Essentials’ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
1.4.2 Part 2: ‘Extensions’ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
1.4.3 Additional content . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.5 Disclaimer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.6 History of Zero to Monero . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.7 Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
I Essentials 7
2 Basic Concepts 8
2.1 A few words about notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
2.2 Modular arithmetic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
iii


2.2.1 Modular addition and multiplication . . . . . . . . . . . . . . . . . . . . . . 10
2.2.2 Modular exponentiation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.2.3 Modular multiplicative inverse . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.2.4 Modular equations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
2.3 Elliptic curve cryptography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
2.3.1 What are elliptic curves? . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
2.3.2 Public key cryptography with elliptic curves . . . . . . . . . . . . . . . . . . 16
2.3.3 Diffie-Hellman key exchange with elliptic curves . . . . . . . . . . . . . . . . 16
2.3.4 Schnorr signatures and the Fiat-Shamir transform . . . . . . . . . . . . . . 16
2.3.5 Signing messages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
2.4 Curve Ed25519 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
2.4.1 Binary representation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
2.4.2 Point compression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
2.4.3 EdDSA signature algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
2.5 Binary operator XOR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
3 Advanced Schnorr-like Signatures 25
3.1 Prove knowledge of a discrete logarithm across multiple bases . . . . . . . . . . . . 25
3.2 Multiple private keys in one proof . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
3.3 Spontaneous Anonymous Group (SAG) signatures . . . . . . . . . . . . . . . . . . 27
3.4 Back’s Linkable Spontaneous Anonymous Group (bLSAG) signatures . . . . . . . . 29
3.5 Multilayer Linkable Spontaneous Anonymous Group (MLSAG) signatures . . . . . 32
3.6 Concise Linkable Spontaneous Anonymous Group (CLSAG) signatures . . . . . . . 34
4 Monero Addresses 36
4.1 User keys . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
4.2 One-time addresses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
4.2.1 Multi-output transactions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
4.3 Subaddresses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
4.3.1 Sending to a subaddress . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
4.4 Integrated addresses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
4.5 Multisignature addresses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
iv


5 Monero Amount Hiding 43
5.1 Commitments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
5.2 Pedersen commitments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
5.3 Amount commitments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
5.4 RingCT introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
5.5 Range proofs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
6 Monero Ring Confidential Transactions (RingCT) 48
6.1 Transaction types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
6.2 Ring Confidential Transactions of type RCTTypeBulletproof2 . . . . . . . . . . . . 49
6.2.1 Amount commitments and transaction fees . . . . . . . . . . . . . . . . . . 49
6.2.2 Signature . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
6.2.3 Avoiding double-spending . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
6.2.4 Space requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
6.3 Concept summary: Monero transactions . . . . . . . . . . . . . . . . . . . . . . . . 53
6.3.1 Storage requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
7 The Monero Blockchain 55
7.1 Digital currency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
7.1.1 Distributed/shared version of events . . . . . . . . . . . . . . . . . . . . . . 56
7.1.2 Simple blockchain . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
7.2 Difficulty . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
7.2.1 Mining a block . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
7.2.2 Mining speed . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
7.2.3 Consensus: largest cumulative difficulty . . . . . . . . . . . . . . . . . . . . 59
7.2.4 Mining in Monero . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
7.3 Money supply . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
7.3.1 Block reward . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
7.3.2 Dynamic block weight . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62
v


7.3.3 Block reward penalty . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
7.3.4 Dynamic minimum fee . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
7.3.5 Emission tail . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
7.3.6 Miner transaction: RCTTypeNull . . . . . . . . . . . . . . . . . . . . . . . . 69
7.4 Blockchain structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
7.4.1 Transaction ID . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
7.4.2 Merkle tree . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71
7.4.3 Blocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
II Extensions 74
8 Monero Transaction-Related Knowledge Proofs 75
8.1 Transaction proofs in Monero . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75
8.1.1 Multi-base Monero transaction proofs . . . . . . . . . . . . . . . . . . . . . 76
8.1.2 Prove creation of a transaction input (SpendProofV1) . . . . . . . . . . . . 76
8.1.3 Prove creation of a transaction output (OutProofV2) . . . . . . . . . . . . . 78
8.1.4 Prove ownership of an output (InProofV2) . . . . . . . . . . . . . . . . . . 79
8.1.5 Prove an owned output was not spent in a transaction (UnspentProof) . . . 81
8.1.6 Prove an address has a minimum unspent balance (ReserveProofV2) . . . 82
8.2 Monero audit framework . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
8.2.1 Prove an address and subaddress correspond (SubaddressProof) . . . . . . 84
8.2.2 The audit framework . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85
9 Multisignatures in Monero 86
9.1 Communicating with co-signers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
9.2 Key aggregation for addresses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
9.2.1 Naive approach . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
9.2.2 Drawbacks to the naive approach . . . . . . . . . . . . . . . . . . . . . . . . 88
9.2.3 Robust key aggregation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
vi


9.3 Thresholded Schnorr-like signatures . . . . . . . . . . . . . . . . . . . . . . . . . . 91
9.4 MLSTAG Ring Confidential signatures for Monero . . . . . . . . . . . . . . . . . . 93
9.4.1 RCTTypeBulletproof2 with N-of-N multisig . . . . . . . . . . . . . . . . . . 93
9.4.2 Simplified communication . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
9.5 Recalculating key images . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
9.6 Smaller thresholds . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98
9.6.1 1-of-N key aggregation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98
9.6.2 (N-1)-of-N key aggregation . . . . . . . . . . . . . . . . . . . . . . . . . . . 99
9.6.3 M-of-N key aggregation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
9.7 Key families . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
9.7.1 Family trees . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
9.7.2 Nesting multisig keys . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104
9.7.3 Implications for Monero . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106
10 Monero in an Escrowed Marketplace 107
10.1 Essential features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107
10.1.1 Purchasing workflow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108
10.2 Seamless Monero multisig . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
10.2.1 Basics of a multisig interaction . . . . . . . . . . . . . . . . . . . . . . . . . 110
10.2.2 Escrowed user experience . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
11 Joint Monero Transactions (TxTangle) 117
11.1 Building joint transactions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
11.1.1 n-way communication channel . . . . . . . . . . . . . . . . . . . . . . . . . 118
11.1.2 Message rounds to construct a joint transaction . . . . . . . . . . . . . . . . 119
11.1.3 Weaknesses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
11.2 Hosted TxTangle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122
11.2.1 Basic communication with a host over I2P, and other features . . . . . . . . 122
11.2.2 Host as a service . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
11.3 Using a trusted dealer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
11.3.1 Dealer-based procedure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
vii


Bibliography 126
Appendices 133
A RCTTypeBulletproof2 Transaction Structure 135
B Block Content 141
C Genesis Block 144
viii


CHAPTER 1
Introduction
In the digital realm it is often trivial to make endless copies of information, with equally endless
alterations. For a currency to exist digitally and be widely adopted, its users must believe its
supply is strictly limited. A money recipient must trust they are not receiving counterfeit coins,
or coins that have already been sent to someone else. To accomplish that without requiring the
collaboration of any third party like a central authority, its supply and complete transaction history
must be publicly verifiable.
We can use cryptographic tools to allow data registered in an easily accessible database - the
blockchain - to be virtually immutable and unforgeable, with legitimacy that cannot be disputed
by any party.
Cryptocurrencies store transactions in the blockchain, which acts as a public ledger1 of all the
currency operations. Most cryptocurrencies store transactions in clear text, to facilitate verifica
tion of transactions by the community of users.
Clearly, an open blockchain defies any basic understanding of privacy or fungibility2, since it
literally publicizes the complete transaction histories of its users.
1 In this context ledger just means a record of all currency creation and exchange events. Specifically, how much money was transferred in each event and to whom. 2 “Fungible means capable of mutual substitution in use or satisfaction of a contract. ... Examples: ... money, etc.”[25] In an open blockchain such as Bitcoin, the coins owned by Alice can be differentiated from those owned by Bob based on the ‘transaction history’ of those coins. If Alice’s transaction history includes transactions related to supposedly nefarious actors, then her coins might be ‘tainted’ [95], and hence less valuable than Bob’s (even if they own the same amount of coins). Reputable figures claim that newly minted Bitcoins trade at a premium over used coins, since they don’t have a history [118].
1


CHAPTER 1. INTRODUCTION 2
To address the lack of privacy, users of cryptocurrencies such as Bitcoin can obfuscate trans
actions by using temporary intermediate addresses [99]. However, with appropriate tools it is
possible to analyze flows and to a large extent link true senders with receivers [125, 41, 112, 48].
In contrast, the cryptocurrency Monero (Moe-neh-row) attempts to tackle the issue of privacy
by storing only single-use addresses for receipt of funds in the blockchain, and by authenticating
the dispersal of funds in each transaction with ring signatures. With these methods there are no
known generally effective ways to link receivers or trace the origin of funds.3
Additionally, transaction amounts in the Monero blockchain are concealed behind cryptographic
constructions, rendering currency flows opaque.
The result is a cryptocurrency with a high level of privacy and fungibility.
1.1 Objectives
Monero is an established cryptocurrency with over five years of development [127, 13], and main
tains a steadily increasing level of adoption [54].4 Unfortunately, there is little comprehensive
documentation describing the mechanisms it uses.5,6 Even worse, essential parts of its theoretical
framework have been published in non-peer-reviewed papers that are incomplete or contain errors.
For significant parts of the theoretical framework of Monero, only the source code is reliable as a
source of information.7
Moreover, for those without a background in mathematics, learning the basics of elliptic curve
cryptography, which Monero uses extensively, can be a haphazard and frustrating endeavor.8
We intend to palliate this situation by introducing the fundamental concepts necessary to under
stand elliptic curve cryptography, reviewing algorithms and cryptographic schemes, and collecting
in-depth information about Monero’s inner workings.
To provide the best experience for our readers, we have taken care to build a constructive, step
by-step description of the Monero cryptocurrency.
3 Depending on the behavior of users, there may be cases where transactions can be analyzed to some extent. For an example see this article: [61]. 4 In terms of market capitalization, Monero has been steady relative to other cryptocurrencies. It was 14th as of June 14th, 2018, and 12th on January 5th, 2020; see https://coinmarketcap.com/. 5 One documentation effort, at https://monerodocs.org/, has some helpful entries, especially related to the Command Line Interface. The CLI is a Monero wallet accessible through a console/terminal. It has the most functionality out of all Monero wallets, at the expense of no user-friendly graphical interface. 6 Another, more general, documentation effort called Mastering Monero can be found here: [57]. 7 Mr. Seguias has created the excellent Monero Building Blocks series [123], which contains a thorough treatment of the cryptographic security proofs used to justify Monero’s signature schemes. As with Zero to Monero: First Edition [33], Seguias’s series is focused on v7 of the protocol. 8 A previous attempt to explain how Monero works [110] did not elucidate elliptic curve cryptography, was incomplete, and is now over five years outdated.


CHAPTER 1. INTRODUCTION 3
In the second edition of this report we have centered our attention on version 12 of the Monero
protocol9, corresponding to version 0.15.x.x of the Monero software suite. All transaction and
blockchain-related mechanisms described here belong to those versions.10,11 Deprecated trans
action schemes have not been explored to any extent, even if they may be partially supported
for backward compatibility. Likewise with deprecated blockchain features. The first edition [33]
corresponded to version 7 of the protocol, and version 0.12.x.x of the software suite.
1.2 Readership
We anticipate many readers will encounter this report with little to no understanding of discrete
mathematics, algebraic structures, cryptography12, and blockchains. We have tried to be thorough
enough that laypeople from all perspectives may learn Monero without needing external research.
We have purposefully omitted, or delegated to footnotes, some mathematical technicalities, when
they would be in the way of clarity. We have also omitted concrete implementation details where
we thought they were not essential. Our objective has been to present the subject half-way between
mathematical cryptography and computer programming, aiming at completeness and conceptual
clarity.13
1.3 Origins of the Monero cryptocurrency
The cryptocurrency Monero, initially known as BitMonero, was created in April 2014 as a deriva
tive of the proof-of-concept currency CryptoNote [127]. Monero means ‘money’ in the language
Esperanto, and its plural form is Moneroj (Moe-neh-rowje, similar to Moneros but using the -ge
from orange).
CryptoNote is a cryptocurrency devised by various individuals. A landmark whitepaper describing
it was published under the pseudonym of Nicolas van Saberhagen in October 2013 [136]. It offered
receiver anonymity through the use of one-time addresses, and sender ambiguity by means of ring
signatures.
9 The ‘protocol’ is the set of rules that each new block is tested against before it can be added to the blockchain. This set of rules includes the ‘transaction protocol’ (currently version 2, RingCT), which are general rules pertaining to how a transaction is constructed. Specific transaction rules can, and do, change, without the transaction protocol’s version changing. Only large-scale changes to the transaction structure warrant moving its version number. 10 The Monero codebase’s integrity and reliability is predicated on assuming enough people have reviewed it to catch most or all significant errors. We hope that readers will not take our explanations for granted, and verify for themselves the code does what it’s supposed to. If it doesn’t, we hope you will make a responsible disclosure (https://hackerone.com/monero) for major problems, or Github pull request (https://github.com/ monero-project/monero) for minor issues.
11 Several protocols worth considering for the next generation of Monero transactions are undergoing research and investigation, including Triptych [106], RingCT3.0 [143], Omniring [84], and Lelantus [71]. 12 An extensive textbook on applied cryptography can be found here: [42]. 13 Some footnotes, especially in chapters related to the protocol, spoil future chapters or sections. These are intended to make more sense on a second read-through, since they usually involve specific implementation details that are only useful to those who have a grasp of how Monero works.


CHAPTER 1. INTRODUCTION 4
Since its inception, Monero has further strengthened its privacy aspects by implementing amount
hiding, as described by Greg Maxwell (among others) in [89] and integrated into ring signatures
based on Shen Noether’s recommendations in [108], then made more efficient with Bulletproofs
[43].
1.4 Outline
As mentioned, our aim is to deliver a self-contained and step-by-step description of the Monero
cryptocurrency. Zero to Monero has been structured to fulfill this objective, leading the reader
through all parts of the currency’s inner workings.
1.4.1 Part 1: ‘Essentials’
In our quest for comprehensiveness, we have chosen to present all the basic elements of cryptog
raphy needed to understand the complexities of Monero, and their mathematical antecedents. In
Chapter 2 we develop essential aspects of elliptic curve cryptography.
Chapter 3 expands on the Schnorr signature scheme from the prior chapter, and outlines the ring
signature algorithms that will be applied to achieve confidential transactions.
Chapter 4 explores how Monero uses addresses to control ownership of funds, and the different
kinds of addresses.
In Chapter 5 we introduce the cryptographic mechanisms used to conceal amounts.
With all the components in place, we explain the transaction scheme used in Monero in Chapter
6.
The Monero blockchain is unfolded in Chapter 7.
1.4.2 Part 2: ‘Extensions’
A cryptocurrency is more than just its protocol, and in ‘Extensions’ we talk about a number of
different ideas, many of which have not been implemented.14
Various information about a transaction can be proven to observers, and those methods are the
content of Chapter 8.
While not essential to the operation of Monero, there is a lot of utility in multisignatures that
allow multiple people to send and receive money collaboratively. Chapter 9 describes Monero’s
current multisignature approach and outlines possible future developments in that area.
14 Please note that future protocol versions of Monero, especially those implementing new transaction protocols, may make any or all of these ideas impossible or impractical.


CHAPTER 1. INTRODUCTION 5
Of extreme importance is applying multisig to the interactions of vendors and shoppers in online
marketplaces. Chapter 10 constitutes our original design of an escrowed marketplace using Monero
multisig.
First presented here, TxTangle, outlined in Chapter 11, is a decentralized protocol for joining the
transactions of multiple individuals into one.
1.4.3 Additional content
Appendix A explains the structure of a sample transaction from the blockchain. Appendix B
explains the structure of blocks (including block headers and miner transactions) in Monero’s
blockchain. Finally, Appendix C brings our report to a close by explaining the structure of
Monero’s genesis block. These provide a connection between the theoretical elements described in
earlier sections with their real-life implementation.
We Isn’t this
useful?
use margin notes to indicate where Monero implementation details can be found in the source
code.15 There is usually a file path, such as src/ringct/rctOps.cpp, and a function, such as
ecdhEncode(). Note: ‘-’ indicates split text, such as crypto- note → cryptonote, and we ne
glect namespace qualifiers (e.g. Blockchain::) in most cases.
1.5 Disclaimer
All signature schemes, applications of elliptic curves, and Monero implementation details should
be considered descriptive only. Readers considering serious practical applications (as opposed to
a hobbyist’s explorations) should consult primary sources and technical specifications (which we
have cited where possible). Signature schemes need well-vetted security proofs, and Monero imple
mentation details can be found in Monero’s source code. In particular, as a common saying goes,
‘don’t roll your own crypto’. Code implementing cryptographic primitives should be well-reviewed
by experts and have a long history of dependable performance. Moreover, original contributions
in this document may not be well-reviewed and are likely untested, so readers should exercise their
judgement when reading them.
1.6 History of Zero to Monero
Zero to Monero is an expansion of Kurt Alonso’s master’s thesis, ‘Monero - Privacy in the
Blockchain’ [32], published in May 2018. The first edition was published in June 2018 [33].
For the second edition we have improved how ring signatures are introduced (Chapter 3), reor
ganized how transactions are explained (added Chapter 4 on Monero Addresses), modernized the
15 Our margin notes are accurate for version 0.15.x.x of the Monero software suite, but may gradually become inaccurate as the codebase is constantly changing. However, the code is stored in a git repository (https://github. com/monero-project/monero), so a complete history of changes is available.


CHAPTER 1. INTRODUCTION 6
method used to communicate output amounts (Section 5.3), replaced Borromean ring signatures
with Bulletproofs (Section 5.5), deprecated RCTTypeFull (Chapter 6), updated and elaborated
Monero’s dynamic block weight and fee system (Chapter 7), investigated transaction-related proofs
(Chapter 8), described Monero multisignatures (Chapter 9), designed solutions for escrowed mar
ketplaces (Chapter 10), proposed a new decentralized joint transaction protocol named TxTangle
(Chapter 11), updated or added various minor details to align with the most current protocol (v12)
and Monero software suite (v0.15.x.x), and scoured the document for quality-of-reading edits.16
1.7 Acknowledgements
Written by author ‘koe’.
This report would not exist without Kurt’s original master’s thesis [32], so to him I owe a great
debt of gratitude. Monero Research Lab (MRL) researchers Brandon “Surae Noether” Goodell
and pseudonymous ‘Sarang Noether’ (who collaborated with me on Section 5.5 and Chapter 8)
have been a reliable and knowledgeable resource throughout both editions of Zero to Monero’s
development. Pseudonymous ‘moneromooo’, the Monero Project’s most prolific core developer,
has probably the most extensive understanding of the codebase on this planet, and has pointed me
in the right direction numerous times. And of course, many other wonderful Monero contributors
have spent time answering my endless questions. Finally, to the various individuals who contacted
us with proofreading feedback, and encouraging comments, thank you!
16 The LATEX source code for both editions of Zero to Monero can be found here (the first edition is in branch ‘ztm1’): https://github.com/UkoeHB/Monero-RCT-report.


Part I
Essentials
7


CHAPTER 2
Basic Concepts
2.1 A few words about notation
A focal objective of this report was to collect, review, correct, and homogenize all existing informa
tion concerning the inner workings of the Monero cryptocurrency. And, at the same time supply
all the necessary details to present the material in a constructive and single-threaded manner.
An important instrument to achieve this was to settle for a number of notational conventions.
Among others, we have used:
• lower case letters to denote simple values, integers, strings, bit representations, etc.
• upper case letters to denote curve points and complicated constructs
For items with a special meaning, we have tried to use as much as possible the same symbols
throughout the document. For instance, a curve generator is always denoted by G, its order is l,
private/public keys are denoted whenever possible by k/K respectively, etc.
Beyond that, we have aimed at being conceptual in our presentation of algorithms and schemes.
A reader with a computer science background may feel we have neglected questions like the bit
representation of items, or, in some cases, how to carry out concrete operations. Moreover, students
of mathematics may find we disregarded explanations of abstract algebra.
8


CHAPTER 2. BASIC CONCEPTS 9
However, we don’t see this as a loss. A simple object such as an integer or a string can always
be represented by a bit string. So-called ‘endianness’ is rarely relevant, and is mostly a matter of
convention for our algorithms.1
Elliptic curve points are normally denoted by pairs (x, y), and can therefore be represented with
two integers. However, in the world of cryptography it is common to apply point compression
techniques, which allow representing a point using only the space of one coordinate. For our con
ceptual approach it is often accessory whether point compression is used or not, but most of the
time it is implicitly assumed.
We src/crypto/
keccak.c
have also used cryptographic hash functions freely without specifying any concrete algorithms.
In the case of Monero it will typically be a Keccak 2 variant, but if not explicitly mentioned then
it is not important to the theory.
A cryptographic hash function (henceforth simply ‘hash function’, or ‘hash’) takes in some message
m of arbitrary length and returns a hash h (or ‘message digest’) of fixed length, with each possible
output equiprobable for a given input. Cryptographic hash functions are difficult to reverse, have
an interesting feature known as the large avalanche effect which can cause very similar messages to
produce very dissimilar hashes, and it is hard to find two messages with the same message digest.
Hash functions will be applied to integers, strings, curve points, or combinations of these objects.
These occurrences should be interpreted as hashes of bit representations, or the concatenation of
such representations. Depending on context, the result of a hash will be numeric, a bit string, or
even a curve point. Further details in this respect will be given as needed.
2.2 Modular arithmetic
Most modern cryptography begins with modular arithmetic, which in turn begins with the modulus
operation (denoted ‘mod’). We only care about the positive modulus, which always returns a
positive integer.
The positive modulus is similar to the ‘remainder’ after dividing two numbers, e.g. c the ‘remain
der’ of a/b. Let’s imagine a number line. To calculate c = a (mod b) we stand at point a then walk
toward zero with each step = b until we reach an integer ≥ 0 and < b. That is c. For example, 4
(modulo 3) = 1, −5 (mod 4) = 3, and so on.
1 In computer memory, each byte is stored in its own address (an address is akin to a numbered slot, which a byte can be stored in). A given ‘word’ or variable is referenced by the lowest address of its bytes. If variable x has 4 bytes, stored in addresses 10-13, address 10 is used to find x. The way bytes of x are organized in its set of addresses depends on endianness, although each individual byte is always and everywhere stored the same way within its address. Basically, which end of x is stored in the reference address? It could be the big end or little end. Given x = 0x12345678 (hexadecimal, 2 hexadecimal digits occupy 1 byte e.g. 8 binary digits a.k.a. bits), and an array of addresses {10, 11, 12, 13}, the big endian encoding of x is {12, 34, 56, 78} and the little endian encoding is {78, 56, 34, 12}. [78] 2 The Keccak hashing algorithm forms the basis for the NIST standard SHA-3 [27].


CHAPTER 2. BASIC CONCEPTS 10
Formally, the positive modulus is here defined for c = a (mod b) as a = bx + c, where 0 ≤ c < b
and x is a signed integer which gets discarded (b is a positive non-zero integer).
Note that, if a ≤ n, −a (mod n) is the same as n − a.
2.2.1 Modular addition and multiplication
In computer science it is important to avoid large numbers when doing modular arithmetic. For
example, if we have 29 + 87 (mod 99) and we aren’t allowed variables with three or more digits
(such as 116 = 29 + 87), then we can’t compute 116 (mod 99) = 17 directly.
To perform c = a + b (mod n), where a and b are each less than the modulus n, we can do this:
• Compute x = n − a. If x > b then c = a + b, otherwise c = b − x.
We can use modular addition to achieve modular multiplication (a ∗ b (mod n) = c) with an
algorithm called ‘double-and-add’. Let us demonstrate by example. Say we want to do 7 ∗ 8
(mod 9) = 2. It is the same as
7 ∗ 8 = 8 + 8 + 8 + 8 + 8 + 8 + 8 (mod 9)
Now break this into groups of two.
(8 + 8) + (8 + 8) + (8 + 8) + 8
And again, by groups of two.
[(8 + 8) + (8 + 8)] + (8 + 8) + 8
The total number of + point operations falls from 6 to 4 because we only need to find (8+8) once.3
Double-and-add is implemented by converting the first number (the ‘multiplicand’ a) to binary
(in our example, 7 → [0111]), then going through the binary array and doubling and adding.
Let’s make an array A = [0111] and index it 3,2,1,0.4 A[0] = 1 is the first element of A and is the
least significant bit. We set a result variable to be initially r = 0, and set a sum variable to be
initially s = 8 (more generally, we start with s = b). We follow this algorithm:
1. Iterate through: i = (0, ..., Asize − 1)
(a) If A[i] == 1, then r = r + s (mod n).
(b) Compute s = s + s (mod n).
2. Use the final r: c = r.
3 The effect of double-and-add becomes apparent with large numbers. For example, with 215 ∗ 230 straight addition would require about 215 + operations, while double-and-add only requires 15! 4 This is known as ‘LSB 0’ numbering, since the least significant bit has index 0. We will use ‘LSB 0’ for the rest of this chapter. The point here is clarity, not accurate conventions.


CHAPTER 2. BASIC CONCEPTS 11
In our example 7 ∗ 8 (mod 9), this sequence appears:
1. i = 0
(a) A[0] = 1, so r = 0 + 8 (mod 9) = 8
(b) s = 8 + 8 (mod 9) = 7
2. i = 1
(a) A[1] = 1, so r = 8 + 7 (mod 9) = 6
(b) s = 7 + 7 (mod 9) = 5
3. i = 2
(a) A[2] = 1, so r = 6 + 5 (mod 9) = 2
(b) s = 5 + 5 (mod 9) = 1
4. i = 3
(a) A[3] = 0, so r stays the same
(b) s = 1 + 1 (mod 9) = 2
5. r = 2 is the result
2.2.2 Modular exponentiation
Clearly 87 (mod 9) = 8 ∗ 8 ∗ 8 ∗ 8 ∗ 8 ∗ 8 ∗ 8 (mod 9). Just like double-and-add, we can do
square-and-multiply. For ae (mod n):
1. Define escalar → ebinary; A = [ebinary]; r = 1; m = a
2. Iterate through: i = (0, ..., Asize − 1)
(a) If A[i] == 1, then r = r ∗ m (mod n).
(b) Compute m = m ∗ m (mod n).
3. Use the final r as result.
2.2.3 Modular multiplicative inverse
Sometimes we need 1/a (mod n), or in other words a−1 (mod n). The inverse of something times
itself is by definition one (identity). Imagine 0.25 = 1/4, and then 0.25 ∗ 4 = 1.


CHAPTER 2. BASIC CONCEPTS 12
In modular arithmetic, for c = a−1 (mod n), ac ≡ 1 (mod n) for 0 ≤ c < n and for a and n
relatively prime.5 Relatively prime means they don’t share any divisors except 1 (the fraction a/n
can’t be reduced/simplified).
We can use square-and-multiply to compute the modular multiplicative inverse when n is a prime
number because of Fermat’s little theorem:6
an−1 ≡ 1 (mod n)
a ∗ an−2 ≡ 1 (mod n)
c ≡ an−2 ≡ a−1 (mod n)
More generally (and more rapidly), the so-called ‘extended Euclidean algorithm’ [7] can also find
modular inverses.
2.2.4 Modular equations
Suppose we have an equation c = 3 ∗ 4 ∗ 5 (mod 9). Computing this is straightforward. Given
some operation ◦ (for example, ◦ = ∗) between two expressions A and B:
(A ◦ B) (mod n) = [A (mod n)] ◦ [B (mod n)] (mod n)
In our example, we set A = 3 ∗ 4, B = 5, and n = 9:
(3 ∗ 4 ∗ 5) (mod 9) = [3 ∗ 4 (mod 9)] ∗ [5 (mod 9)] (mod 9)
= [3] ∗ [5] (mod 9)
c=6
Now we have a way to do modular subtraction.
A − B (mod n) → A + (−B) (mod n)
→ [A (mod n)] + [−B (mod n)] (mod n)
The same principle would apply to something like x = (a − b ∗ c ∗ d)−1(e ∗ f + gh) (mod n).7
5 In the equation a ≡ b (mod n), a is congruent to b (mod n), which just means a (mod n) = b (mod n). 6 The modular multiplicative inverse has a rule stating:
If ac ≡ b (mod n) with a and n relatively prime, the solution to this linear congruence is given by c = a−1b (mod n).[10] It means we can do c = a−1b (mod n) → ca ≡ b (mod n) → a ≡ c−1b (mod n). 7 The modulus of large numbers can exploit modular equations. It turns out 254 (mod 13) ≡ 2∗10∗10+5∗10+4 ≡ (((2) ∗ 10 + 5) ∗ 10 + 4) (mod 13). An algorithm for a (mod n) when a > n is:
1. Define A → [adecimal]; r = 0
2. For i = Asize − 1, ..., 0
(a) r = (r ∗ 10 + A[i]) (mod n)
3. Use the final r as result.


CHAPTER 2. BASIC CONCEPTS 13
2.3 Elliptic curve cryptography
2.3.1 What are elliptic curves?
A fe: field
element
finite field Fq, where q is a prime number greater than 3, is the field formed by the set
{0, 1, 2, ..., q − 1}. Addition and multiplication (+, ·) and negation (−) are calculated (mod q).
“Calculated (mod q)” means (mod q) is performed on any instance of an arithmetic operation
between two field elements, or negation of a single field element. For example, given a prime field
Fp with p = 29, 17 + 20 = 8 because 37 (mod 29) = 8. Also, −13 = −13 (mod 29) = 16.
Typically, an elliptic curve with a given (a, b) pair is defined as the set of all points with coordinates
(x, y) satisfying a Weierstraß equation [69]:8
y2 = x3 + ax + b where a, b, x, y ∈ Fq
The cryptocurrency Monero uses a special curve belonging to the category of so-called Twisted
Edwards curves [38], which are commonly expressed as (for a given (a, d) pair):
ax2 + y2 = 1 + dx2y2 where a, d, x, y ∈ Fq
In what follows we will prefer this second form. The advantage it offers over the previously men
tioned Weierstraß form is that basic cryptographic primitives require fewer arithmetic operations,
resulting in faster cryptographic algorithms (see Bernstein et al. in [40] for details).
Let P1 = (x1, y1) and P2 = (x2, y2) be two points belonging to a Twisted Edwards elliptic curve
(henceforth known simply as an EC). We define addition on points by defining P1 +P2 = (x1, y1)+
(x2, y2) as the point P3 = (x3, y3) where9
x3 = x1y2 + y1x2
1 + dx1x2y1y2
(mod q)
y3 = y1y2 − ax1x2
1 − dx1x2y1y2
(mod q)
These formulas for addition also apply for point doubling; that is, when P1 = P2. To subtract a
point, invert its coordinates over the y-axis, (x, y) → (−x, y) [38], and use point addition. Recall
that ‘negative’ elements −x of Fq are really −x (mod q).
Whenever two curve points are added together P3 is a point on the ‘original’ elliptic curve, or in
other words all x3, y3 ∈ Fq and satisfy the EC equation.
Each point P in EC can generate a subgroup of order (size) u out of some of the other points
in EC using multiples of itself. For example, some point P ’s subgroup might have order 5 and
8 Notation: The phrase a ∈ F means a is some element in the field F. 9 Typically elliptic curve points are converted into projective coordinates src/crypto/ crypto ops builder/ ref10CommentedCombined/ ge.h
prior to curve operations like point addition, in order to avoid performing field inversions for efficiency. [142]


CHAPTER 2. BASIC CONCEPTS 14
contain the points (0, P, 2P, 3P, 4P ), each of which is in EC. At 5P the so-called point-at-infinity
appears, which is like the ‘zero’ position on an EC, and has coordinates (0, 1).10
Conveniently, 5P + P = P . This means the subgroup is cyclic.11 All P in EC generate a cyclic
subgroup. If P generates a subgroup whose order is prime, then all the included points (except for
the point-at-infinity) generate that same subgroup. In our example, take multiples of point 2P :
2P, 4P, 6P, 8P, 10P → 2P, 4P, 1P, 3P, 0
Another example: a subgroup with order 6 (0, P, 2P, 3P, 4P, 5P ). Multiples of point 2P :
2P, 4P, 6P, 8P, 10P, 12P → 2P, 4P, 0, 2P, 4P, 0
Here 2P has order 3. Since 6 is not prime, not all of its member points recreate the original
subgroup.
Each EC has an order N equal to the total number of points in the curve (including the point
at-infinity), and the orders of all subgroups generated by points are divisors of N (by Lagrange’s
theorem). We can imagine a set of all EC points {0, P1, ..., PN−1}. If N isn’t prime, some points
will make subgroups with orders equal to divisors of N .
To find the order, u, of any given point P ’s subgroup:
1. Find N (e.g. use Schoof ’s algorithm).
2. Find all the divisors of N .
3. For every divisor n of N , compute nP .
4. The smallest n such that nP = 0 is the order u of the subgroup.
ECs ge: group
element
selected for cryptography typically have N = hl, where l is some sufficiently large (such as
160 bits) prime number and h is the so-called cofactor which could be as small as 1 or 2.12 One
point in the subgroup of size l is usually selected to be the generator G as a convention. For every
other point P in that subgroup there exists an integer 0 < n ≤ l satisfying P = nG.
Let’s expand our understanding. Say there is a point P ′ with order N , where N = hl. Any
other point Pi can be found with some integer ni such that Pi = niP ′. If P1 = n1P ′ has order l,
any P2 = n2P ′ with order l must be in the same subgroup as P1 because lP1 = 0 = lP2, and if
l(n1P ′) ≡ l(n2P ′) ≡ N P ′ = 0, then n1 & n2 must both be multiples of h. Since N = hl, there are
only l multiples of h, implying only one subgroup of size l is possible.
10 It turns out elliptic curves have abelian group structure under the addition operation described, since their point-at-infinity’s are identity elements. A concise definition of this notion can be found under https://brilliant. org/wiki/abelian-group/.
11 Cyclic subgroup means, for P ’s subgroup with order u, and with any integer n, nP = [n (mod u)]P . We can imagine ourselves standing on a point on a globe some distance from a ‘zero’th position, and each step we take moves us that distance. After a while, we will wind up back where we started, although it may take many revolutions before we land exactly on the original spot again. The number of steps it takes to land on the exact same spot is the ‘order’ of the ‘stepping group’, and all our footprints are unique points in that group. We recommend applying this concept to other ideas discussed here. 12 EC with small cofactors allow relatively faster point addition, etc. [38].


CHAPTER 2. BASIC CONCEPTS 15
Put simply, the subgroup formed by multiples of (hP ′) always contains P1 and P2. Furthermore,
h(n′P ′) = 0 when n′ is a multiple of l, and there are only h such variations of n′ (mod N )
(including the point at infinity for n′ = hl) because when n′ = hl it cycles back to 0: hlP ′ = 0.
So, there are only h points P in EC where hP will equal 0.
A similar argument could be applied to any subgroup of size u. Any two points P1 and P2 with
order u are in the same subgroup, which is composed of multiples of (N/u)P ′.
With this new understanding it is clear we can use the following algorithm to find (non-point-at
infinity) points in the subgroup of order l:
1. Find N of the elliptic curve EC, choose subgroup order l, compute h = N/l.
2. Choose a random point P ′ in EC.
3. Compute P = hP ′.
4. If P = 0 return to step 2, else P is in the subgroup of order l.
Calculating the scalar product between any integer n and any point P , nP , is not difficult, whereas sc: scalar
finding n such that P1 = nP2 is thought to be computationally hard. By analogy to modular
arithmetic, this is often called the discrete logarithm problem (DLP). Scalar multiplication can be
seen as a one-way function, which paves the way for using elliptic curves for cryptography.13
The scalar product nP is equivalent to (((P + P ) + (P + P )). . . ). Though not always the most
efficient approach, we can use double-and-add like in Section 2.2.1. To get the sum R = nP ,
remember we use the + point operation discussed in Section 2.3.1.
1. Define nscalar → nbinary; A = [nbinary]; R = 0, the point-at-infinity; S = P
2. Iterate through: i = (0, ..., Asize − 1)
(a) If A[i] == 1, then R += S.
(b) Compute S += S.
3. Use the final R as result.
Note that EC scalars for points in the subgroup of size l (which we will be using henceforth) are
members of the finite field Fl. This means arithmetic between scalars is mod l.
13 No known equation or algorithm can efficiently (based on available technology) solve for n in P1 = nP2, meaning it would take many many years to unravel just one scalar product.


CHAPTER 2. BASIC CONCEPTS 16
2.3.2 Public key cryptography with elliptic curves
Public key cryptography algorithms can be devised in a way analogous to modular arithmetic.
Let k be a randomly selected number satisfying 0 < k < l, and call it a private key.14 Calculate
the corresponding public key K (an EC point) with the scalar product kG = K.
Due to the discrete logarithm problem (DLP) we cannot easily deduce k from K alone. This
property allows us to use the values (k, K) in standard public key cryptography algorithms.
2.3.3 Diffie-Hellman key exchange with elliptic curves
A basic Diffie-Hellman [52] exchange of a shared secret between Alice and Bob could take place
in the following manner:
1. Alice and Bob generate their own private/public keys (kA, KA) and (kB, KB). Both publish
or exchange their public keys, and keep the private keys for themselves.
2. Clearly, it holds that
S = kAKB = kAkBG = kBkAG = kBKA
Alice could privately calculate S = kAKB, and Bob S = kBKA, allowing them to use this
single value as a shared secret.
For example, if Alice has a message m to send Bob, she could hash the shared secret h =
H(S), compute x = m + h, and send x to Bob. Bob computes h′ = H(S), calculates
m = x − h′, and learns m.
An external observer would not be able to easily calculate the shared secret due to the ‘Diffie
Hellman Problem’ (DHP), which says finding S from KA and KB is very difficult. Also, the DLP
prevents them from finding kA or kB.15
2.3.4 Schnorr signatures and the Fiat-Shamir transform
In 1989 Claus-Peter Schnorr published a now-famous interactive authentication protocol [121],
generalized by Maurer in 2009 [87], that allowed someone to prove they know the private key k of
a given public key K without revealing any information about it [89]. It goes something like this:
1. The prover generates a random integer α ∈R Zl,16 computes αG, and sends αG to the
verifier.
14 The private key is sometimes known as a secret key. This lets us abbreviate: pk = public key, sk = secret key. 15 The DHP is thought to be of at least similar difficulty to the DLP, although it has not been proven. [31] 16 Notation: The R in α ∈R Zl means α is randomly selected from {1, 2, 3, ..., l − 1}. src/crypto/ crypto.cpp random32 unbiased()
In other words, Zl is all integers (mod l). We exclude ‘l’ since the point-at-infinity is not useful here.


CHAPTER 2. BASIC CONCEPTS 17
2. The verifier generates a random challenge c ∈R Zl and sends c to the prover.
3. The prover computes the response r = α + c ∗ k and sends r to the verifier.
4. The verifier computes R = rG and R′ = αG + c ∗ K, and checks R ?= R′.
The verifier can compute R′ = αG + c ∗ K before the prover, so providing c is like saying, “I
challenge you to respond with the discrete logarithm of R′.” A challenge the prover can only
overcome by knowing k (except with negligible probability).
If α was chosen randomly by the prover then r is randomly distributed [122] and k is information
theoretically secure within r (it can still be found by solving the DLP for K or αG).17 However, if
the prover reuses α to prove his knowledge of k, anyone who knows both challenges in r = α + c ∗ k
and r′ = α + c′ ∗ k can compute k (two equations, two unknowns).18
k = r − r′
c − c′
If the prover knew c from the beginning (e.g. if the verifier secretly gave it to her), she could
generate a random response r and compute αG = rG − cK. When she later sends r to the verifier,
she ‘proves’ knowledge of k without ever having to know it. Someone observing the transcript of
events between prover and verifier would be none the wiser. The scheme is not publicly verifiable.
[89]
In his role as challenger, the verifier spits out a random number after receiving αG, making him
equivalent to a random function. Random functions, such as hash functions, are known as random
oracles because computing one is like requesting a random number from someone [89].19
Using a hash function, instead of the verifier, to generate challenges is known as a Fiat-Shamir
transform [60], because it makes an interactive proof non-interactive and publicly verifiable [89].20,21
Non-interactive proof
1. Generate random number α ∈R Zl, and compute αG.
17 A cryptosystem with information-theoretic security is one where even an adversary with infinite computing power could not break it, because they simply wouldn’t have enough information. 18 If the prover is a computer, you could imagine someone ‘cloning’/copying the computer after it generates α, then presenting each copy with a different challenge. 19 More generally, “[i]n cryptography... an oracle is any system which can give some extra information on a system, which otherwise would not be available.”[3] 20 The output of a cryptographic hash function H is uniformly distributed across the range of possible outputs. That is to say, for some input A, H(A) ∈D
R SH where SH is the set of possible outputs from H. We use ∈D
R to indicate the function is deterministically random. H(A) produces the same thing every time, but its output is equivalent to a random number. 21 Note that non-interactive Schnorr-like proofs (and signatures) require either use of a fixed generator G, or inclusion of the generator in the challenge hash. Including it that way is known as key prefixing, which we discuss a bit more later (Sections 3.4 and 9.2.3).


CHAPTER 2. BASIC CONCEPTS 18
2. Calculate the challenge using a cryptographically secure hash function, c = H([αG]).
3. Define the response r = α + c ∗ k.
4. Publish the proof pair (αG, r).
Verification
1. Calculate the challenge: c′ = H([αG]).
2. Compute R = rG and R′ = αG + c′ ∗ K.
3. If R = R′ then the prover must know k (except with negligible probability).
Why it works
rG = (α + c ∗ k)G
= (αG) + (c ∗ kG)
= αG + c ∗ K
R = R′
An important part of any proof/signature scheme is the resources required to verify them. This
includes space to store proofs, and time spent verifying. In this scheme we store one EC point
and one integer, and need to know the public key - another EC point. Since hash functions are
comparatively fast to compute, keep in mind that verification time is mostly a function of elliptic
curve operations src/ringct/
rctOps.cpp
.
2.3.5 Signing messages
Typically, a cryptographic signature is performed on a cryptographic hash of a message rather
than the message itself, which facilitates signing messages of varying size. However, in this report
we will loosely use the term ‘message’, and its symbol m, to refer to the message properly speaking
and/or its hash value, unless specified.
Signing messages is a staple of Internet security that lets a message’s recipient be confident its
content is as intended by the signer. One common signature scheme is called ECDSA. See [72],
ANSI X9.62, and [69].
The signature scheme we present here is an alternative formulation of the transformed Schnorr
proof from before. Thinking of signatures in this way prepares us for exploring ring signatures in
the next chapter.


CHAPTER 2. BASIC CONCEPTS 19
Signature
Assume Alice has the private/public key pair (kA, KA). To unequivocally sign an arbitrary message
m, she could execute the following steps:
1. Generate random number α ∈R Zl, and compute αG.
2. Calculate the challenge using a cryptographically secure hash function, c = H(m, [αG]).
3. Define the response r such that α = r + c ∗ kA. In other words, r = α − c ∗ kA.
4. Publish the signature (c, r).
Verification
Any third party who knows the EC domain parameters (specifying which elliptic curve was used),
the signature (c, r) and the signing method, m and the hash function, and KA can verify the
signature:
1. Calculate the challenge: c′ = H(m, [rG + c ∗ KA]).
2. If c = c′ then the signature passes.
In this signature scheme we store two scalars, and need one public EC key.
Why it works
This stems from the fact that
rG = (α − c ∗ kA)G
= αG − c ∗ KA
αG = rG + c ∗ KA
Hn(m, [αG]) = Hn(m, [rG + c ∗ KA])
c = c′
Therefore the owner of kA (Alice) created (c, r) for m: she signed the message. The probability
someone else, a forger without kA, could have made (c, r) is negligible, so a verifier can be confident
the message was not tampered with.


CHAPTER 2. BASIC CONCEPTS 20
2.4 Curve Ed25519
Monero uses a particular Twisted Edwards elliptic curve for cryptographic operations, Ed25519,
the birational equivalent22 of the Montgomery curve Curve25519.
Both Curve25519 and Ed25519 were released by Bernstein et al. [38, 39, 40].23
The src/crypto/
crypto ops
builder/
ref10Comm
entedComb
ined/
ge.h
curve is defined over the prime field F2255−19 (i.e. q = 2255 − 19) by means of the following
equation:
−x2 + y2 = 1 − 121665
121666 x2y2
This curve addresses many concerns raised by the cryptography community.24 It is well known
that NIST25 standard algorithms have issues. For example, it has recently become clear the NIST
standard random number generation algorithm PNRG (the version based on elliptic curves) is
flawed and contains a potential backdoor [68]. Seen from a broader perspective, standardization
authorities like NIST lead to a cryptographic monoculture, introducing a point of centralization.
A great example of this was illustrated when the NSA used its influence over NIST to weaken an
international cryptographic standard [18].
Curve Ed25519 is not subject to any patents (see [79] for a discussion on this subject), and the
team behind it has developed src/crypto/
crypto ops
builder/
and adapted basic cryptographic algorithms with efficiency in mind
[40].
Twisted Edwards curves have order expressible as N = 2cl, where l is a prime number and c a
positive integer. In the case of curve Ed25519, its order is a 76 digit number (l is 253 bits):26
23 · 7237005577332262213973186563042994240857116359379907606001950938285454250989 src/ringct/
rctOps.h
curve
Order()
2.4.1 Binary representation
Elements of F2255−19 are encoded as 256-bit integers, so they can be represented using 32 bytes.
Since each element only requires 255 bits, the most significant bit is always zero.
Consequently, any point in Ed25519 could be expressed using 64 bytes. By applying point com
pression techniques, described here below, however, it is possible to reduce this amount by half,
to 32 bytes.
22 Without giving further details, birational equivalence can be thought of as an isomorphism expressible using rational terms. 23 Dr. Bernstein also developed an encryption scheme known as ChaCha [37, 100], which the primary Monero implementation uses to encrypt src/wallet/ ringdb.cpp
certain sensitive information related to users’ wallets. 24 Even if a curve appears to have no cryptographic security problems, it’s possible the person/organization that created it knows a secret issue that only crops up in very rare curves. Such a person may have to randomly generate many curves in order to find one with a hidden weakness and no known weaknesses. If reasonable explanations are required for curve parameters, then it becomes even more difficult to find weak curves that will be accepted by the cryptographic community. Curve Ed25519 is known as a ‘fully rigid’ curve, which means its generation process was fully explained. [120] 25 National Institute of Standards and Technology, https://www.nist.gov/ 26 This means private EC keys in Ed25519 are 253 bits.


CHAPTER 2. BASIC CONCEPTS 21
2.4.2 Point compression
The Ed25519 curve has the property that its points can be easily compressed, so that representing
a point will consume only the space of one coordinate. We will not delve into the mathematics
necessary to justify this, but we can give a brief insight into how it works [74]. Point compression
for the Ed25519 curve was first described in [39], while the concept was first introduced in [94].
This point compression scheme follows from a transformation of the Twisted Edwards curve equa
tion (assuming a = −1, which is true for Monero): x2 = (y2 − 1)/(dy2 + 1),27 which indicates there
are two possible x values (+ or −) for each y. Field elements x and y are calculated (mod q), so
there are no actual negative values. However, taking (mod q) of –x will change the value between
odd and even since q is odd. For example: 3 (mod 5) = 3, −3 (mod 5) = 2. In other words, the
field elements x and –x have different odd/even assignments.
If we have a curve point and know its x is even, but given its y value the transformed curve
equation outputs an odd number, then we know negating that number will give us the right x.
One bit can convey this information, and conveniently the y coordinate has an extra bit.
Assume we want to compress a point (x, y).
Encoding We src/crypto/
crypto ops
builder/
ref10Comm
entedComb
ined/
ge to
bytes.c
set the most significant bit of y to 0 if x is even, and 1 if it is odd. The resulting
value y′ will represent the curve point.
Decoding
1. Retrieve
ge from
bytes.c
the compressed point y′, then copy its most significant bit to the parity bit b
before setting it to 0. Now it is the original y again.
2. Let u = y2 − 1 (mod q) and v = dy2 + 1 (mod q). This means x2 = u/v (mod q).
3. Compute28 z = uv3(uv7)(q−5)/8 (mod q).
(a) If vz2 = u (mod q) then x′ = z.
(b) If vz2 = −u (mod q) then calculate x′ = z ∗ 2(q−1)/4 (mod q).
4. Using the parity bit b from the first step, if b 6= the least significant bit of x′ then
x = −x′ (mod q), otherwise x = x′.
5. Return the decompressed point (x, y).
Implementations of Ed25519 (such as Monero) typically use the generator G = (x, 4/5) [39], where
x is the ‘even’, or b = 0, variant based on point decompression of y = 4/5 (mod q).
27 Here d = − 121665
121666 .
28 Since q = 2255 − 19 ≡ 5 (mod 8), (q − 5)/8 and (q − 1)/4 are integers.


CHAPTER 2. BASIC CONCEPTS 22
2.4.3 EdDSA signature algorithm
Bernstein and his team have developed a number of basic algorithms based on curve Ed25519.29
For illustration purposes we will describe a highly optimized and secure alternative to the ECDSA
signature scheme which, according to the authors, allows producing over 100 000 signatures per
second using a commodity Intel Xeon processor [39]. The algorithm can also be found described
in Internet RFC8032 [75]. Note this is a very Schnorr-like signature scheme.
Among other things, instead of generating random integers every time, it uses a hash value derived
from the private key of the signer and the message itself. This circumvents security flaws related
to the implementation of random number generators. Also, another goal of the algorithm is to
avoid accessing secret or unpredictable memory locations to prevent so-called cache timing attacks
[39].
We provide here an outline of the steps performed by the algorithm. A complete description and
sample implementation in the Python language can be found in [75].
Signature
1. Let hk be a hash H(k) of the signer’s private key k. Compute α as a hash α = H(hk, m) of
the hashed private key and message. Depending on implementation, m could be the actual
message or its hash [75].
2. Calculate αG and the challenge ch = H([αG], K, m).
3. Calculate the response r = α + ch · k.
4. The signature is the pair (αG, r).
Verification
Verification is performed as follows
1. Compute ch′ = H([αG], K, m).
2. If the equality 2crG ?= 2cαG + 2cch′ ∗ K holds then the signature is valid.
The 2c term comes from Bernstein et al.’s general form of the EdDSA algorithm [39]. According
to that paper, though it isn’t required for adequate verification, removing 2c provides stronger
equations.
29 See src/crypto/ crypto ops builder/ ref10CommentedCombined/
[40] for efficient group operations in Twisted Edwards EC (i.e. point addition, doubling, mixed addition, etc). See [36] for efficient modular arithmetic.


CHAPTER 2. BASIC CONCEPTS 23
The public key K can be any EC point, but we only want to use points in the generator G’s
subgroup. Multiplying by the cofactor 2c ensures all points are in that subgroup. Alternatively,
verifiers could check lK ?= 0, which only works if K is in the subgroup. We do not know of any
weaknesses caught by these precautions, though as we will see the latter method is important in
Monero (Section 3.4).
In this signature scheme we store one EC point and one scalar, and have one public EC key.
Why it works
2crG = 2c(α + H([αG], K, m) · k) · G
= 2cαG + 2cH([αG], K, m) · K
Binary representation
By default, an EdDSA signature would need 64 + 32 bytes for the EC point αG and scalar r.
However, RFC8032 assumes point αG is compressed, which reduces space requirements to only
32 + 32 bytes. We include the public key K, which implies 32 + 32 + 32 total bytes.
2.5 Binary operator XOR
The binary operator XOR is a useful tool that will appear in Sections 4.4 and 5.3. It takes two
arguments and returns true if one, but not both, of them is true [22]. Here is its truth table:
A B A XOR B
TT F
TF T
FT T
FF F
In the context of computer science, XOR is equivalent to bit addition modulo 2. For example, the
XOR of two bit pairs:
XOR({1, 1}, {1, 0}) = {1 + 1, 1 + 0} (mod 2)
= {0, 1}
Each of these also produce {0, 1}: XOR({1, 0}, {1, 1}), XOR({0, 0}, {0, 1}), and XOR({0, 1}, {0, 0}).
For XOR inputs with b bits, there are 2b − 1 other combinations of inputs that would make the
same output. This means if C = XOR(A, B) and input A ∈R {0, ..., 2b−1}, an observer who
learned C would gain no information about B.


CHAPTER 2. BASIC CONCEPTS 24
At the same time, anyone who knows two of the elements in {A, B, C}, where C = XOR(A, B),
can calculate the third element, such as A = XOR(B, C). XOR indicates if two elements are
different or the same, so knowing C and B is enough to expose A. A careful examination of the
truth table reveals this vital feature.30
30 One interesting application of XOR (unrelated to Monero) is swapping two bit registers without a third register. We use the symbol ⊕ to indicate an XOR operation. A⊕A = 0, so after three XOR operations between the registers: {A, B} → {[A ⊕ B], B} → {[A ⊕ B], B ⊕ [A ⊕ B]} = {[A ⊕ B], A ⊕ 0} = {[A ⊕ B], A} → {[A ⊕ B] ⊕ A, A} = {B, A}.


CHAPTER 3
Advanced Schnorr-like Signatures
A basic Schnorr signature has one signing key. As it happens, we can apply its core concepts to
create a variety of progressively more complex signature schemes. One of those schemes, MLSAG,
will be of central importance in Monero’s transaction protocol.
3.1 Prove knowledge of a discrete logarithm across multiple bases
It is often useful to prove the same private key was used to construct public keys on different ‘base’
keys. For example, we could have a normal public key kG, and a Diffie-Hellman shared secret kR
with some other person’s public key (recall Section 2.3.3), where the base keys are G and R. As
we will soon see, we can prove knowledge of the discrete log k in kG, prove knowledge of k in kR,
and prove that k is the same in both cases (all without revealing k).
Non-interactive proof
Suppose we have a private key k, and d base keys J = {J1, ..., Jd}. The corresponding public
keys are K = {K1, ..., Kd}. We make a Schnorr-like proof (recall Section 2.3.4) across all bases.1
Assume the existence of a hash function Hn mapping to integers from 0 to l − 1.2
1 While we say ‘proof’, it can be trivially made a signature by including a message m in the challenge hash. The terminology is loosely interchangeable in this context. 2 In Monero, the hash function Hn(x) = sc reduce32(Keccak (x)) where Keccak is the basis of SHA3 and sc reduce32() puts the 256 bit result in the range 0 to l − 1 (although it should really be 1 to l − 1).
25


CHAPTER 3. ADVANCED SCHNORR-LIKE SIGNATURES 26
1. Generate random number α ∈R Zl, and compute, for all i ∈ (1, ..., d), αJi.
2. Calculate the challenge,
c = Hn(J , K, [αJ1], [αJ2], ..., [αJd])
3. Define the response r = α − c ∗ k.
4. Publish the signature (c, r).
Verification
Assuming the verifier knows J and K, he does the following.
1. Calculate the challenge:
c′ = H(J , K, [rJ1 + c ∗ K1], [rJ2 + c ∗ K2], ..., [rJd + c ∗ Kd])
2. If c = c′ then the signer must know the discrete logarithm across all bases, and it’s the same
discrete logarithm in each case (as always, except with negligible probability).
Why it works
If instead of d base keys there was just one, this proof would clearly be the same as our original
Schnorr proof (Section 2.3.4). We can imagine each base key in isolation to see that the multi-base
proof is just a bunch of Schnorr proofs connected together. Moreover, by using only one challenge
and response for all of those proofs, they must have the same discrete logarithm k. To get a single
response that works for multiple keys the challenge would need to be known before defining an α
for each key, but c is a function of α!
3.2 Multiple private keys in one proof
Much like a multi-base proof, we can combine many Schnorr proofs that use different private
keys. Doing so proves we know all the private keys for a set of public keys, and reduces storage
requirements by making just one challenge for all proofs.
Non-interactive proof
Suppose we have d private keys k1, ..., kd, and base keys J = {J1, ..., Jd}.3 The corresponding
public keys are K = {K1, ..., Kd}. We make a Schnorr-like proof for all keys simultaneously.
3 There is no reason J can’t contain duplicate base keys here, or for all base keys to be the same (e.g. G). Duplicates would be redundant for multi-base proofs, but now we are dealing with different private keys.


CHAPTER 3. ADVANCED SCHNORR-LIKE SIGNATURES 27
1. Generate random numbers αi ∈R Zl for all i ∈ (1, ..., d), and compute all αiJi.
2. Calculate the challenge,
c = Hn(J , K, [α1J1], [α2J2], ..., [αdJd])
3. Define each response ri = αi − c ∗ ki.
4. Publish the signature (c, r1, ..., rd).
Verification
Assuming the verifier knows J and K, he does the following.
1. Calculate the challenge:
c′ = H(J , K, [r1J1 + c ∗ K1], [r2J2 + c ∗ K2], ..., [rdJd + c ∗ Kd])
2. If c = c′ then the signer must know the private keys for all public keys in K (except with
negligible probability).
3.3 Spontaneous Anonymous Group (SAG) signatures
Group signatures are a way of proving a signer belongs to a group, without necessarily identifying
him. Originally (Chaum in [49]), group signature schemes required the system be set up, and
in some cases managed, by a trusted person in order to prevent illegitimate signatures, and, in
a few schemes, adjudicate disputes. These relied on a group secret which is not desirable since
it creates a disclosure risk that could undermine anonymity. Moreover, requiring coordination
between group members (i.e. for setup and management) is not scalable beyond small groups or
inside companies.
Liu et al. presented a more interesting scheme in [85] building on the work of Rivest et al. in [119].
The authors detailed a group signature algorithm called LSAG characterized by three properties:
anonymity, linkability, and spontaneity. Here we discuss SAG, the non-linkable version of LSAG,
for conceptual clarity. We reserve the idea of linkability for later sections.
Schemes with anonymity and spontaneity are typically referred to as ‘ring signatures’. In the
context of Monero they will ultimately allow for unforgeable, signer-ambiguous transactions that
leave currency flows largely untraceable.


CHAPTER 3. ADVANCED SCHNORR-LIKE SIGNATURES 28
Signature
Ring signatures are composed of a ring and a signature. Each ring is a set of public keys, one of
which belongs to the signer and the rest of which are unrelated. The signature is generated with
that ring of keys, and anyone verifying it would not be able to tell which ring member was the
actual signer.
Our Schnorr-like signature scheme in Section 2.3.5 can be considered a one-key ring signature.
We get to two keys by, instead of defining r right away, generating a decoy r′ and creating a new
challenge to define r with.
Let m be the message to sign, R = {K1, K2, ..., Kn} a set of distinct public keys (a group/ring),
and kπ the signer’s private key corresponding to his public key Kπ ∈ R, where π is a secret index.
1. Generate random number α ∈R Zl and fake responses ri ∈R Zl for i ∈ {1, 2, ..., n} but
excluding i = π.
2. Calculate
cπ+1 = Hn(R, m, [αG])
3. For i = π + 1, π + 2, ..., n, 1, 2, ..., π − 1 calculate, replacing n + 1 → 1,
ci+1 = Hn(R, m, [riG + ciKi])
4. Define the real response rπ such that α = rπ + cπkπ (mod l).
The ring signature contains the signature σ(m) = (c1, r1, ..., rn), and the ring R.
Verification
Verification means proving σ(m) is a valid signature created by a private key corresponding to a
public key in R (without necessarily knowing which one), and is done in the following manner:
1. For i = 1, 2, ..., n iteratively compute, replacing n + 1 → 1,
c′
i+1 = Hn(R, m, [riG + ciKi])
2. If c1 = c′1 then the signature is valid. Note that c′1 is the last term calculated.
In this scheme we store (1+n) integers and use n public keys.


CHAPTER 3. ADVANCED SCHNORR-LIKE SIGNATURES 29
Why it works
We can informally convince ourselves the algorithm works by going through an example. Consider
ring R = {K1, K2, K3} with kπ = k2. First the signature:
1. Generate random numbers: α, r1, r3
2. Seed the signature loop:
c3 = Hn(R, m, [αG])
3. Iterate:
c1 = Hn(R, m, [r3G + c3K3])
c2 = Hn(R, m, [r1G + c1K1])
4. Close the loop by responding: r2 = α − c2k2 (mod l)
We can substitute α into c3 to see where the word ‘ring’ comes from:
c3 = Hn(R, m, [(r2 + c2k2)G])
c3 = Hn(R, m, [r2G + c2K2 ])
Then verification using R, and σ(m) = (c1, r1, r2, r3):
1. We use r1 and c1 to compute
c′
2 = Hn(R, m, [r1G + c1K1])
2. From when we made the signature, we see c′2 = c2. With r2 and c′2 we compute
c′
3 = Hn(R, m, [r2G + c′
2K2])
3. We can easily see that c′3 = c3 by substituting c2 for c′2. Using r3 and c′3 we get
c′
1 = Hn(R, m, [r3G + c′
3K3])
No surprises here: c′1 = c1 if we substitute c3 for c′3.
3.4 Back’s Linkable Spontaneous Anonymous Group (bLSAG)
signatures
The ring signature schemes discussed here on out display several properties that will be useful for
producing confidential transactions.4 Note that both ‘signer ambiguity’ and ‘unforgeability’ also
apply to SAG signatures.
4 Keep in mind that all robust signature schemes have security models which contain various properties. The properties mentioned here are perhaps most relevant to understanding the purpose of Monero’s ring signatures, but are not a comprehensive overview of linkable ring signature properties.


CHAPTER 3. ADVANCED SCHNORR-LIKE SIGNATURES 30
Signer Ambiguity An observer should be able to determine the signer must be a member of
the ring (except with negligible probability), but not which member.5 Monero uses this to
obfuscate the origin of funds in each transaction.
Linkability If a private key is used to sign two different messages then the messages will become
linked.6 As we will show, this property is used to prevent double-spending attacks in Monero
(except with negligible probability).
Unforgeability No attacker can forge a signature except with negligible probability.7 This is
used to prevent theft of Monero funds by those not in possession of the appropriate private
keys.
In the LSAG signature scheme [85], the owner of a private key could produce one anonymous
unlinked signature per ring.8 In this section we present an enhanced version of the LSAG algorithm
where linkability is independent of the ring’s decoy members.9
The modification was unraveled in [108] based on a publication by Adam Back [35] regarding the
CryptoNote [136] ring signature algorithm (previously used in Monero, and now deprecated; see
Section 8.1.2), which was in turn inspired by Fujisaki and Suzuki’s work in [65].
Signature
As with SAG, let m be the message to sign, R = {K1, K2, ..., Kn} a set of distinct public keys,
and kπ the signer’s private key corresponding to his public key Kπ ∈ R, where π is a secret index.
Assume the existence of a hash function Hp, which maps to curve points in EC.10,11
1. Calculate key image K ̃ = kπHp(Kπ).12
5 Anonymity for an action is usually in terms of an ‘anonymity set’, which is ‘all the people who could have possibly taken that action’. The largest anonymity set is ‘humanity’, and for Monero it is the ring size, or e.g. the so-called ‘mixin level’ v plus the real signer. Mixin refers to how many fake members each ring signature has. If the mixin is v = 4 then there are 5 possible signers. Expanding anonymity sets makes it progressively harder to track down real actors. 6 The linkability property does not apply to non-signing public keys. That is, a ring member whose public key has been used in different ring signatures will not cause linkage. 7 Certain ring signature schemes, including the one in Monero, are strong against adaptive chosen-message and adaptive chosen-public-key attacks. An attacker who can obtain legitimate signatures for chosen messages and corresponding to specific public keys in rings of his choice cannot discover how to forge the signature of even one message. This is called existential unforgeability; see [108] and [85]. 8 In the LSAG scheme linkability only applies to signatures using rings with the same members and in the same order, the ‘exact same ring.’ It is really “one anonymous signature per ring member per ring.” Signatures can be linked even if made for different messages. 9 LSAG was discussed in the first edition of this report. [33] 10 It doesn’t matter if points from Hp are compressed or not. They can always be decompressed. 11 Monero uses a hash function src/ringct/ rctOps.cpp hash to p3()
that returns curve points directly, rather than computing some integer that is then multiplied by G. Hp would be broken if someone discovered a way to find nx such that nxG = Hp(x). See a description of the algorithm in [107]. According to the CryptoNote whitepaper [136] its origin was this paper: [133]. 12 In Monero it’s important to use the hash to point function for key images instead of another base point so linearity doesn’t lead to linking signatures created by the same address (even if for different one-time addresses). See [136] page 18.


CHAPTER 3. ADVANCED SCHNORR-LIKE SIGNATURES 31
2. Generate random number α ∈R Zl and random numbers ri ∈R Zl for i ∈ {1, 2, ..., n} but
excluding i = π.
3. Compute
cπ+1 = Hn(m, [αG], [αHp(Kπ)])
4. For i = π + 1, π + 2, ..., n, 1, 2, ..., π − 1 calculate, replacing n + 1 → 1,
ci+1 = Hn(m, [riG + ciKi], [riHp(Ki) + ciK ̃ ])
5. Define rπ = α − cπkπ (mod l).
The signature will be σ(m) = (c1, r1, ..., rn), with key image K ̃ and ring R.
Verification
Verification means proving σ(m) is a valid signature created by a private key corresponding to a
public key in R, and is done in the following manner:
1. Check lK ̃ ?= 0.
2. For i = 1, 2, ..., n iteratively compute, replacing n + 1 → 1,
c′
i+1 = Hn(m, [riG + ciKi], [riHp(Ki) + ciK ̃ ])
3. If c1 = c′1 then the signature is valid.
In this scheme we store (1+n) integers, have one EC key image, and use n public keys.
We src/crypto
note core/
cryptonote
core.cpp
check tx
inputs key
images do
main()
must check lK ̃ ?= 0 because it is possible to add an EC point from the subgroup of size h (the
cofactor) to K ̃ and, if all ci are multiples of h (which we could achieve with automated trial and
error using different α and ri values), make h unlinked valid signatures using the same ring and
signing key.13 This is because an EC point multiplied by its subgroup’s order is zero.14
To be clear, given some point K in the subgroup of order l, some point Kh with order h, and an
integer c divisible by h:
c ∗ (K + Kh) = cK + cKh
= cK + 0
We can demonstrate correctness (i.e. ‘how it works’) in a similar way to the more simple SAG
signature scheme.
Our description attempts to be faithful to the original explanation of bLSAG, which does not
include R in the hash that calculates ci. Including keys in the hash is known as ‘key prefixing’.
Recent research [77] suggests it may not be necessary, although adding the prefix is standard
practice for similar signature schemes (LSAG uses key prefixing).
13 We are not concerned with points from other subgroups because the output of Hn is confined to Zl. For EC order N = hl, all divisors of N (and hence, possible subgroups) are either multiples of l (a prime) or divisors of h. 14 In Monero’s early history this was not checked for. Fortunately, it was not exploited before a fix was implemented in April 2017 (v5 of the protocol) [63].


CHAPTER 3. ADVANCED SCHNORR-LIKE SIGNATURES 32
Linkability
Given two valid signatures that are different in some way (e.g. different fake responses, different
messages, different overall ring members),
σ(m) = (c1, r1, ..., rn) with K ̃ , and
σ′(m′) = (c′
1, r′
1, ..., r′
n′ ) with K ̃ ′,
if K ̃ = K ̃ ′ then clearly both signatures come from the same private key.
While an observer could link σ and σ′, he wouldn’t necessarily know which Ki in R or R′ was the
culprit unless there was only one common key between them. If there was more than one common
ring member, his only recourse would be solving the DLP or auditing the rings in some way (such
as learning all ki with i 6= π, or learning kπ).15
3.5 Multilayer Linkable Spontaneous Anonymous Group (ML
SAG) signatures
In order to sign transactions, one has to sign with multiple private keys. In [108], Shen Noether
et al. describe a multi-layered generalization of the bLSAG signature scheme applicable when we
have a set of n · m keys; that is, the set
R = {Ki,j} for i ∈ {1, 2, ..., n} and j ∈ {1, 2, ..., m}
where we know the m private keys {kπ,j} corresponding to the subset {Kπ,j} for some index i = π.
Such an algorithm would address our needs if we generalize the notion of linkability.
Linkability If any private key kπ,j is used in 2 different signatures, then those signatures will be
automatically linked.
Signature
1. Calculate key images K ̃j = kπ,jHp(Kπ,j) for all j ∈ {1, 2, ..., m}.
2. Generate random numbers αj ∈R Zl, and ri,j ∈R Zl for i ∈ {1, 2, ..., n} (except i = π) and
j ∈ {1, 2, ..., m}.
3. Compute16
cπ+1 = Hn(m, [α1G], [α1Hp(Kπ,1)], ..., [αmG], [αmHp(Kπ,m)])
15 LSAG, which is quite similar to bLSAG, is unforgeable, meaning no attacker could make a valid ring signature without knowing a private key. If he invents a fake K ̃ and seeds his signature computation with cπ+1, then, not knowing kπ, he can’t calculate a number rπ = α − cπkπ that would produce [rπG + cπKπ] = αG. A verifier would reject his signature. Liu et al. prove forgeries that manage to pass verification are extremely improbable [85]. 16 Monero src/ringct/ rctSigs.cpp MLSAG Gen()
MLSAG uses key prefixing. Each challenge contains explicit public keys like this (adding the K terms absent from bLSAG; key images are included in the message signed):
cπ+1 = Hn(m, Kπ,1, [α1G], [α1Hp(Kπ,1)], ..., Kπ,m, [αmG], [αmHp(Kπ,m)])


CHAPTER 3. ADVANCED SCHNORR-LIKE SIGNATURES 33
4. For i = π + 1, π + 2, ..., n, 1, 2, ..., π − 1 calculate, replacing n + 1 → 1,
ci+1 = Hn(m, [ri,1G+ciKi,1], [ri,1Hp(Ki,1)+ciK ̃1], ..., [ri,mG+ciKi,m], [ri,mHp(Ki,m)+ciK ̃m])
5. Define all rπ,j = αj − cπkπ,j (mod l).
The signature will be σ(m) = (c1, r1,1, ..., r1,m, ..., rn,1, ..., rn,m), with key images (K ̃1, ..., K ̃m).
Verification
Verification of a signature is done in the following manner:
1. For all j ∈ {1, ..., m} check lK ̃j
?= 0.
2. For i = 1, ..., n compute, replacing n + 1 → 1,
c′
i+1 = Hn(m, [ri,1G + ciKi,1], [ri,1Hp(Ki,1) + ciK ̃1], ..., [ri,mG + ciKi,m], [ri,mHp(Ki,m) + ciK ̃m])
3. If c1 = c′1 then the signature is valid.
Why it works
Just as with the SAG algorithm, we can readily observe that
• If i 6= π, then clearly the values c′
i+1 are calculated as described in the signature algorithm.
• If i = π then, since rπ,j = αj − cπkπ,j closes the loop,
rπ,j G + cπKπ,j = (αj − cπkπ,j )G + cπKπ,j = αj G
and
rπ,jHp(Kπ,j) + cπK ̃j = (αj − cπkπ,j)Hp(Kπ,j) + cπK ̃j = αjHp(Kπ,j)
In other words, it holds also that c′π+1 = cπ+1.
Linkability
If a private key kπ,j is re-used to make any signature, the corresponding key image K ̃j supplied in
the signature will reveal it. This observation matches our generalized definition of linkability.17
Space requirements
In this scheme we store (1+m ∗ n) integers, have m EC key images, and use m ∗ n public keys.
17 As with bLSAG, linked MLSAG signatures do not indicate which public key was used to sign it. However, if the linking key image’s sub-loops’ rings have only one key in common, the culprit is obvious. If the culprit is identified, all other signing members of both signatures are revealed since they share the culprit’s indices.


CHAPTER 3. ADVANCED SCHNORR-LIKE SIGNATURES 34
3.6 Concise Linkable Spontaneous Anonymous Group (CLSAG)
signatures
CLSAG [67]18 is sort of half-way between bLSAG and MLSAG. Suppose you have a ‘primary’ key,
and associated with it are several ‘auxiliary’ keys. It is important to prove knowledge of all private
keys, but linkability only applies to the primary. This linkability retraction allows smaller, faster
signatures than afforded by MLSAG.
As with MLSAG, we have a set of n · m keys (n is the ring size, m is the number of signing keys),
and the primary keys are at index 1. In other words, there are n primary keys, and the πth such
key and its auxiliaries will sign.
R = {Ki,j} for i ∈ {1, 2, ..., n} and j ∈ {1, 2, ..., m}
We know the private keys {kπ,j} corresponding to the subset {Kπ,j} for some index i = π.
Signature
1. Calculate key images K ̃j = kπ,jHp(Kπ,1) for all j ∈ {1, 2, ..., m}. Note the base key is always
the same, and so key images with j > 1 are ‘auxiliary key images’. For notational simplicity
we call them all K ̃j.
2. Generate random numbers α ∈R Zl, and ri ∈R Zl for i ∈ {1, 2, ..., n} (except i = π).
3. Calculate aggregate public keys Wi for i ∈ {1, 2, ..., n}, and aggregate key image W ̃ 19
Wi =
m
∑
j=1
Hn(Tj, R, K ̃1, ..., K ̃m) ∗ Ki,j
W ̃ =
m
∑
j=1
Hn(Tj, R, K ̃1, ..., K ̃m) ∗ K ̃j
where wπ = ∑
j Hn(Tj, ...) ∗ kπ,j is the aggregate private key.
4. Compute
cπ+1 = Hn(Tc, R, m, [αG], [αHp(Kπ,1)])
5. For i = π + 1, π + 2, ..., n, 1, 2, ..., π − 1 calculate, replacing n + 1 → 1,
ci+1 = Hn(Tc, R, m, [riG + ciWi], [riHp(Ki,1) + ciW ̃ ])
6. Define rπ = α − cπwπ (mod l).
Therefore σ(m) = (c1, r1, ..., rn), with primary key image K ̃1, and auxiliary images (K ̃2, ..., K ̃m).
18 The paper this section is based on is a pre-print being finalized for external review. CLSAG is promising as a replacement for MLSAG in future protocol versions, but has not been implemented, and might not be in the future. 19 The CLSAG paper says to use different hash functions for domain separation, which we model by prefixing each hash with a tag [67], e.g. T1 = “CLSAG 1”, Tc = “CLSAG c”, etc. Domain separated hash functions have different outputs even with the same inputs. We also use key prefixing here (including R, which has all the keys, in the hash). Domain separating is a new policy for Monero development, and will likely be done with all applications of hash functions added in the future (v13+). Historical uses of hash functions will probably be left alone.


CHAPTER 3. ADVANCED SCHNORR-LIKE SIGNATURES 35
Verification
The verification of a signature is done in the following manner:
1. For all j ∈ {1, ..., m} check lK ̃j
?= 0.20
2. Calculate aggregate public keys Wi for i ∈ {1, 2, ..., n}, and aggregate key image W ̃
Wi =
m
∑
j=1
Hn(Tj, R, K ̃1, ..., K ̃m) ∗ Ki,j
W ̃ =
m
∑
j=1
Hn(Tj, R, K ̃1, ..., K ̃m) ∗ K ̃j
3. For i = 1, ..., n compute, replacing n + 1 → 1,
ci+1 = Hn(Tc, R, m, [riG + ciWi], [riHp(Ki,1) + ciW ̃ ])
4. If c1 = c′1 then the signature is valid.
Why it works
The biggest danger in concise signatures like this is key cancellation, where the key images reported
aren’t legitimate, yet still sum to a legitimate aggregate value. This is where the aggregation
coefficients Hn(Tj, R, K ̃1, ..., K ̃m) come into play, locking down each key to its expected value.
We leave tracing out the circular repercussions of faking a key image as an exercise to the reader
(perhaps start by imagining those coefficients don’t exist). Auxiliary key images are an artifact
of proving the primary image is legitimate, since the aggregate private key wπ, which contains all
the private keys, is applied to base point Hp(Kπ,1).
Linkability
If a private key kπ,1 is re-used to make any signature, the corresponding primary key image K ̃1
supplied in the signature will reveal it. Auxiliary key images are ignored, as they only exist to
facilitate the ‘Concise’ part of CLSAG.
Space requirements
We store (1+n) integers, have m key images, and use m ∗ n public keys.
20 In Monero we would only check l ∗ K ̃1
?= 0 for the primary key image. Auxiliary keys would be stored as (1/8) ∗ K ̃j, and during verification multiplied by 8 (recall Section 2.3.1), which is more efficient. The method discrepancy is an implementation choice, since linkable key images are very important and so shouldn’t be messed with aggressively, and the other method was employed in prior protocol versions.


CHAPTER 4
Monero Addresses
The ownership of digital currency stored in a blockchain is controlled by so-called ‘addresses’.
Addresses are sent money which only the address-holder can spend.1
More specifically, an address owns the ‘outputs’ from some transactions, which are like notes giving
the address-holder spending rights to an ‘amount’ of money. Such a note might say “Address C
now owns 5.3 XMR”.
To spend an owned output, the address-holder references it as the input to a new transaction.
This new transaction has outputs owned by other addresses (or by the sender’s address, if the
sender wants). A transaction’s total input amount equals its total output amount, and once spent
an owned output can’t be respent. Carol, who has Address C, could reference that old output in
a new transaction (e.g. “In this transaction I’d like to spend that old output.”) and add a note
saying “Address B now owns 5.3 XMR”.
An address’s balance is the sum of amounts contained in its unspent outputs.2
We discuss hiding the amount from observers in Chapter 5, the structure of transactions in Chapter
6 (which includes how to prove you are spending an owned and previously unspent output, without
even revealing which output is being spent), and the money creation process and role of observers
in Chapter 7.
1 Except with negligible probability. 2 Computer applications known as ‘wallets’ are used to find and organize the outputs owned by an address, to maintain custody of its private keys for authoring new transactions, and to submit those transactions to the network for verification and inclusion in the blockchain.
36


CHAPTER 4. MONERO ADDRESSES 37
4.1 User keys
Unlike Bitcoin, Monero users have two sets of private/public keys, (kv, Kv) and (ks, Ks), generated
as described in Section 2.3.2.
The address src/
common/
base58.cpp
encode
addr()
of a user is the pair of public keys (Kv, Ks). Her private keys will be the correspond
ing pair (kv, ks).3
Using two sets of keys allows function segregation. The rationale will become clear later in this
chapter, but for the moment let us call private key kv the view key, and ks the spend key. A person
can use their view key to determine if their address owns an output, and their spend key will allow
them to spend that output in a transaction (and retroactively figure out it has been spent).4
4.2 One-time addresses
To receive money, a Monero user may distribute their address to other users, who can then send
it money via transaction outputs.
The address is never used directly.5 Instead, a Diffie-Hellman-like exchange is applied to it, creating
a unique one-time address for each transaction output to be paid to the user. In this way, even
external observers who know all users’ addresses cannot use them to identify which user owns any
given transaction output.6
Let’s start with a very simple mock transaction, containing exactly one output — a payment of
‘0’ amount from Alice to Bob.
Bob has private/public keys (kv
B, ks
B) and (Kv
B, Ks
B), and Alice knows his public keys (his address).
The mock transaction could proceed as follows [136]:
1. Alice generates a random number r ∈R Zl, and calculates the one-time address7
3 To communicate an address to other users, it is extremely common to encode it in base-58, a binary-to-text encoding scheme first created for Bitcoin [28]. See [5] for more details. 4 It src/wallet/ api/wallet.cpp create() wallet2.cpp generate() get seed()
is currently most common for the view key kv to equal Hn(ks). This means a person only needs to save their spend key ks in order to access (view and spend) all of the outputs they own (spent and unspent). The spend key is typically represented as a series of 25 words (where the 25th word is a checksum). Other, less popular methods include: generating kv and ks as separate random numbers, or generating a random 12-word mnemonic a, where ks = sc reduce32(Keccak (a)) and kv = sc reduce32(Keccak (Keccak (a))). [5]
5 The method described here is not enforced by the protocol, just by wallet implementation standards. This means an alternate wallet could follow the style of Bitcoin where recipients’ addresses are included directly in transaction data. Such a non-compliant wallet would produce transaction outputs unusable by other wallets, and each Bitcoin-esque address could only be used once due to key image uniqueness. 6 Except with negligible probability. 7 In src/crypto/ crypto.cpp generate key derivation()
Monero, every instance (including when it’s used for other parts of the transaction) of rkvG is multiplied by the cofactor 8, so in this case Alice computes 8 ∗ rKv
B and Bob computes 8 ∗ kv
BrG. As far as we can tell this serves no purpose (but it is a rule that users must follow). Multiplying by the cofactor ensures the resulting point is in G’s subgroup, but if R and Kv don’t share a subgroup to begin with, then the discrete logs r and kv can’t be used to make a shared secret regardless.


CHAPTER 4. MONERO ADDRESSES 38
Ko = Hn(rKv
B)G + Ks
B src/crypto/
crypto.cpp
derive pu
blic key()
2. Alice sets Ko as the addressee of the payment, adds the output amount ‘0’ and the value
rG to the transaction data, and submits it to the network.
3. Bob src/crypto/
crypto.cpp
derive
subaddress
public
key()
receives the data and sees the values rG and Ko. He can calculate kv
BrG = rKv
B. He
can then calculate K′s
B = Ko − Hn(rKv
B)G. When he sees that K′s
B = Ks
B, he knows the
output is addressed to him.8
The private key kv
B is called the ‘view key’ because anyone who has it (and Bob’s public
spend key Ks
B) can calculate K′s
B for every transaction output in the blockchain (record of
transactions), and ‘view’ which ones belong to Bob.
4. The one-time keys for the output are:
Ko = Hn(rKv
B)G + Ks
B = (Hn(rKv
B) + ks
B )G
ko = Hn(rKv
B) + ks
B
To spend his ‘0’ amount output [sic] in a new transaction, all Bob needs to do is prove ownership
by signing a message with the one-time key Ko. The private key ks
B is the ‘spend key’ since it
is required for proving output ownership, while kv
B is the ‘view key’ since it can be used to find
outputs spendable by Bob.
As will become clear in Chapter 6, without ko Alice can’t compute the output’s key image, so she
can never know for sure if Bob spends the output she sent him.9
Bob may give a third party his view key. Such a third party could be a trusted custodian, an
auditor, a tax authority, etc. Somebody who could be allowed read access to the user’s trans
action history, without any further rights. This third party would also be able to decrypt the
output’s amount (to be explained in Section 5.3). See Chapter 8 for other ways Bob could provide
information about his transaction history.
4.2.1 Multi-output transactions
Most transactions will contain more than one output. If nothing else, to transfer ‘change’ back to
the sender.10,11
8 K′s
B is computed with derive subaddress public key() because normal address spend keys are stored at index 0 in the spend key lookup table, while subaddresses are at indices 1,2... This will make sense soon: see Section 4.3. 9 Imagine Alice produces two transactions, each containing the same one-time output address Ko that Bob can spend. Since Ko only depends on r and Kv
B, there is no reason she can’t do it. Bob can only spend one of those outputs because each one-time address only has one key image, so if he isn’t careful Alice might trick him. She could make transaction 1 with a lot of money for Bob, and later transaction 2 with a small amount for Bob. If he spends the money in 2, he can never spend the money in 1. In fact, no one could spend the money in 1, effectively ‘burning’ it. Monero wallets have been designed to ignore the smaller amount in this scenario. 10 Actually, as of protocol v12 two outputs are required from each (non-miner) transaction, even if it means one output has 0 amount (HF VERSION MIN 2 OUTPUTS). This improves transaction indistinguishability by mixing 1-output cases with the much more common 2-output transactions. Previous to v12 the core wallet software was already creating 0-value outputs. The core implementation sends 0-amount outputs to a random address. src/wallet/ wallet2.cpp transfer selected rct()
11 After Bulletproofs were implemented in protocol v8, each transaction became limited to no more than 16 outputs (BULLETPROOF MAX OUTPUTS). Previously there was no limit, aside from a restraint on transaction size (in


CHAPTER 4. MONERO ADDRESSES 39
Monero senders usually generate only one random value r. The curve point rG is typically known
as the transaction public key and is published alongside other transaction data in the blockchain.
To
src/crypto
note core/
cryptonote
tx utils.cpp
construct
tx with
tx key()
ensure that all one-time addresses in a transaction with p outputs are different even in cases
where the same addressee is used twice, Monero uses an output index. Every output from a
transaction has an index t ∈ {0, ..., p − 1}. By appending this value to the shared secret before
hashing it, one can ensure the resulting one-time addresses are unique:
src/crypto/
crypto.cpp
derive pu
blic key()
Ko
t = Hn(rKv
t , t)G + Ks
t = (Hn(rKv
t , t) + ks
t )G
ko
t = Hn(rKv
t , t) + ks
t
4.3 Subaddresses
Monero users can generate subaddresses from each address [105]. Funds sent to a subaddress can
be viewed and spent using its main address’s view and spend keys. By analogy: an online bank
account may have multiple balances corresponding to credit cards and deposits, yet they are all
accessible and spendable from the same point of view – the account holder.
Subaddresses are convenient for receiving funds to the same place when a user doesn’t want to link
his activities together by publishing/using the same address. As we will see, most observers would
have to solve the DLP to determine a given subaddress is derived from any particular address
[105].12
They are also useful for differentiating between received outputs. For example, if Alice wants to
buy an apple from Bob on a Tuesday, Bob could write a receipt describing the purchase and make
a subaddress for that receipt, then ask Alice to use that subaddress when she sends him the money.
This way Bob can associate the money he receives with the apple he sold. We explore another
way to distinguish between received outputs in the next section.
Bob src/device/
device de
fault.cpp
get sub
address
secret
key()
generates his ith subaddress (i = 1, 2, ...) from his address as a pair of public keys (Kv,i, Ks,i):13
Ks,i = Ks + Hn(kv, i)G
Kv,i = kvKs,i
So,
Kv,i = kv(ks + Hn(kv, i))G
Ks,i = (ks + Hn(kv, i))G
bytes). 12 Prior to subaddresses (added in the software update corresponding with protocol v7 [76]), Monero users could simply generate many normal addresses. To view each address’s balance, you needed to do a separate scan of the blockchain record. This was very inefficient. With subaddresses, users maintain a look-up table of (hashed) spend keys, so one scan of the blockchain takes the same amount of time for 1 subaddress, or 10,000 subaddresses. 13 It turns out the subaddress hash is domain separated, so it’s really Hn(Tsub, kv, i) where Tsub =“SubAddr”. We omit Tsub throughout this document for brevity.


CHAPTER 4. MONERO ADDRESSES 40
4.3.1 Sending to a subaddress
Let’s say Alice is going to send Bob ‘0’ amount again, this time via his subaddress (Kv,1
B , Ks,1
B ).
1. Alice generates a random number r ∈R Zl, and calculates the one-time address
Ko = Hn(rKv,1
B , 0)G + Ks,1
B
2. Alice sets Ko as the addressee of the payment, adds the output amount ‘0’ and the value
rK s,1
B to the transaction data, and submits it to the network.
3. Bob src/crypto/
crypto.cpp
derive
subaddress
public
key()
receives the data and sees the values rKs,1
B and Ko. He can calculate kv
B rK s,1
B = rKv,1
B. He can then calculate K′s
B = Ko − Hn(rKv,1
B , 0)G. When he sees that K′s
B = Ks,1
B , he knows
the transaction is addressed to him.14
Bob only needs his private view key kv
B and subaddress public spend key Ks,1
B to find trans
action outputs sent to his subaddress.
4. The one-time keys for the output are:
Ko = Hn(rKv,1
B , 0)G + Ks,1
B = (Hn(rKv,1
B , 0) + ks,1
B )G
ko = Hn(rKv,1
B , 0) + ks,1
B
Now, src/crypto
note core/
cryptonote
tx utils.cpp
construct
tx with
tx key()
Alice’s transaction public key is particular to Bob (rKs,1
B instead of rG). If she creates a
p-output transaction with at least one output intended for a subaddress, Alice needs to make a
unique transaction public key for each output t ∈ {0, ..., p − 1}. In other words, if Alice is sending
to Bob’s subaddress (Kv,1
B , Ks,1
B ) and Carol’s address (Kv
C, Ks
C), she will put two transaction public
keys {r1Ks,1
B , r2G} in the transaction data.15,16
14 An advanced attacker may be able to link subaddresses [56] (a.k.a. the Janus attack). With subaddresses (one of which can be a normal address) K1
B & K2
B the attacker thinks may be related, he makes a transaction output
with Ko = Hn(rKv,2
B , 0)G + Ks,1
B and includes transaction public key rKs,2
B . Bob calculates rKv,2
B to find K′s,1
B
but has no way of knowing it was his other (sub)address’s key used! If he tells the attacker that he received funds to K1
B, the attacker will know K2
B is a related subaddress (or normal address). Since subaddresses are outside the protocol’s scope, mitigations are up to wallet implementers. No known wallets have done so, and any mitigation would only work for compliant wallets. Potential mitigations include: not informing attackers of received funds, including encrypted transaction private key r in transaction data, a Schnorr signature on the shared secret using Ks,1 as the base point instead of G, and including rG in transaction data and verifying the shared secret with
rKs,1 ?= (ks + Hn(kv, 1)) ∗ rG (requires the private spend key). Outputs received by a normal address should also be verified. See [101] for a discussion of the last mitigation listed. 15 In src/cryptonote basic/ cryptonote basic impl.cpp get account address as str()
Monero subaddresses are prefixed with an ‘8’, separating them from addresses, which are prefixed with ‘4’. This helps senders choose the correct procedure when constructing transactions. 16 There is some intricacy to when additional transaction public keys are used (see the code path transfer selected rct() → construct tx and get tx key() → construct tx with tx key() → generate output ephemeral keys() and classify addresses()) surrounding change outputs where the transaction author knows the recipient’s view key (since it’s himself; also the case for dummy change outputs, which are created when a 0-amount output is necessary, since authors generate those addresses). Whenever there are at least two non-change outputs, and at least one of their recipients is a subaddress, proceed in the normal way explained above (a current bug in the core implementation adds an extra transaction public key to transaction data even beyond the additional keys, which is not used for anything). If either just the change output is to a subaddress, or


CHAPTER 4. MONERO ADDRESSES 41
4.4 Integrated addresses
To differentiate between the outputs they receive, a recipient can request senders include a payment
ID in transaction data.17 For example, if Alice wants to buy an apple from Bob on a Tuesday,
Bob could write a receipt describing the purchase and ask Alice to include the receipt’s ID number
when she sends him the money. This way Bob can associate the money he receives with the apple
he sold.
At one point senders could communicate payment IDs in clear text, but manually including the
IDs in transactions is inconvenient, and cleartext is a privacy hazard for recipients, who might
inadvertently expose their activities.18 In src/crypto
note basic/
cryptonote
basic
impl.cpp
get
account
integrated
address as
str()
Monero, recipients can integrate payment IDs into their
addresses, and provide those integrated addresses, containing (Kv, Ks, payment ID), to senders.
Payment IDs can technically be integrated into any kind of address, including normal addresses,
subaddresses, and multisignature addresses.19
Senders addressing outputs to integrated addresses can encode payment IDs using the shared
secret rKtv and an XOR operation (recall Section 2.5), which recipients can then decode with the
appropriate transaction public key and another XOR operation [9]. Encoding payment IDs in
this way also allows senders to prove they made particular transaction outputs (e.g. for audits,
refunds, etc.).20
Encoding
The src/device/
device de
fault.cpp
encrypt
payment
id()
sender encodes the payment ID for inclusion in transaction data21
kmask = Hn(rKv
t , pid tag)
kpayment ID = kmask → reduced to bit length of payment ID
encoded payment ID = XOR(kpayment ID, payment ID)
there is just one non-change output and it’s to a subaddress, then only one transaction public key is created. In the former case, the transaction public key is rG and the change’s one-time key is (subaddress index 1, using c subscript to denote the change’s keys) Ko = Hn(kv
c rG, t)G + Ks,1
c using the normal view key and subaddress’s spend key. In the latter case the transaction public key rKv,1 is based off the subaddress’s view key, and the change’s one time key is Ko = Hn(kv
c ∗ rKv,1, t)G + Ks
c . These details help mingle a portion of subaddress transactions amongst the more common normal address transactions, and 2-output transactions which compose around 95% of transaction volume as of this writing. 17 Currently, Monero implementations only support one payment ID per transaction regardless of how many outputs it has. 18 These long-form (256 bit) cleartext payment IDs were deprecated in v0.15 of the core software implementation (coincident with protocol v12 in November 2019). While other wallets may still support them and allow their inclusion in transaction data, the core wallet will ignore them. 19 Within the authors’ knowledge, integrated addresses have only ever been implemented for normal addresses. 20 Since an observer can recognize the difference between transactions with and without payment IDs, using them is thought to make the Monero transaction history less uniform. Because of this, since protocol v10 the core implementation adds a dummy src/cryptonote core/ cryptonote tx utils.cpp construct tx with tx key()
encrypted payment ID to all 2-output transactions. Decoding one will reveal all 0s (this is not required by the protocol, just best practice). 21 In Monero payment IDs for integrated addresses are conventionally 64 bits long.


CHAPTER 4. MONERO ADDRESSES 42
We include pid tag to ensure kmask is different from the component Hn(rKtv, t) in one-time output
addresses.22
Decoding
Whichever src/device/
device.hpp
decrypt
payment
id()
recipient the payment ID was created for can find it using his view key and the trans
action public key rG:23
kmask = Hn(kv
t rG, pid tag)
kpayment ID = kmask → reduced to bit length of payment ID
payment ID = XOR(kpayment ID, encoded payment ID)
Similarly, senders can decode payment IDs they had previously encoded by recalculating the shared
secret.
4.5 Multisignature addresses
Sometimes it is useful to share ownership of funds between different people/addresses. We dedicate
Chapter 9 to elaborating this topic.
22 In Monero, pid tag = ENCRYPTED PAYMENT ID TAIL = 141. In, for example, multi-input transactions we compute Hn (rK v
t , t) (mod l) to ensure we are using a scalar less than the EC subgroup order, but since l is 253 bits and payment IDs are only 64 bits, taking the modulus for encoding payment IDs would be meaningless, so we don’t. 23 Transaction data does not indicate which output a payment ID ‘belongs’ to. Recipients have to identify their own payment IDs.


CHAPTER 5
Monero Amount Hiding
In most cryptocurrencies like Bitcoin, transaction output notes, which give spending rights to
‘amounts’ of money, communicate those amounts in clear text. This allows observers to easily
verify the amount spent equals the amount sent.
In Monero we use commitments to hide output amounts from everyone except senders and receivers,
while still giving observers confidence that a transaction sends no more or less than what is spent.
As we will see, amount commitments must also have corresponding ‘range proofs’ which prove the
hidden amount is within a legitimate range.
5.1 Commitments
Generally speaking, a cryptographic commitment scheme is a way of committing to a value without
revealing the value itself. After committing to something, you are stuck with it.
For example, in a coin-flipping game Alice could privately commit to one outcome (i.e. ‘call it’)
by hashing her committed value with secret data and publishing the hash. After Bob flips the
coin, Alice declares which value she committed to and proves it by revealing the secret data. Bob
could then verify her claim.
In other words, assume that Alice has a secret string blah and the value she wants to commit to
is heads. She hashes h = H(blah, heads) and gives h to Bob. Bob flips a coin, then Alice tells
Bob the secret string blah and that she committed to heads. Bob calculates h′ = H(blah, heads).
If h′ = h, then he knows Alice called heads before the coin flip.
43


CHAPTER 5. MONERO AMOUNT HIDING 44
Alice uses the so-called ‘salt’, blah, so Bob can’t just guess H(heads) and H(tails) before his coin
flip, and figure out she committed to heads.1
5.2 Pedersen commitments
A Pedersen commitment [113] is a commitment that has the property of being additively ho
momorphic. If C(a) and C(b) denote the commitments for values a and b respectively, then
C(a + b) = C(a) + C(b).2 This property will be useful when committing transaction amounts, as
one can prove, for instance, that inputs equal outputs, without revealing the amounts at hand.
Fortunately, Pedersen commitments are easy to implement with elliptic curve cryptography, as
the following holds trivially
aG + bG = (a + b)G
Clearly, by defining a commitment as simply C(a) = aG, we could easily create cheat tables of
commitments to help us recognize common values of a.
To attain information-theoretic privacy, one needs to add a secret blinding factor and another
generator H, such that it is unknown for which value of γ the following holds: H = γG. The
hardness of the discrete logarithm problem ensures calculating γ from H is infeasible.3
We can then define the commitment to a value a as C(x, a) = xG + aH, where x is the blinding
factor (a.k.a. ‘mask’) that prevents observers from guessing a.
Commitment C(x, a) is information-theoretically private because there are many possible combi
nations of x and a that would output the same C.4 If x is truly random, an attacker would have
literally no way to figure out a [88, 122].
5.3 Amount commitments
In Monero, output amounts are stored in transactions as Pedersen commitments. We define a
commitment to an output’s amount b as:
1 If the committed value is very difficult to guess and check, e.g. if it’s an apparently random elliptic curve point, then salting the commitment isn’t necessary. 2 Additively homomorphic in this context means addition is preserved when you transform scalars into EC points by applying, for scalar x, x → xG. 3 In the case of Monero src/ringct/ rctTypes.h
, H = 8 ∗ to point(Hn(G)). This differs from the Hp hash function in that it directly interprets the output of Hn(G) as a compressed point coordinate instead of deriving a curve point mathematically (see [107]). The historical reasons for this discrepancy tests/unit tests/ ringct.cpp
TEST(ringct, HPow2)
are unknown to us, and indeed this is the only place where Hp is not used (Bulletproofs also use Hp). Note how there is a ∗8 operation, to ensure the resultant point is in our l subgroup (Hp also does that). 4 Basically, there are many x′ and a′ such that x′ + a′γ = x + aγ. A committer knows one combination, but an attacker has no way to know which one. This property is also known as ‘perfect hiding’ [138]. Furthermore, even the committer can’t find another combination without solving the DLP for γ, a property called ‘computational binding’ [138].


CHAPTER 5. MONERO AMOUNT HIDING 45
C(y, b) = yG + bH src/ringct/
rctOps.cpp
addKeys2()
Recipients should be able to know how much money is in each output they own, as well as
reconstruct the amount commitments, so they can be used as the inputs to new transactions.
This means the blinding factor y and amount b must be communicated to the receiver.
The solution adopted is a Diffie-Hellman shared secret rKv
B using the ‘transaction public key’
(recall Section 4.2.1). For any given transaction in the blockchain, each of its outputs t ∈ {0, ..., p−
1} has a mask yt that senders and receivers can privately compute, and an amount stored in the
transaction’s data. While yt is an elliptic curve scalar and occupies 32 bytes, b will be restricted
to 8 bytes by the range proof so only an 8 byte value needs to be stored.5,6
src/ringct/
rctOps.cpp
ecdh
Encode()
yt = Hn(“commitment mask”, Hn(rKv
B, t))
amount t = bt ⊕8 Hn(“amount”, Hn(rKv
B, t))
Here, ⊕8 means to perform an XOR operation (Section 2.5) between the first 8 bytes of each
operand (bt which is already 8 bytes, and Hn(...) which is 32 bytes). Recipients can perform the
same XOR operation on amountt to reveal bt.
The receiver Bob will be able to calculate the blinding factor yt and the amount bt using the
transaction public key rG and his view key kv
B. He can also check that the commitment C(yt, bt)
provided in the transaction data, henceforth denoted Ctb, corresponds to the amount at hand.
More generally, any third party with access to Bob’s view key could decrypt his output amounts,
and also make sure they agree with their associated commitments.
5.4 RingCT introduction
A transaction will contain references to other transactions’ outputs (telling observers which old
outputs are to be spent), and its own outputs. The content of an output includes a one-time
address (assigning ownership of the output) and an output commitment hiding the amount (also
the encoded output amount from Section 5.3).
While a transaction’s verifiers don’t know how much money is contained in each input and output,
they still need to be sure the sum of input amounts equals the sum of output amounts. Monero
uses a technique called RingCT [108], first implemented in January 2017 (v4 of the protocol), to
accomplish this.
5 As src/cryptonote core/ cryptonote tx utils.cpp construct tx with tx key() calls generate output ephemeral keys()
with the one-time address Ko from Section 4.2, the output index t is appended to the shared secret before hashing. This ensures outputs directed to the same address do not have similar masks and amounts, except with negligible probability. Also like before, the term rKv
B is multiplied by 8, so it’s really 8rKv
B.
6 This solution (implemented in v10 of the protocol) replaced a previous method that used more data, thereby causing the transaction type to change from v3 (RCTTypeBulletproof) to v4 (RCTTypeBulletproof2). The first edition of this report discussed the previous method [33].


CHAPTER 5. MONERO AMOUNT HIDING 46
If we have a transaction with m inputs containing amounts a1, ..., am, and p outputs with amounts
b0, ..., bp−1, then an observer would justifiably expect that:7
∑
j
aj −
∑
t
bt = 0
Since commitments are additive and we don’t know γ, we could easily prove our inputs equal
outputs to observers by making the sum of commitments to input and output amounts equal zero
(i.e. by setting the sum of output blinding factors equal to the sum of old input blinding factors):8
∑
j
Cj,in −
∑
t
Ct,out = 0
To avoid sender identifiability we use a slightly different approach. The amounts being spent
correspond to the outputs of previous transactions, which had commitments
Ca
j = xjG + ajH
The sender can create new commitments to the same amounts but using different blinding factors;
that is,
C ′a
j = x′
jG + ajH
Clearly, she would know the private key of the difference between the two commitments:
Ca
j − C′a
j = (xj − x′
j )G
Hence, she would be able to use this value as a commitment to zero, since she can make a signature
with the private key (xj − x′
j) = zj and prove there is no H component to the sum (assuming γ is
unknown). In other words prove that Ca
j − C′a
j = zjG + 0H, which we will actually do in Chapter
6 when we discuss the structure of RingCT transactions.
Let us call C′a
j a pseudo output commitment. Pseudo output commitments are included in trans
action data, and there is one for each input.
Before committing a transaction to the blockchain, the network will want to verify that its amounts
balance. Blinding factors for pseudo and output commitments are selected such that
∑
j
x′
j−
∑
t
yt = 0
This src/ringct/
rctSigs.cpp
verRct
Semantics
Simple()
allows us to prove input amounts equal output amounts:
(
∑
j
C ′a
j−
∑
t
Cb
t) = 0
Fortunately, choosing such blinding factors is easy. In the current version of Monero, all blinding
7 If the intended total output amount doesn’t precisely equal any combination of owned outputs, then transaction authors can add a ‘change’ output sending extra money back to themselves. By analogy to cash, with a 20$ bill and 15$ expense you will receive 5$ back from the cashier. 8 Recall from Section 2.3.1 we can subtract a point by inverting its coordinates then adding it. If P = (x, y), −P = (−x, y). Recall also that negations of field elements are calculated (mod q), so (–x (mod q)).


CHAPTER 5. MONERO AMOUNT HIDING 47
factors are random except for the mth pseudo out commitment, where x′m is simply genRct
Simple()
x′
m=
∑
t
yt −
m−1
∑
j=1
x′
j
5.5 Range proofs
One problem with additive commitments is that, if we have commitments C(a1), C(a2), C(b1), and
C(b2) and we intend to use them to prove that (a1 + a2) − (b1 + b2) = 0, then those commitments
would still apply if one value in the equation were ‘negative’.
For instance, we could have a1 = 6, a2 = 5, b1 = 21, and b2 = −10.
(6 + 5) − (21 + −10) = 0
where
21G + −10G = 21G + (l − 10)G = (l + 11)G = 11G
Since −10 = l − 10, we have effectively created l more Moneroj (over 7.2x1074!) than we put in.
The solution addressing this issue in Monero is to prove each output amount is in a certain range
(from 0 to 264 − 1) using the Bulletproofs proving scheme first described by Benedikt Bu ̈nz et al.
in [43] (and also explained in [138, 50]).9 Given the involved and intricate nature of Bulletproofs,
it is not elucidated in this document. Moreover we feel the cited materials adequately present its
concepts.10
The Bulletproof proving algorithm src/ringct/
rctSigs.cpp
proveRange
Bullet
proof()
takes as input output amounts bt and commitment masks yt,
and outputs all Ctb and an n-tuple aggregate proof ΠBP = (A, S, T1, T2, τx, μ, L, R, a, b, t)11,12. That
single proof is used to prove all output amounts are in range at the same time, as aggregating
them greatly reduces space requirements (although it does increase the time to verify).13 The
verification algorithm takes as input all Ctb, and ΠBP , and outputs true if all committed amounts
are in the range 0 to 264 − 1.
The n-tuple ΠBP occupies (2 · dlog2(64 · p)e + 9) · 32 bytes of storage.
9 It’s conceivable that with several outputs in a legitimate range, the sum of their amounts could roll over and cause a similar problem. However, when the maximum output is much smaller than l it takes a huge number of outputs for that to happen. For example, if the range is 0-5, and l = 99, then to counterfeit money using an input of 2, we would need 5 + 5 + . . . . + 5 + 1 = 101 ≡ 2 (mod 99), for 21 total outputs. In Monero l is about 2ˆ189 times bigger than the available range, which means a ridiculous 2ˆ189 outputs to counterfeit money. 10 Prior to protocol v8 range proofs were accomplished with Borromean ring signatures, which were explained in the first edition of Zero to Monero [33]. 11 Vectors L and R contain dlog2(64 · p)e elements each. d e means the log function is rounded up. Due to their construction, some Bulletproofs use ‘dummy outputs’ as padding to ensure p plus the number of dummy outputs is a power of 2. Those dummy outputs can be generated during verification, and are not stored with the proof data. 12 The variables in a Bulletproof are unrelated to other variables in this document. Symbol overlap is merely coincidental. Note that group elements A, S, T1, T2, L, and R are multiplied by 1/8 before being stored, then multiplied by 8 during verification. This ensures they are all members of the l sub-group (recall Section 2.3.1). 13 It turns out multiple separate Bulletproofs can be ‘batched’ rct/ringct/ bulletproofs.cc bulletproof VERIFY()
together, which means they are verified simultaneously. Doing so improves how long it takes to verify them, and currently in Monero Bulletproofs are batched on a per-block basis, although there is no theoretical limit to how many can be batched together. Each transaction is only allowed to have one Bulletproof.


CHAPTER 6
Monero Ring Confidential Transactions (RingCT)
Throughout Chapters 4 and 5 we built up several aspects of Monero transactions. At this point a
simple one-input, one-output transaction from some unknown author to some unknown recipient
sounds like:
“My transaction uses transaction public key rG. I will spend old output X (note that it has a
hidden amount AX , committed to in CX ). I will give it a pseudo output commitment C′
X . I will
make one output Y , which may be spent by the one-time address Ko
Y . It has a hidden amount AY
committed to in CY , encrypted for the recipient, and proven in range with a Bulletproofs-style
range proof. Please note that C′
X − CY = 0.”
Some questions remain. Did the author actually own X? Does the pseudo output commitment C′
X actually correspond to CX , such that AX = A′
X = AY ? Has someone tampered with the
transaction, and perhaps directed the output at a recipient unintended by the original author?
As mentioned in Section 4.2, we can prove ownership of an output by signing a message with its
one-time address (whoever has the address’s key owns the output). We can also prove it has the
same amount as a pseudo output commitment by proving knowledge of the commitment to zero’s
private key (CX − C′
X = zX G). Moreover, if that message is all the transaction data (except the
signature itself), then verifiers can be assured everything is as the author intended (the signature
only works with the original message). MLSAG signatures allow us to do all of this while also
obscuring the actual spent output amongst other outputs from the blockchain, so observers can’t
be sure which one is being spent.
48


CHAPTER 6. MONERO RING CONFIDENTIAL TRANSACTIONS (RINGCT) 49
6.1 Transaction types
Monero src/crypto
note core/
cryptonote
tx utils.cpp
construct
tx with
tx key()
is a cryptocurrency under steady development. Transaction structures, protocols, and
cryptographic schemes are always prone to evolving as new innovations, objectives, or threats are
found.
In this report we have focused our attention on Ring Confidential Transactions, a.k.a. RingCT, as
they are implemented in the current version of Monero. RingCT is mandatory for all new Monero
transactions, so we will not describe any deprecated transaction schemes, even if they are still
partially supported.1 The transaction type we have discussed so far, and which will be further
elaborated in this chapter, is RCTTypeBulletproof2.2
We present a conceptual summary of transactions in Section 6.3.
6.2 Ring Confidential Transactions of type RCTTypeBulletproof2
Currently (protocol v12) all new transactions must use this transaction type, in which each input
is signed separately. An actual example of an RCTTypeBulletproof2 transaction, with all its
components, can be inspected in Appendix A.
6.2.1 Amount commitments and transaction fees
Assume a transaction sender has previously received various outputs with amounts a1, ..., am
addressed to one-time addresses Kπo,1, ..., Kπo,m and with amount commitments Cπa,1, ..., Cπa,m.
This sender knows the private keys koπ,1, ..., koπ,m corresponding to the one-time addresses (Section
4.2). The sender also knows the blinding factors xj used in commitments Ca
π,j (Section 5.3).
Typically transaction outputs are lower in total than transaction inputs, in order to provide a fee
that will incentivize miners to include the transaction in the blockchain.3 Transaction fee amounts
f are stored in clear text in the transaction data transmitted to the network. Miners can create
an additional output for themselves with the fee (see Section 7.3.6).
1 RingCT was first implemented in January 2017 (v4 of the protocol). It was made mandatory for all new transactions in September 2017 (v6 of the protocol) [16]. RingCT is version 2 of Monero’s transaction protocol. 2 Within the RingCT era there are three deprecated transaction types: RCTTypeFull, RCTTypeSimple, and RCTTypeBulletproof. The former two coexisted in the first iteration of RingCT and are explored in the first edition of this report [33], then with the advent of Bulletproofs (protocol v8) RCTTypeFull was deprecated, and RCTTypeSimple was upgraded to RCTTypeBulletproof. RCTTypeBulletproof2 arrived due to a minor improvement in encrypting output commitments’ masks and amounts (v10). 3 In Monero there is a minimum base fee that scales with transaction weight. It is semi-mandatory because while you can create new blocks containing tiny-fee transactions, most Monero nodes won’t relay such transactions to other nodes. The result is few if any miners will try to include them in blocks. Transaction authors can provide miner fees above the minimum if they want. We go into more detail on this in Section 7.3.4.


CHAPTER 6. MONERO RING CONFIDENTIAL TRANSACTIONS (RINGCT) 50
A transaction consists of inputs a1, ..., am and outputs b0, ..., bp−1 such that
m
∑
j=1
aj −
p−1
∑
t=0
bt − f = 0.4
The sender calculates pseudo output commitments for the input amounts, C′πa,1, ..., C′πa,m, and
creates commitments for intended output amounts b0, ..., bp−1. Let these new commitments be
C0b, ..., Cpb−1.
He knows the private keys z1, ..., zm to the commitments to zero (Cπa,1 − C′πa,1), ..., (Cπa,m − C′πa,m).
For verifiers to confirm transaction amounts sum to zero, the fee amount must be converted into a
commitment. The solution is to calculate the commitment of the fee f without the masking effect
of any blinding factor. That is, C(f ) = f H.
Now src/ringct/
rctSigs.cpp
verRct
Semantics
Simple()
we can prove input amounts equal output amounts:
(
∑
j
C ′a
j−
∑
t
Cb
t) − fH = 0
6.2.2 Signature
The sender selects m sets of size v, of additional unrelated one-time addresses and their commit
ments from the blockchain, corresponding to apparently unspent outputs.5,6 To sign input j, she
stirs a set of size v into a ring with her own jth unspent one-time address (placed at unique index
π), along with false commitments to zero, as follows:7
Rj = {{Ko
1,j , (C1,j − C′a
π,j )},
...
{K o
π,j , (Ca
π,j − C′a
π,j )},
...
{K o
v+1,j , (Cv+1,j − C′a
π,j )}}
4 Outputs
src/cryptonote core/ cryptonote tx utils.cpp construct tx with tx key()
are randomly shuffled by the core implementation before getting assigned an index, so observers can’t build heuristics around their order. Inputs are sorted by key image within transaction data. 5 In Monero it is standard for the sets src/wallet/ wallet2.cpp get outs()
of ‘additional unrelated addresses’ to be selected from a gamma
gamma picker ::pick()
distribution across the range of historical outputs (RingCT outputs only, a triangle distribution is used for pre-RingCT outputs). This method uses a binning procedure to smooth out differences in block densities. First calculate the average time between transaction outputs over up to a year ago of RingCT outputs (avg time = [#outputs/#blocks]*blocktime). Select an output via the gamma distribution, then look inside its block and grab a random output to be a member of the set. [93] 6 As of protocol v12, all transaction inputs must be at least 10 blocks old (CRYPTONOTE DEFAULT TX SPENDABLE AGE). Prior to v12 the core implementation used 10 blocks by default, but it was not required so an alternate wallet could make different choices, and some apparently did [82]. 7 In Monero each of a transaction’s rings must have the same size, and the protocol controls how many ring members there can be per output-to-be-spent. It has changed with different protocol versions: v2 March 2016 ≥ 3, v6 Sept. 2017 ≥ 5, v7 April 2018 ≥ 7, v8 Oct. 2018 11-only. Since src/cryptonote core/ cryptonote core.cpp check tx inputs ring members diff()
v6 each individual ring can not contain duplicate members, though there may be duplicates between rings to allow multiple inputs when there are insufficient total outputs in the transaction history (i.e. to assemble rings without cross-over) [135].


CHAPTER 6. MONERO RING CONFIDENTIAL TRANSACTIONS (RINGCT) 51
Alice src/ringct/
rctSigs.cpp
proveRct
MGSimple()
uses an MLSAG signature (Section 3.5) to sign this ring, where she knows the private keys ko
π,j for Ko
π,j, and zj for the commitment to zero (Ca
π,j - C′a
π,j). Since no key image is needed for
the commitments to zero, there is consequently no corresponding key image component in the
signature’s construction.8
Each input in a transaction is signed individually using rings like Rj as defined above, thereby
obscuring the real outputs being spent, (Kπo,1, ..., Kπo,m), amongst other unspent outputs.9 Since
part of each ring includes a commitment to zero, the pseudo output commitment used must contain
an amount equal to the real input being spent. This ties input amounts to the proof that amounts
balance, without compromising which ring member is the real input.
The message m signed by each input is essentially a hash of all transaction data except for the
MLSAG signatures.10 This ensures transactions are tamper-proof from the perspective of both
transaction authors and verifiers. Only one message is produced, and each input MLSAG signs it.
One-time private key ko is the essence of Monero’s transaction model. Signing m with ko proves
you are the owner of the amount committed to in Ca. Verifiers can be confident that transaction
authors are spending their own funds, without even knowing which funds are being spent, how
much is being spent, or what other funds they might own!
6.2.3 Avoiding double-spending
An src/crypto
note core/
block
chain.cpp
have tx
keyimges
as spent()
MLSAG signature (Section 3.5) contains images K ̃j of private keys kπ,j. An important prop
erty for any cryptographic signature scheme is that it should be unforgeable with non-negligible
probability. Therefore, to all practical effects, we can assume a signature’s key images must have
been deterministically produced from legitimate private keys.
The network only needs to verify that key images included with MLSAG signatures (corresponding
to inputs and calculated as K ̃ o
j = ko
π,j Hp(Ko
π,j)) have not appeared before in other transactions.11
If they have, then we can be sure we are witnessing an attempt to re-spend an output (Ca
π,j , Ko
π,j ).
8 Building and verifying the signature excludes the term ri,2Hp(Ci,j − C′a
π,j ) + ciK ̃ zj .
9 The advantage of signing inputs individually is that the set of real inputs and commitments to zero need not be placed at the same index π, as they would be in the aggregated case. This means even if one input’s origin becomes identifiable, the other inputs’ origins would not. The old transaction type RCTTypeFull used aggregated ring signatures, combining all rings into one, and as we understand it was deprecated for that reason. 10 The src/ringct/ rctSigs.cpp get pre mlsag hash()
actual message is m = H(H(tx pref ix), H(ss), H(range proofs)) where: tx pref ix ={transaction era version (i.e. RingCT = 2), inputs {ring member key offsets, key images}, outputs {one-time addresses}, extra {transaction public key, payment ID or encoded payment ID, misc.}} ss ={transaction type (RCTTypeBulletproof2 = ‘4’), transaction fee, pseudo output commitments for inputs, ecdhInfo (encrypted amounts), output commitments}. See Appendix A regarding this terminology. 11 Verifiers must also check the key image is a member of the generator’s subgroup (recall Section 3.4).


CHAPTER 6. MONERO RING CONFIDENTIAL TRANSACTIONS (RINGCT) 52
6.2.4 Space requirements
MLSAG signature (inputs)
From Section 3.5 we recall that an MLSAG signature in this context would be expressed as
σj(m) = (c1, r1,1, r1,2, ..., rv+1,1, rv+1,2) with K ̃ o
j
As a legacy of CryptoNote, the values K ̃ o
j are not referred to as part of the signature, but rather as
images of the private keys ko
π,j. These key images are normally stored separately in the transaction
structure, as they are used to detect double-spending attacks.
With this in mind and assuming point compression (Section 2.4.2), since each ring Rj contains
(v + 1) · 2 keys, an input signature σj will require (2(v + 1) + 1) · 32 bytes. On top of this, the key
image K ̃ o
π,j and the pseudo output commitment C′a
π,j leave a total of (2(v + 1) + 3) · 32 bytes per
input.
To this value we would need additional space to store the ring member offsets in the blockchain (see
Appendix A). These offsets are used by verifiers to find each MLSAG signature’s ring members’
output keys and commitments in the blockchain, and are stored as variable length integers, hence
we can not exactly quantify the space needed.12,13,14
Verifying
src/ringct/
rctSigs.cpp
verRctMG
Simple()
verRct
Semantics
Simple()
all of an RCTTypeBulletproof2 transaction’s MLSAGs includes the computation of
(Ci,j − C′a
π,j) and (∑
j C′a
j
?= ∑
t Ctb + f H), and verifying key images are in G’s subgroup with
lK ̃ ?= 0.
Range proofs (outputs)
An src/ringct/
bullet
proofs.cpp
bullet
proof
VERIFY()
aggregate Bulletproof range proof will require (2 · dlog2(64 · p)e + 9) · 32 total bytes.
12 See [66] or [24] for an explanation of Monero’s varint data type src/common/ varint.h
. It is an integer type that uses up to 9 bytes, and stores up to 63 bits of information. 13 Imagine src/cryptonote basic/ cryptonote format utils.cpp
absolute output offsets to relative()
the blockchain contains a long list of transaction outputs. We report the indices of outputs we want to use in rings. Now, bigger indexes require more storage space. We just need the ‘absolute’ position of one index from each ring, and the ‘relative’ positions of the other ring members’ indices. For example, with real indices {7,11,15,20} we just need to report {7,4,4,5}. Verifiers can compute the last index with (7+4+4+5 = 20). Ring members are organized in ascending order of blockchain index within rings. 14 A transaction with 10 inputs using rings with 11 total members will need ((11 · 2 + 3) · 32) · 10 = 8000 bytes for its inputs, with around 110 to 330 bytes for the offsets (there are 110 ring members).


CHAPTER 6. MONERO RING CONFIDENTIAL TRANSACTIONS (RINGCT) 53
6.3 Concept summary: Monero transactions
To summarize this chapter, and the previous two chapters, we present the main content of a
transaction, organized for conceptual clarity. A real example can be found in Appendix A.
• Type: ‘0’ is RCTTypeNull (for miners), ‘4’ is RCTTypeBulletproof2
• Inputs: for each input j ∈ {1, ..., m} spent by the transaction author
– Ring member offsets: a list of ‘offsets’ indicating where a verifier can find input j’s
ring members i ∈ {1, ..., v + 1} in the blockchain (includes the real input)
– MLSAG Signature: σj terms c1, and ri,1 & ri,2 for i ∈ {1, ..., v + 1}
– Key image: the key image K ̃ o,a
j for input j
– Pseudo output commitment: C′a
j for input j
• Outputs: for each output t ∈ {0, ..., p − 1} to address or subaddress (Ktv, Kts)
– One-time address: Ko,b
t for output t
– Output commitment: Ctb for output t
– Encoded amount: so output owners can compute bt for output t
∗ Amount: bt ⊕8 Hn(“amount”, Hn(rKv
B, t))
– Range proof : an aggregate Bulletproof for all output amounts bt
∗ Proof : ΠBP = (A, S, T1, T2, τx, μ, L, R, a, b, t)
• Transaction fee: communicated in clear text multiplied by 1012 (i.e. atomic units, see Section
7.3.1), so a fee of 1.0 would be recorded as 1000000000000
• Extra: includes the transaction public key rG, or, if at least one output is directed to a
subaddress, rtKs,i
t for each subaddress’d output t and rtG for each normal address’d output
t, and maybe an encoded payment ID (should be at most one per transaction)15
Our final one-input/one-output example transaction sounds like this: “My transaction uses trans
action public key rG. I will spend one of the outputs in set X (note that it has a hidden amount
AX , committed to in CX ). The output being spent is owned by me (I made a MSLAG signature on
the one-time addresses in X), and hasn’t been spent before (its key image K ̃ has not yet appeared
in the blockchain). I will give it a pseudo output commitment C′
X . I will make one output Y ,
which may be spent by the one-time address Ko
Y . It has a hidden amount AY committed to in
CY , encrypted for the recipient, and proven in range with a Bulletproofs-style range proof. My
transaction includes a transaction fee f . Please note that C′
X − (CY + Cf ) = 0, and that I have
signed the commitment to zero C′
X − CX = zG which means the input amount equals the output
amount (AX = A′
X = AY + f ). My MLSAG signed all transaction data, so observers can be sure
it hasn’t been tampered with.”
15 No information stored in the ‘extra’ field is verified, though it is signed by input MLSAGs, so no tampering is possible (except with negligible probability). The field has no limit on how much data it can store, so long as the maximum transaction weight is respected. See [81] for more details.


CHAPTER 6. MONERO RING CONFIDENTIAL TRANSACTIONS (RINGCT) 54
6.3.1 Storage requirements
For RCTTypeBulletproof2 we need (2(v + 1) + 2) · m · 32 bytes of storage, and the aggregate
Bulletproof range proof needs (2 · dlog2(64 · p)e + 9) · 32 bytes of storage.16
Miscellaneous requirements:
• Input key images: m ∗ 32 bytes
• One-time output addresses: p ∗ 32 bytes
• Output commitments: p ∗ 32 bytes
• Encoded output amounts: p ∗ 8 bytes
• Transaction public key: 32 bytes normally, p ∗ 32 bytes if sending to at least one subaddress.
• Payment ID: 8 bytes for an integrated address. There should be no more than one per tx.
• Transaction fee: stored as a variable length integer, so ≤ 9 bytes
• Input offsets: stored as variable length integers, so ≤ 9 bytes per offset, for m ∗ (v + 1) ring
members
• Unlock time: stored as a variable length integer, so ≤ 9 bytes17
• ‘Extra’ tags: each piece of data in the ‘extra’ field (e.g. a transaction public key) begins
with a 1 byte ‘tag’, and some pieces also have a 1+ byte ‘length’; see Appendix A for more
details
16 The amount of transaction content is limited by a maximum so-called ‘transaction weight’. src/cryptonote core/ tx pool.cpp get transaction weight limit()
Before Bulletproofs were added in protocol v8 (and indeed currently when transactions have only two outputs) the transaction weight and size in bytes were equivalent. The maximum weight is (0.5*300kB - CRYPTONOTE COINBASE BLOB RESERVED SIZE), where the blob reserve (600 bytes) is intended to leave room for the miner transaction within blocks. Before v8 the 0.5x multiplier was not included, and the 300kB term was smaller in earlier protocol versions (20kB v1, 60kB v2, 300kB v5). We elaborate on these topics in Section 7.3.2. 17 Any transaction’s author can lock its outputs src/cryptonote core/ blockchain.cpp is tx spendtime unlocked()
, rendering them unspendable until a specified block height where it may be spent (or until a UNIX timestamp, at which time its outputs may be included in a block’s transaction’s ring members). He only has the option to lock all outputs to the same block height. It is not clear if this offers any meaningful utility to transaction authors (perhaps smart contracts). Miner transactions have a mandatory 60-block lock time. As of protocol v12 normal outputs can’t be spent until after the default spendable age (10 blocks) which is functionally equivalent to a mandatory minimum 10-block lock time. If a transaction is published in the 10th block with an unlock time of 25, it may be spent in the 25th block or later. Unlock time is probably the least used of all transaction features for normal transactions.


CHAPTER 7
The Monero Blockchain
The Internet Age has brought a new dimension to the human experience. We can correspond
with people on every corner of the planet, and an unimaginable wealth of information is at our
fingertips. Exchanging goods and services is fundamental to a peaceful and prosperous society
[96], and in the digital realm we can offer our productivity to the whole world.
Media of exchange (moneys) are essential, giving us a point of reference to an immense diversity of
economic goods that would otherwise be impossible to evaluate, and enabling mutually beneficial
interactions between people with nothing in common [96]. Throughout history there have been
many kinds of money, from seashells to paper to gold. Those were exchanged by hand, and now
money can be exchanged electronically.
In the current, by far most pervasive, model, electronic transactions are handled by third-party
financial institutions. These institutions are given custody of money and trusted to transfer it
upon request. Such institutions must mediate disputes, their payments are reversible, and they
can be censored or controlled by powerful organizations. [97]
To alleviate these drawbacks decentralized digital currencies have been engineered.1
7.1 Digital currency
Designing a digital currency is non-trivial. There are three types: personal, centralized, or dis
tributed. Keep in mind that a digital currency is just a collection of messages, and the ‘amounts’
recorded in those messages are interpreted as monetary quantities.
1 This chapter includes more implementation details than previous chapters, as a blockchain’s nature depends heavily on its specific structure.
55


CHAPTER 7. THE MONERO BLOCKCHAIN 56
In the email model anyone can make coins (e.g. a message saying ‘I own 5 coins’), and anyone
can send their coins over and over to whoever has an email address. It does not have a limited
supply, nor does it prevent spending the same coins over and over (double spending).
In the video game model, where the entire currency is stored/recorded on one central database,
users rely on the custodian to be honest. The currency’s supply is unverifiable for observers, and
the custodian can change the rules at any time, or be censored by powerful outsiders.
7.1.1 Distributed/shared version of events
In digital ‘shared’ money, many computers each have a record of every currency transaction. When
a new transaction is made on one computer it is broadcast to the other computers, and accepted
if it follows predefined rules.
Users only benefit from coins when other users accept them in exchange, and users only accept
coins they feel are legitimate. To maximize the utility of their coins, users are naturally inclined
to settle on one commonly accepted rule-set, without the presence of a central authority.2
Rule 1: Money can only be created in clearly defined scenarios.
Rule 2: Transactions spend money that already exists.
Rule 3: A person can only spend a piece of money once.
Rule 4: Only the person who owns a piece of money can spend it.
Rule 5: Transactions output money equal to the money spent.
Rule 6: Transactions are formatted correctly.
Rules 2-6 are covered by the transaction scheme discussed in Chapter 6, which adds the fungibility
and privacy-related benefits of ambiguous signing, anonymous receipt of funds, and unreadable
amount transfers. We explain Rule 1 later in this chapter.3 Transactions use cryptography, so we
call their content a cryptocurrency.
If two computers receive different legitimate transactions spending the same money before they
have a chance to send the information to each other, how do they decide which is correct? There
is a ‘fork’ in the currency, because two different copies that follow the same rules exist.
Clearly the earliest legitimate transaction spending a piece of money should be canonical. This is
easier said than done. As we will see, obtaining consensus for transaction histories constitutes the
raison d’ˆetre of blockchain technology.
2 In political science this is called a Schelling Point [64], social minima, or social contract. 3 In commodity money like gold these rules are met by physical reality.


CHAPTER 7. THE MONERO BLOCKCHAIN 57
7.1.2 Simple blockchain
First we need all computers, henceforth referred to as nodes, to agree on the order of transactions.
Let’s say a currency started with a ‘genesis’ declaration: “Let the SampleCoin begin!”. We call
this message a ‘block’, and its block hash is
BH G = H(“Let the SampleCoin begin!”)
Every time a node receives some transactions, they use hashes of those transactions, TH , like
messages, along with the previous block’s hash, and compute new block hashes
BH 1 = H(BH G, TH 1, TH 2, ...)
BH 2 = H(BH 1, TH 3, TH 4, ...)
And so on, publishing each new block of messages as it’s made. Each new block references the
previous, most recently published block. In this way a clear order of events extends/chains all the
way back to the genesis message. We have a very simple ‘blockchain’.4
Nodes can include a timestamp in their blocks to aid record keeping. If most nodes are honest with
timestamps then the blockchain provides a decent picture of when each transaction was recorded.
If different blocks referencing the same previous block are published at the same time, then the
network of nodes will fork as each node receives one of the new blocks before the other (for
simplicity, imagine about half the nodes end up with each side of the fork).
7.2 Difficulty
If nodes can publish new blocks whenever they want, the network might fracture and diverge into
many different, equally legitimate, chains. Say it takes 30 seconds to make sure everyone in the
network gets a new block. What if new blocks are sent out every 31, 15 seconds, 10 seconds, etc?
We can control how fast the entire network makes new blocks. If the time it takes to make a new
block is much higher than the time for the previous block to reach most nodes, the network will
tend to remain intact.
7.2.1 Mining a block
The output of a cryptographic hash function is uniformly distributed and apparently independent
of the input. This means, given a potential input, its hash is equally likely to be every single
possible output. Furthermore, it takes a certain amount of time to compute a single hash.
4 A blockchain is technically a ‘directed acyclic graph’ (DAG), with Bitcoin-style blockchains a one-dimensional variant. DAGs contain a finite number of nodes and one-directional edges (vectors) connecting nodes. If you start at one node, you will never loop back to it no matter what path you take. [6]


CHAPTER 7. THE MONERO BLOCKCHAIN 58
Let’s imagine a hash function Hi(x) which outputs a number from 1 to 100: Hi(x) ∈D
R {1, ..., 100}.5
Given some x, Hi(x) selects the same ‘random’ number from {1, ..., 100} every time you calculate
it. It takes 1 minute to calculate Hi(x).
Say we are given a message m, and told to find a ‘nonce’ n (some integer) such that Hi(m, n)
outputs a number less than or equal to the target t = 5 (i.e. Hi(m, n) ∈ {1, ..., 5}).
Since only 1/20th of outputs from Hi(x) will meet the target, it should take around 20 guesses of
n to find one that works (and hence 20 minutes of computing time).
Searching for a useful nonce is called mining, and publishing the message with its nonce is a proof
of work because it proves we found a useful nonce (even if we were lucky and found it with just one
hash, or even blindly published a good nonce), which anyone can verify by computing Hi(m, n).
Now say we have a hash function for generating proofs of work, HP oW ∈D
R {0, ..., m}, where m is
its maximum possible output. Given a message m (a block of information), a nonce n to mine,
and a target t, we can define the expected average number of hashes, the difficulty d, like this:
d = m/t. If src/crypto
note basic/
diffi
culty.cpp
check
hash()
HP oW (m, n) ∗ d ≤ m, then HP oW (m, n) ≤ t and n is acceptable.6
With smaller targets the difficulty rises and it takes a computer more and more hashes, and
therefore longer and longer periods of time, to find useful nonces.7
7.2.2 Mining speed
Assume all nodes are mining at the same time, but quit on their ‘current’ block when they receive
a new one from the network. They immediately start mining a fresh block that references the new
one.
Suppose we collect a bunch b of recent blocks from the blockchain (say, with index u ∈ {1, ..., b})
which each had a difficulty du. For now, assume the nodes who mined them were honest, so each
block timestamp T Su is accurate.8 The total time between the earliest block and most recent
block is totalTime = T Sb − T S1. The approximate number of hashes it took to mine all the blocks
is totalDifficulty = ∑
u du.
Now we can guess how fast the network, with all its nodes, can compute hashes. If the actual
speed didn’t change much while the bunch of blocks was being produced, it should be effectively9
hashSpeed ≈ totalDifficulty/totalTime
5 We use ∈D
R to say the output is deterministically random. 6 In Monero only difficulties are recorded/computed since HP oW (m, n) ∗ d ≤ m doesn’t need t. 7 Mining and verifying are asymmetric since it takes the same time to verify a proof of work (one computation of the proof of work algorithm) no matter what the difficulty is. 8 Timestamps are determined when a miner starts mining a block, so they are likely to lag behind the actual publication moment. The next block starts mining right away, so the timestamp that appears after a given block indicates how long miners spent on it. 9 If node 1 tries nonce n = 23 and later node 2 also tries n = 23, node 2’s effort is wasted because the network already ‘knows’ n = 23 doesn’t work (otherwise node 1 would have published that block). The network’s effective hash rate depends on how fast it hashes unique nonces for a given block of messages. As we will see, since miners include a miner transaction with one-time address Ko ∈ER Zl (ER = effectively random) in their blocks, blocks are always unique between miners except with negligible probability, so trying the same nonces doesn’t matter.


CHAPTER 7. THE MONERO BLOCKCHAIN 59
If we want to set the target time to mine new blocks so blocks are produced at a rate
(one block)/(target time), then we calculate how many hashes it should take for the network to
spend that amount of time mining. Note: we round up so the difficulty never equals zero.
newDifficulty = hashSpeed ∗ targetTime
There is no guarantee the next block will take newDifficulty amount of total network hashes to
mine, but over time and many blocks and constantly re-calibrating, the difficulty will track with
the network’s real hash speed and blocks will tend to take targetTime.10
7.2.3 Consensus: largest cumulative difficulty
Now we can resolve conflicts between chain forks.
By convention, the chain with highest cumulative difficulty (from all blocks in the chain), and
therefore with most work (network hashes) spent constructing, is considered the real, legitimate
version. If a chain splits and each fork has the same cumulative difficulty, nodes continue mining
on the branch they received first. When one branch gets ahead of the other they discard (‘orphan’)
the weaker branch.
If nodes wish to change or upgrade the basic protocol, i.e. the set of rules a node considers when
deciding if a blockchain copy or new block is legitimate, they may easily do so by forking the
chain. Whether the new branch has any impact on users depends on how many nodes switch and
how much software infrastructure is modified.11
For an attacker to convince honest nodes to alter the transaction history, perhaps in order to
respend/unspend funds, he must create a chain fork (on the current protocol) with higher total
difficulty than the main chain (which meanwhile continues to grow). This is very hard to do unless
you control over 50% of the network hash speed and can outwork other miners. [97]
7.2.4 Mining in Monero
To make sure chain forks are on an even footing, we don’t sample the most recent blocks (for
calculating new difficulties), instead lagging our bunch b by l. For example, if there are 29 blocks
in the chain (blocks 1, ..., 29), b = 10, and l = 5, we sample blocks 15-24 in order to compute block
30’s difficulty.
If mining nodes are dishonest they can manipulate timestamps so new difficulties don’t match
the network’s real hash speed. We get around this by sorting timestamps chronologically, then
10 If we assume network hash rate is constantly, gradually, increasing, then since new difficulties depend on past hashes (i.e. before the hash rate increased a tiny bit) we should expect actual block times to, on average, be slightly less than targetTime. The effect of this on the emission schedule (Section 7.3.1) could be canceled out by penalties from increasing block weights, which we explore in Section 7.3.3. 11 Monero developers have successfully changed src/hardforks/ hardforks.cpp mainnet hard forks[]
its protocol 11 times, with nearly all users and miners adopting each fork: v1 April 18, 2014 (genesis version) [127]; v2 March 2016; v3 September 2016; v4 January 2017; v5 April 2017; v6 September 2017; v7 April 2018; v8 and v9 October 2018; v10 and v11 March 2019; v12 November 2019. The core git repository’s README contains a summary of protocol changes in each version.


CHAPTER 7. THE MONERO BLOCKCHAIN 60
chopping off the first o outliers and last o outliers. Now we have a ‘window’ of blocks w = b − 2 ∗ o.
From the previous example, if o = 3 and timestamps are honest then we would chop blocks 15-17
and 22-24, leaving blocks 18-21 to compute block 30’s difficulty from.
Before chopping outliers we sorted timestamps, but only timestamps. Block difficulties are left
unsorted. We use the cumulative difficulty for each block, which is that block’s difficulty plus the
difficulty of all previous blocks in the chain.
Using
src/crypto
note core/
block
chain.cpp
get diff
iculty for
next
block()
the chopped arrays of w sorted timestamps and unsorted cumulative difficulties (indexed
from 1, ..., w), we define
totalTime = choppedSortedTimestamps[w] − choppedSortedTimestamps[1]
totalDifficulty = choppedCumulativeDifficulties[w] − choppedCumulativeDifficulties[1]
In src/crypto
note config.h
Monero the target time is 120 seconds (2 minutes), l = 15 (30 mins), b = 720 (one day), and
o = 60 (2 hours).12,13
Block difficulties are not stored in the blockchain, so someone downloading a copy of the blockchain
and verifying all blocks are legitimate needs to recalculate difficulties from recorded timestamps.
There src/crypto
note basic/
diffi
culty.cpp
next diff
iculty()
are a few rules to consider for the first b + l = 735 blocks.
Rule 1: Ignore the genesis block (block 0, with d = 1) completely. Blocks 1 and 2 have
d = 1.
Rule 2: Before chopping off outliers, try to get the window w to compute totals from.
Rule 3: After w blocks, chop off high and low outliers, scaling the amount chopped until
b blocks. If the amount of previous blocks (minus w) is odd, remove one more low outlier
than high.
Rule 4: After b blocks, sample the earliest b blocks until b + l blocks, after which everything
proceeds normally - lagging by l.
Monero proof of work (PoW)
Monero src/crypto
note basic/
cryptonote
tx utils.cpp
get block
longhash()
has used a few different proof of work hash algorithms (with 32 byte outputs) in different
protocol versions. The original, known as Cryptonight, was designed to be relatively inefficient on
GPU, FPGA, and ASIC architectures [124] compared to standard hash functions like SHA256. In
April 2018 (v7 of the protocol), new blocks were required to begin using a slightly modified variant
that countered the advent of Cryptonight ASICs [29]. Another slight variant, named Cryptonight
V2, was implemented in October 2018 (v8) [11], and Cryptonight-R (based on Cryptonight but
with more substantial changes than just a tweak) started being used for new blocks in March 2019
(v10) [12]. A src/crypto/
rx-slow
hash.c
radical new proof of work called RandomX [70] was designed and made mandatory
for new blocks in November 2019 (v12) with the intention of long-term ASIC resistance [15].
12 In March 2016 (v2 of the protocol), Monero changed from 1 minute target block times to 2 minute target block times [14]. Other difficulty parameters have always been the same. 13 Monero’s difficulty algorithm may be suboptimal compared to state of the art algorithms [144]. Fortunately it is ‘fairly resilient to selfish mining’ [51], an essential feature.


CHAPTER 7. THE MONERO BLOCKCHAIN 61
7.3 Money supply
There are two basic mechanisms for creating money in a blockchain-based cryptocurrency.
First, the currency’s creators can conjure coins and distribute them to people in the genesis
message. This is often called an ‘airdrop’. Sometimes creators give themselves a large amount in
a so-called ‘pre-mine’. [20]
Second, the currency can be automatically distributed as reward for mining a block, much like
mining for gold. There are two types here. In the Bitcoin model the total possible supply is
capped. Block rewards slowly decline to zero, after which no more money is ever made. In the
inflation model supply increases indefinitely.
Monero is based on a currency known as Bytecoin that had a sizeable pre-mine, followed by block
rewards [13]. Monero had no pre-mine, and as we will see, its block rewards slowly decline to a
small amount after which all new blocks reward that same amount, making Monero inflationary.
7.3.1 Block reward
Block miners, before mining for a nonce, make a ‘miner transaction’ with no inputs and at least
one output.14 The total output amount is equal to the block reward, plus transaction fees from all
transactions to be included in the block, and is communicated in clear text. Nodes who receive a
mined block must verify src/crypto
note core/
block
chain.cpp
validate
miner
trans
action()
the block reward is correct, and can calculate the current money supply
by summing all past block rewards together.
Besides distributing money, block rewards incentivize mining. If there were no block rewards
(and no other mechanism), why would anyone mine new blocks? Perhaps altruism or curiosity.
However, few miners makes it easy for a malicious actor to assemble >50% of the network’s hash
rate and easily rewrite recent chain history.15 This is also why in Monero block rewards do not
fall all the way to zero.
With block rewards, competition between miners drives total hash rate up until the marginal cost
of adding more hash rate is higher than the marginal reward of obtaining that proportion of mined
blocks (which appear at a constant rate) (plus some premiums like risk and opportunity cost).
This means as a cryptocurrency becomes more valuable, its total hash rate will increase and it
becomes progressively more difficult and expensive to gather >50%.
14 A miner transaction can have any number of outputs, although currently the core implementation is only able to make one. Moreover, unlike normal transactions there are no explicit restrictions on miner transaction weight. They are functionally limited by the maximum block weight. 15 As an attacker gets higher shares of the hash rate (beyond 50%), it takes less time to rewrite older and older blocks. Given a block x days old, owned hash speed v, and honest hash speed vh (v > vh), it will take y = x ∗ (vh/(v − vh)) days to rewrite.


CHAPTER 7. THE MONERO BLOCKCHAIN 62
Bit shifting
Bit shifting is used for calculating the base block reward (as we will see in Section 7.3.3, the actual
block reward can sometimes be reduced below the base amount).
Suppose we have an integer A = 13 with bit representation [1101]. If we shift the bits of A down
by 2 using the bitwise shift right operator, denoted A >> 2, we get [0011].01, which equals 3.25.
In reality that last part gets thrown away - ‘shifted’ into oblivion, leaving us with [0011] = 3.16
Calculating base block reward for Monero
Let’s call the current total money supply M, and the ‘limit’ of the money supply L = 264 − 1
(in binary it is [11....11], with 64 bits).17 In the beginning of Monero the base block reward was
B = (L-M) >> 20. If M = 0, then, in decimal format,
L = 18, 446, 744, 073, 709, 551, 615
B0 = (L − 0) >> 20 = 17, 592, 186, 044, 415
These numbers are in ‘atomic units’ - 1 atomic unit of Monero can’t be divided. Clearly atomic
units are ridiculous - L is over 18 quintillion! We can divide everything by 1012 to move the decimal
point over, giving us the standard units of Monero (a.k.a. XMR, Monero’s so-called ‘stock ticker’).
L
1012 = 18, 446, 744.073709551615
B0 = (L − 0) >> 20
1012 = 17.592186044415
And there it is, the very first block reward, dispersed to pseudonymous thankful for today (who
was responsible for starting the Monero project) in Monero’s genesis block [127], was about 17.6
Moneroj! See Appendix C to confirm this for yourself.18
As blocks are mined M grows, lowering subsequent block rewards. Initially (since the genesis
block in April 2014) Monero blocks were mined once per minute, but in March 2016, it became
two minutes per block [14]. To keep the rate of money creation, i.e. the ‘emission schedule’,19
the same, block rewards were doubled. This just means, after the change, we use (L-M) >> 19
instead of >> 20 for new blocks. Currently the base block reward is src/crypto
note basic/
cryptonote
basic
impl.cpp
get block
reward()
B = (L − M ) >> 19
1012
7.3.2 Dynamic block weight
It would be nice to mine every new transaction into a block right away. What if someone submits
a lot of transactions maliciously? The blockchain, storing every transaction, would quickly grow
enormous.
16 Bitwise shift right by n bits is equivalent to integer division by 2n. 17 Perhaps now it is clear why range proofs (Section 5.5) limit transaction amounts to 64 bits. 18 Monero amounts are stored in atomic-unit format in the blockchain. 19 For an interesting comparison of Monero and Bitcoin’s emission schedules see [19].


CHAPTER 7. THE MONERO BLOCKCHAIN 63
One mitigation is a fixed block size (in bytes), so the number of transactions per block is limited.
What if honest transaction volume rises? Each transaction author would bid for a spot in new
blocks by offering fees to miners. Miners would focus on mining transactions with the highest fees.
As transaction volume increases, fees would become prohibitively large for transactions of small
amounts (such as Alice buying an apple from Bob). Only people willing to outbid everyone else
would get their transactions into the blockchain.20
Monero avoids those extremes (unlimited vs fixed) with a dynamic block weight.
Size vs Weight
Since src/crypto
note basic/
cryptonote
format
utils.cpp
get trans
action
weight()
Bulletproofs were added (v8), transaction and block sizes are no longer considered strictly.
The term used now is transaction weight. Transaction weight for a miner transaction (see Section
7.3.6), or a normal transaction with two outputs, is equal to the size in bytes. When a normal
transaction has more than two outputs the weight is somewhat higher than the size.
Recalling Section 5.5, a Bulletproof occupies (2 · dlog2(64 · p)e + 9) · 32 bytes, so as more outputs
are added the additional storage for range proofs is sub-linear. However, Bulletproof verification
is linear, so artificially increasing transaction weights ‘prices in’ that extra verification time (it’s
called a ‘clawback’).
Suppose src/crypto
note basic/
cryptonote
format
utils.cpp
get trans
action
weight
clawback()
we have a transaction with p outputs, and imagine that if p isn’t a power of 2 we create
enough dummy outputs to fill the gap. We find the difference between the actual Bulletproof size,
and the size of all the Bulletproofs if those p + ‘dummy outputs’ had been in 2-out transactions
(it’s 0 if p = 2). We only claw back 80% of the difference.21
transaction clawback = 0.8 ∗ [(23 ∗ (p + num dummy outs)/2) · 32 − (2 · dlog2(64 · p)e + 9) · 32]
Therefore the transaction weight is
transaction weight = transaction size + transaction clawback
A block’s weight src/crypto
note core/
block
chain.cpp
create
block
template()
is equal to the sum of its component transactions’ weights plus the miner trans
action’s weight.
Long term block weight
If dynamic blocks are allowed to grow at a rapid pace the blockchain can quickly become unman
ageable [83]. To mitigate this, maximum block weights are tethered by long term block weights.
20 Bitcoin has a history of overloaded transaction volume. This website (https://bitcoinfees.info/) charts the ridiculous fee levels encountered (up to the equivalent of 35$ per transaction at one point). 21 Note that log2(64 · 2) = 7, and 2 ∗ 7 + 9 = 23.


CHAPTER 7. THE MONERO BLOCKCHAIN 64
Each block has, in addition to its normal weight, a ‘long term weight’ calculated based on the pre
vious block’s effective median long term weight.22 A block’s effective median long term weight is
related to the median of the most recent 100000 blocks’ long term weights (including its own). src/crypto
note core/
block
chain.cpp
update
next cumu
lative
weight
limit()
23,24
longterm block weight = min{block weight, 1.4 ∗ previous effective longterm median}
effective longterm median = max{300kB, median 100000blocks longterm weights}
If normal block weights stay large for a long time, then it will take at least 50,000 blocks (about
69 days) for the effective long term median to rise by 40% (that’s how long it takes a given long
term weight to become the median).
Cumulative median weight
Transaction volume can change dramatically in a short period of time, especially around holidays
[128]. To accommodate this, Monero allows short term flexibility in block weights. To smooth
CRYPTONOTE
REWARD
BLOCKS
WINDOW
out
transient variability, a block’s cumulative median uses the median of the last 100 blocks’ normal
block weights (including its own).
cumulative weights median = max{300kB, min{max{300kB, median 100blocks weights},
50 ∗ effective longterm median}}
The next block to be added to the blockchain is constrained in this way:25
max next block weight src/crypto
note basic/
cryptonote
basic
impl.cpp
get block
reward()
= 2 ∗ cumulative weights median
While the maximum block weight can rise up to 100 times the effective median long term weight
after a few hundred blocks, it cannot rise more than 40% beyond that over the next 50,000 blocks.
Therefore long-term block weight growth is tethered by the long term weights, and in the short
term weights may surge above their steady-state values.
7.3.3 Block reward penalty
To mine blocks bigger than the cumulative median, miners have to pay a price, or penalty, in the
form of reduced block reward. This means there are functionally two zones within the maximum
22 Similar to block difficulties, block weights and long term block weights are calculated and stored by blockchain verifiers rather than being included in blockchain data. 23 Blocks made before long term weights were implemented have long term weights equal to their normal weights, so there is no concern for us about details surrounding the genesis block or early blocks. A brand new chain could easily make sensible choices. 24 In the beginning src/cryptonote basic/ cryptonote basic impl.cpp get min block weight()
of Monero the ‘300kB’ term was 20kB, then increased to 60kB in March 2016, (v2 of the protocol) [14], and has been 300kB since April 2017 (v5 of the protocol) [1]. This non-zero ‘floor’ within the dynamic block weight medians helps transient transaction volume changes when the absolute volume is low, especially in the early stages of Monero adoption. 25 The cumulative median replaced ‘M100’ (a similar median term) in protocol v8. Penalties and fees described in the first edition of this report [33] used M100.


CHAPTER 7. THE MONERO BLOCKCHAIN 65
block weight: the penalty-free zone, and the penalty zone. The median can slowly rise, allowing
progressively larger blocks with no penalty.
If the intended block weight is greater than the cumulative median, then, given base block reward
B, the block reward penalty is
P = B ∗ ((block weight/cumulative weights median) − 1)2
The actual block reward src/crypto
note basic/
cryptonote
basic
impl.cpp
get block
reward()
is therefore26
Bactual = B − P
Bactual = B ∗ (1 − ((block weight/cumulative weights median) − 1)2)
Using the ˆ2 operation means penalties are sub-proportional to block weight. A block weight
10% larger than the previous cumulative weights median has just a 1% penalty, 50% larger is 25%
penalty, 90% larger is 81% penalty, and so on. [19]
We can expect miners to create blocks larger than the cumulative median when the fee from adding
another transaction is bigger than the penalty incurred.
7.3.4 Dynamic minimum fee
To prevent malicious actors from flooding the blockchain with transactions that could be used to
pollute ring signatures, and generally bloat it unnecessarily, Monero has a minimum fee src/crypto
note core/
block
chain.cpp
check fee()
per byte
of transaction data.27 Originally this was 0.01 XMR/KiB (added early during protocol v1) [80],
then it became 0.002 XMR/KiB in September 2016 (v3).28
In January 2017 (v4), a dynamic fee per KiB algorithm [46, 45, 44, 73] was added,29 and then
along with transaction weight reductions due to Bulletproofs (v8) it changed from per KiB to per
byte. The most important feature of the algorithm is that it prevents minimum possible total fees
26 Before confidential transactions (RingCT) were implemented (v4), all amounts were communicated in clear text and in some early protocol versions split into chunks (e.g. 1244 → 1000 + 200 + 40 + 4). To reduce miner tx size, the core implementation chopped off the lowest significant digits of block rewards (anything less than 0.0001 Moneroj; see BASE REWARD CLAMP THRESHOLD) in v2-v3. The extra little bit was not lost, just made available for future block rewards. More generally, since v2 src/cryptonote core/ blockchain.cpp validate miner transaction()
the block reward calculation here is just an upper limit on the real block reward that can be dispersed in a miner tx’s outputs. Also of note, very early transactions’ outputs with cleartext amounts not split into chunks can’t be used in ring signatures in the current implementation, so to spend them they are migrated into chunked, ‘mixable’, outputs, which can then be spent in normal RingCT transactions by creating rings out of other chunks with the same amount. Exact modern protocol rules around these ancient pre-RingCT outputs are not clear. 27 This minimum is enforced by the node consensus protocol, not the blockchain protocol. Most nodes won’t relay a transaction to other nodes if it has a fee below the minimum src/cryptonote core/ tx pool.cpp add tx()
(at least in part so only transactions likely to be mined by someone are passed along [45]), but they will accept a new block containing that transaction. In particular, this means there is no need to maintain backward compatibility with fee algorithms. 28 The unit KiB (kibibyte, 1 KiB = 1024 bytes) is different from kB (kilobyte, 1 kB = 1000 bytes). 29 The base fee was changed from 0.002 XMR/KiB to 0.0004 XMR/KiB in April 2017 (v5 of the protocol) [1]. The first edition of this report described the original dynamic fee algorithm [33].


CHAPTER 7. THE MONERO BLOCKCHAIN 66
from exceeding the block reward (even with small block rewards and large block weights), which
is thought to cause instability [98, 47, 59].30
The fee algorithm
We base our fee algorithm around a reference transaction [73] of weight 3000 bytes (similar to a
basic RCTTypeBulletproof2 2-input, 2-output transaction, which is usually about 2600 bytes)31,
and the fees it would take to offset the penalty when the median is at its minimum (the smallest
penalty-free zone, 300kB) [45]. In other words, the penalty induced by a 303kB block weight.
Firstly, the fee F to balance the marginal penalty MP from adding a transaction with weight TW
to a block with weight BW, is
F = MP = B ∗ (([BW + TW]/cumulative median − 1)2−
B ∗ ((BW/cumulative median − 1)2
Defining the block weight factor WFb = (BW/cumulative median − 1), and transaction weight
factor WFt = (TW/cumulative median), lets us simplify
F = B ∗ (2 ∗ WFb ∗ WFt + WF2
t)
Using a block weighing 300kB (with a cumulative median at the default 300kB) and our reference
transaction with 3000 bytes,
Fref = B ∗ (2 ∗ 0 ∗ WFt + WF2
t)
Fref = B ∗ WF2
t
Fref = B ∗ ( TWref
cumulative medianref
)2
This fee is spread out over 1% of the penalty zone (3000 out of 300000). We can spread the same
fee over 1% of any penalty zone with a generalized reference transaction.
TWref
cumulative medianref
= TWgeneral-ref
cumulative mediangeneral
1 = ( TWgeneral-ref
cumulative mediangeneral
) ∗ ( cumulative medianref
TWref
)
Fgeneral-ref = Fref
= Fref ∗ ( TWgeneral-ref
cumulative mediangeneral
) ∗ ( cumulative medianref
TWref
)
Fgeneral-ref = B ∗ ( TWgeneral-ref
cumulative mediangeneral
) ∗ ( TWref
cumulative medianref
)
30 Credit for the concepts in this section largely belongs to Francisco Caban ̃as (a.k.a. ‘ArticMine’), the architect of Monero’s dynamic block and fee system. See [46, 45, 44]. 31 A basic 1-input, 2-output Bitcoin transaction is 250 bytes [26], or 430 bytes for 2-in/2-out.


CHAPTER 7. THE MONERO BLOCKCHAIN 67
Now we can scale the fee based on a real transaction weight at a given median, so e.g. if the
transaction is 2% of the penalty zone the fee gets doubled.
Fgeneral = Fgeneral-ref ∗ TWgeneral
TWgeneral-ref
Fgeneral = B ∗ ( TWgeneral
cumulative mediangeneral
) ∗ ( TWref
cumulative medianref
)
This rearranges to the default fee per byte, which we have been working toward.
fB
def ault = Fgeneral/TWgeneral
fB
default = B ∗ ( 1
cumulative mediangeneral
) ∗ ( 3000
300000 )
When transaction volume is below the median there is no real reason for fees to be at the reference
level [73]. We set the minimum to be 1/5th the default.
fB
min = B ∗ ( 1
cumulative weights median ) ∗ ( 3000
300000 ) ∗ ( 1
5)
fB
min = B ∗ ( 1
cumulative weights median ) ∗ 0.002
The fee median
It turns out using the cumulative median for fees enables a spam attack. By raising the short
term median to its highest value (50 x long term median), an attacker can use minimum fees to
maintain high block weights (relative to organic transaction volume) with very low cost.
To avoid this we limit fees for transactions to go in the next block with the smallest median
available, which favors higher fees in all cases.32
smallest median src/crypto
note core
block
chain.cpp
check fee()
= max{300kB, min{median 100blocks weights, effective longterm median}}
Favoring higher fees during rising transaction volume also facilitates adjusting the short term
median and ensuring transactions aren’t left pending, as miners are more likely to mine into the
penalty zone.
32 An attacker can spend just enough in fees for the short term median to hit 50*long-term-median. With current (as of this writing) block rewards at 2 XMR, an optimized attacker can increase the short term median by 17% every 50 blocks, and reach the upper bound after about 1300 blocks (about 43 hours), spending 0.39*2 XMR per block, for a total setup cost of about 1000 XMR (or around 65k USD at current valuations), and then go back to the minimum fee. When the fee median equals the penalty-free zone, then the minimum total fee to fill the penalty-free zone is 0.004 XMR (about 0.26 USD at current valuations). If the fee median equals the long term median, it would in the spam scenario be 1/50th the penalty-free zone. Therefore it would just be 50x the short-median case, for 0.2 XMR per block (13 USD per block). This comes out to 2.88 XMR per day vs 144 XMR per day (for 69 days, until the long term median rises by 40%) to maintain every block with 50*long-term-median block weight. The 1000 XMR setup cost would be worthwhile in the former case, but not the latter. This will reduce to 300 XMR setup, and 43 XMR maintenance, at the emission tail.


CHAPTER 7. THE MONERO BLOCKCHAIN 68
The actual minimum fee is therefore33,34
fB
min−actual src/crypto
note core
block
chain.cpp
get dyna
mic base
fee()
=B∗( 1
smallest median ) ∗ 0.002
Transaction fees
As Caban ̃as said in his insightful presentation on this topic [45], “[f]ees tell the miner how deep
into the penalty [transaction authors are] willing to pay for, in order to get a transaction mined.”
Miners will fill up their blocks by adding transactions in descending order of fee amount [45]
(assuming all transactions have the same weight), so to move into the penalty zone there must be
numerous transactions with large fees. This means it is likely the block weight cap can only be
reached if total fees are at least about 3-4 times the base block reward (at which point the actual
block reward is zero).35
To calculate fees for a transaction, Monero’s core implementation wallet uses ‘priority’ src/wallet/
wallet2.cpp
get fee
multi
plier()
multipliers.
A ‘slow’ transaction uses the minimum fee directly, ‘normal’ is the default fee (5x), if all trans
actions use ‘fast’ (25x) they can reach 2.5% of the penalty zone, and a block with ‘super urgent’
(1000x) transactions can fill 100% of the penalty zone.
One important consequence of dynamic block weights is average total block fees will tend to be
of a magnitude lower than, or at least the same as, the block reward (total fees can be expected
to equal the base block reward at about 37% of the penalty zone [68.5% of the maximum block
weight], when the penalty is 13%). Transactions competing for block space with higher fees leads
to a bigger supply of block space, and lower fees.36 This feedback mechanism is a strong counter
to the renowned ‘selfish miner’ [59] threat.
7.3.5 Emission tail
Let’s suppose a cryptocurrency with fixed maximum supply and dynamic block weight. After a
while its block rewards fall to zero. With no more penalty on increasing block weight, miners add
any transaction with a non-zero fee to their blocks.
33 To check if a given fee is correct, we allow a 2% buffer on f B
min−actual in case of integer overflow (we must compute fees before tx weights are completely determined). This means the effective minimum fee is 0.98*f B
min−actual. src/cryptonote core blockchain.cpp
check fee()
34 Research to improve minimum fees even further is ongoing. [131] 35 The marginal penalty from the last bytes to fill up a block can be considered a ‘transaction’ comparable to other transactions. In order for a clump of transactions to buy that transaction space from a miner, all its individual transaction fees should be higher than the penalty, since if any one of them is lower then the miner will keep the marginal reward instead. This last marginal reward, assuming a block filled with small transactions, requires at least 4x the base block reward in total fees to be purchased. If transaction weights are maximized (50% of the minimum penalty-free zone, i.e. 150kB) then if the median is minimized (300kB) the last marginal transaction requires at least 3x in total fees. 36 As block rewards decline over time, and the median rises due to increased adoption (theoretically), fees should steadily become smaller and smaller. In ‘real purchasing power’ terms, this may be less impactful on transaction costs if the value of Moneroj rises due to adoption and economic deflation.


CHAPTER 7. THE MONERO BLOCKCHAIN 69
Block weights stabilize around the average rate of transactions submitted to the network, and
transaction authors have no compelling reason to use transaction fees above the minimum, which
would be zero according to Section 7.3.4.
This introduces an unstable, insecure situation. Miners have little to no incentive to mine new
blocks, leading to a fall in network hash rate as returns on investment decline. Block times remain
the same as difficulties adjust, but the cost of performing a double-spend attack may become
feasible.37 If minimum fees are forced to be non-zero then the ‘selfish miner’ [59] threat becomes
realistic [47].
Monero src/crypto
note basic/
cryptonote
basic
impl.cpp
get block
reward()
prevents this by not allowing the block reward to fall below 0.6 XMR (0.3 XMR per
minute). When the following condition is met,
0.6 > ((L − M ) >> 19)/1012
M > L − 0.6 ∗ 219 ∗ 1012
M/1012 > L/1012 − 0.6 ∗ 219
M/1012 > 18, 132, 171.273709551615
the Monero chain will enter a so-called ‘emission tail’, with constant 0.6 XMR (0.3 XMR/minute)
block rewards forever after.38 This corresponds with about 0.9% yearly inflation to begin with,
steadily declining thereafter.
7.3.6 Miner transaction: RCTTypeNull
A block’s miner has the right to claim ownership of the fees provided in its transactions, and to
mint new money in the form of a block reward. The mechanism is a miner transaction src/crypto
note core/
cryptonote
tx utils.cpp
construct
miner tx()
(a.k.a.
coinbase transaction), which is similar to a normal transaction.39
The output amount(s) of a miner transaction must be no more than the sum of transaction fees
and block reward, and are communicated in clear text.40 In place of an input, the block’s height
is recorded (i.e. “I claim the block reward and fees for the nth block”).
Ownership of the miner output(s) is assigned to a standard one-time address41, with a correspond
ing transaction public key stored in the extra field. The funds are locked, unspendable, until the
37 The case of fixed supply and fixed block weight, as in Bitcoin, is also thought to be unstable. [47] 38 The Monero emission tail’s estimated arrival is May 2022 [17]. The money supply limit L will be reached in May 2024, but since coin emission will no longer depend on the supply it will have no effect. Based on Monero’s range proof, it will be impossible to send more money than L in one output, even if someone manages to accumulate more than that (and assuming they have wallet software that can handle that much). 39 Apparently, at one point miner transactions could be constructed using deprecated transaction format versions, and could include some normal transaction (RingCT) components. The issues were fixed in protocol v12 after this hackerone report was published: [8]. 40 In the current version miners may claim less than the calculated block reward. The leftovers are pushed back into the emission schedule for future miners. 41 The miner transaction output can theoretically be sent to a subaddress and/or use multisig and/or an encoded payment ID. We don’t know if any implementations have any of those features.


CHAPTER 7. THE MONERO BLOCKCHAIN 70
60th block after it is published [21].42
Since RingCT was implemented in January 2017 (v4 of the protocol) [16], people downloading a
new copy of the blockchain compute a commitment to the miner transaction (a.k.a. tx) amount
src/block
chain db/
blockchain
db.cpp
add trans
action()
a, as C = 1G + aH, and store it for referral. This allows block miners to spend their miner
transaction outputs just like a normal transaction’s outputs, putting them in MLSAG rings with
other normal and miner tx outputs.
Blockchain verifiers store each post-RingCT block’s miner tx amount commitment, for 32 bytes
each.
7.4 Blockchain structure
Monero’s blockchain style is simple.
It starts with a genesis message
src/crypto
note core/
cryptonote
tx utils.cpp
generate
genesis
block()
of some kind (in our case basically a miner transaction dispersing
the first block reward), which constitutes the genesis block (see Appendix C). The next block
contains a reference to the previous block, in the form of block ID.
A block ID is simply a hash of
src/crypto
note basic/
cryptonote
format
utils.cpp
get block
hashing
blob()
the block’s header (a list of information about a block), a so-called
‘Merkle root’ that attaches all the block’s transaction IDs (which are hashes of each transaction),
and the number of transactions (including the miner transaction).
src/crypto
note basic/
cryptonote
format
utils.cpp
calculate
block
hash()
43
Block ID = Hn(Block header, Merkle root, #transactions + 1)
To produce a new block, one must do proof of work hashes by changing a nonce value stored
in the block header until the difficulty target condition is met.44 The proof of work and block
ID hash the same information, except use different hash functions. Blocks are mined
get block
longhash()
by, while
(P oW output ∗ dif f iculty) > 2256 − 1, repeatedly changing the nonce and recalculating
P oW output = HP oW (Block header, Merkle root, #transactions + 1)
7.4.1 Transaction ID
Transaction IDs are similar to the message signed by input MLSAG signatures (Section 6.2.2),
but include the MLSAG signatures too.
The following information is hashed:
42 The miner tx can’t be locked for more or less than 60 blocks. If it is published in the 10th block, its unlock height is 70, and it may be spent in the 70th block or later.
src/cryptonote core/ blockchain.cpp is tx spendtime unlocked()
43 +1 accounts for the miner tx. 44 In Monero a typical miner (from https://monerobenchmarks.info/ as of this writing) can do less than 50,000 hashes per second, so less than 6 million hashes per block. This means the nonce variable doesn’t need to be that big. Monero’s nonce is 4 bytes (max 4.3 billion), and it would be strange for any miner to require all the bits.


CHAPTER 7. THE MONERO BLOCKCHAIN 71
• TX Prefix src/crypto
note basic/
cryptonote
format
utils.cpp
calculate
transa
ction
hash()
= {transaction era version (e.g. ringCT = 2), inputs {key offsets, key images},
outputs {one-time addresses}, extra {transaction public key, encoded payment ID, misc.}}
• TX Stuff = {signature type (RCTTypeNull or RCTTypeBulletproof2), transaction fee, pseudo
output commitments for inputs, ecdhInfo (encrypted or cleartext amounts), output commit
ments}
• Signatures = {MLSAGs, range proofs}
In this tree diagram the black arrow indicates a hash of inputs.
Transaction ID
Hn(TX Prefix) Hn(TX Stuff) Hn(Signatures)
In place of an ‘input’, a miner transaction records the block height of its block. This ensures the
miner transaction’s ID, which is simply a normal transaction ID except with Hn(Signatures) →
0, is always unique, for simpler ID-searching.
7.4.2 Merkle tree
Some users may want to discard data from their copy of the blockchain. For example, once you
verify a transaction’s range proofs and input signatures, the only reason to keep that signature
information is so users who obtain it from you can verify it for themselves.
To src/crypto/
tree-hash.c
tree hash()
facilitate ‘pruning’ transaction data, and to more generally organize it within a block, we use
a Merkle tree [92], which is just a binary hash tree. Any branch in a Merkle tree can be pruned if
you keep its root hash.45
An example Merkle tree based on four transactions and a miner transaction is diagrammed in
Figure 7.1.46
45 The first known pruning method was added in v0.14.1 of the core Monero implementation (March 2019, coinciding with protocol v10). After verifying a transaction, full nodes can delete all its signature data (including Bulletproofs, MLSAGS, and pseudo output commitments) while keeping Hn(Signatures) for computing the transaction ID. They only do this with 7/8ths of all transactions, so every transaction is fully stored by at least 1/8th of the network’s full nodes. This reduces blockchain storage by about 2/3rds. [55] 46 A bug in Monero’s Merkle tree code led to a serious, though apparently non-critical, real-world attack on September 4th, 2014 [86].


CHAPTER 7. THE MONERO BLOCKCHAIN 72
Merkle Root
Hash B
Transaction ID
1
Transaction ID
2
Hash C
Transaction ID
3
Hash A
Transaction ID
4
Miner Transaction ID
Figure 7.1: Merkle Tree
A Merkle root is inherently a reference to all its included transactions.


CHAPTER 7. THE MONERO BLOCKCHAIN 73
7.4.3 Blocks
A block is basically a block header and some transactions. Block headers record important in
formation about each block. A block’s transactions can be referenced with their Merkle root.
We present here the outline of a block’s content. Our readers can find a real block example in
Appendix B.
• Block header:
– Major version: Used to track hard forks (changes to the protocol).
– Minor version: Once used for voting, now it just displays the major version again.
– Timestamp: src/crypto
note core/
block
chain.cpp
check
block
timestamp()
UTC (Coordinated Universal Time) time of the block. Added by min
ers, timestamps are unverified but they won’t be accepted if lower than the median
timestamp of the previous 60 blocks.
– Previous block’s ID: Referencing the previous block, this is the essential feature of
a blockchain.
– Nonce: A 4-byte integer that miners change over and over until the PoW hash meets
the difficulty target. Block verifiers can easily recalculate the PoW hash.
• Miner transaction: Disperses the block reward and transaction fees to the block’s miner.
• Transaction IDs: References to non-miner transactions added to the blockchain by this block.
Tx IDs can, in combination with the miner tx ID, be used to calculate the Merkle root, and
to find the actual transactions wherever they are stored.
In addition to the data in each transaction (Section 6.3), we store the following information:
• Major and minor versions: variable integers ≤ 9 bytes
• Timestamp: variable integer ≤ 9 bytes
• Previous block’s ID: 32 bytes
• Nonce: 4 bytes, can extend its effective size with the miner tx extra field’s extra nonce47
• Miner transaction: 32 bytes for a one-time address, 32 bytes for a transaction public key
(+1 byte for its ‘extra’ tag), and variable integers for the unlock time, corresponding block’s
height, and amount. After downloading the blockchain, we also need 32 bytes to store an
amount commitment C = 1G + aH (only for post-RingCT miner tx amounts).
• Transaction IDs: 32 bytes each
47 Within each transaction is an ‘extra’ field which can contain more-or-less arbitrary data. If a miner needs a wider range of nonces than just 4 bytes, they can add or alter data in their miner tx’s extra field to ‘extend’ the nonce size. [81]


Part II
Extensions
74


CHAPTER 8
Monero Transaction-Related Knowledge Proofs
Monero is a currency, and like any currency its uses are complex. From corporate accounting,
to market exchange, to legal arbitration, different interested parties may want to know detailed
information about transactions made.
How can you know for sure that money you received came from a specific person? Or prove that
you did in fact send a certain output or transaction to someone despite claims to the contrary?
Senders and recipients in the Monero public ledger are ambiguous. How can you prove you have
a certain amount of money, without compromising your private keys? Amounts in Monero are
completely hidden from observers.
We consider several types of transaction assertions, a few of which are implemented in Monero and
available with built-in wallet tools. We also outline a framework for auditing the full balance owned
by a person or organization, that doesn’t require leaking information about future transactions
they might make.
8.1 Transaction proofs in Monero
Monero transaction proofs are in the process of being updated [103]. The currently implemented
proofs are all ‘version 1’, and don’t include domain separation. We describe only the most advanced
proofs, whether they be currently implemented, slated for implementation in future releases [104],
or hypothetical proofs that may or may not get implemented (Sections 8.1.5 [130], and 8.2.1).
75


CHAPTER 8. MONERO TRANSACTION-RELATED KNOWLEDGE PROOFS 76
8.1.1 Multi-base Monero transaction proofs
There are a few details to be aware of going forward. Most Monero transaction proofs involve
multi-base proofs (recall Section 3.1). Wherever relevant, the domain separator is Ttxprf2 =
Hn(“TXPROOF V2”).1 The message being signed src/wallet/
wallet2.cpp
get tx
proof()
is usually (unless otherwise specified) m =
Hn(tx hash, message), where tx hash is the relevant transaction’s ID (Section 7.4.1), and message
is an optional message that provers or third parties can provide to make sure the prover actually
makes a proof and hasn’t stolen it.
Proofs are encoded in base-58, a binary-to-text encoding scheme first introduced for Bitcoin [28].
Verifying these proofs always involves first decoding them from base-58 back to binary. Note
that verifiers also need access to the blockchain, so they can use transaction ID references to get
information like one-time addresses.2
The structure of key prefixing in proofs is somewhat lopsided, due in part to accumulating updates
that haven’t reorganized it. Challenges for 2-base ‘version 2’ proofs are assembled with this format,
where if ‘base key 1’ is G then its position in the challenge is filled with 32 zero bytes,
c = Hn(m, public key 2, proof part 1, proof part 2, Ttxprf2, public key 1, base key 2, base key 1)
8.1.2 Prove creation of a transaction input (SpendProofV1)
Suppose we made a transaction, and want to prove it. Clearly, by remaking a transaction input’s
signature on a new message, any verifier would have no choice but to conclude we made the
original. Remaking all of a transaction’s inputs’ signatures means we must have made the entire
transaction (recall Section 6.2.2), or at the very least fully funded it.3
A so-called ‘SpendProof’ src/wallet/
wallet2.cpp
get spend
proof()
contains remade signatures for all of a transaction’s inputs. Importantly,
SpendProof ring signatures re-use the original ring members to avoid identifying the true signer
via ring intersections.
SpendProofs are implemented in Monero, and to encode one for transmission to verifiers, the
prover concatenates the prefix string “SpendProofV1” with the list of signatures. Note that the
prefix string is not in base-58 and doesn’t need to be encoded/decoded, since its purpose is human
readability.
The SpendProof
SpendProofs unexpectedly don’t use MLSAGs, but rather Monero’s original ring signature scheme
src/crypto/
crypto.cpp
generate
ring signa
ture()
that was used in the very first transaction protocol (pre-RingCT) [136].
1 Just like in Section 3.6, hash functions should be domain separated by prefixing them with tags. The current Monero transaction proofs implementation has no domain separation, so all the tags in this chapter are in features not yet implemented. 2 Transaction IDs are usually communicated separately from proofs. 3 As we will see in Chapter 11, someone who made one input signature didn’t necessarily make all input signatures.


CHAPTER 8. MONERO TRANSACTION-RELATED KNOWLEDGE PROOFS 77
1. Calculate key image K ̃ = koπHp(Kπo).
2. Generate random number α ∈R Zl and random numbers ci, ri ∈R Zl for i ∈ {1, 2, ..., n} but
excluding i = π.
3. Compute
ctot = Hn(m, [r1G + c1Ko
1 ], [r1Hp(Ko
1 ) + c1K ̃ ], ..., [αG], [αHp(Ko
π)], ..., etc.)
4. Define the real challenge
cπ = ctot −
n
∑
i=1,i6=π
ci
5. Define rπ = α − cπ ∗ koπ (mod l).
The signature is σ = (c1, r1, c2, r2, ..., cn, rn).
Verification
To verify src/wallet/
wallet2.cpp
check spe
nd proof()
a SpendProof on a given transaction, the verifier confirms that all ring signatures are
valid using information found in the relevant reference transaction (e.g. key images, and output
offsets for getting one-time addresses from other transactions).
1. Compute
ctot = Hn(m, [r1G + c1Ko
1 ], [r1Hp(Ko
1 ) + c1K ̃ ], ..., [rnG + cnKo
n], [rnHp(Ko
n) + cnK ̃ ])
2. Check that
ctot
?=
n
∑
i=1
ci
Why it works
Note how this scheme is the same as bLSAG (Section 3.4) when there is only one ring member. To
add a fake member, instead of passing the challenge cπ+1 into a new challenge hash, the member
gets added into the original hash. Since the following equation
cs = ctot −
n
∑
i=1,i6=s
ci
trivially holds for any index s, a verifier will have no way to identify the real challenge. Moreover,
without knowledge of koπ the prover would never have been able to define rπ properly (except with
negligible probability).


CHAPTER 8. MONERO TRANSACTION-RELATED KNOWLEDGE PROOFS 78
8.1.3 Prove creation of a transaction output (OutProofV2)
Now suppose we sent someone money (an output) and want to prove it. Transaction outputs
contain at heart three components: the recipient’s address, the amount sent, and the transaction
private key. Amounts are encoded, so we only really need the address and transaction private key
to get started. Anyone who deletes or loses their transaction private key will be unable to make
an OutProof, so in that sense OutProofs are the least reliable of all Monero transaction proofs.4
Our task here is to show the one-time address was made from the recipient’s address, and allow
verifiers to reconstruct the output commitment. We do so by providing the sender-receiver shared
secret rKv, then proving we created it and that it corresponds with the transaction public key
and recipient’s address by signing a 2-base signature (Section 3.1) on the base keys G and Kv.
Verifiers can use the shared secret to check the recipient src/wallet/
wallet2.cpp
check tx
proof()
(Section 4.2), decode the amount (Section
5.3), and reconstruct the output commitment (Section 5.3). We provide details for both normal
addresses and subaddresses.
The OutProof
To generate src/crypto/
crypto.cpp
generate
tx proof()
a proof for an output directed to an address (Kv, Ks) or subaddress (Kv,i, Ks,i),
with transaction private key r, where the sender-receiver shared secret is rKv, recall that the
transaction public key stored in transaction data is either rG or rKs,i depending on whether or
not the recipient is a subaddress (Section 4.3).
1. Generate random number α ∈R Zl, and compute
(a) Normal address: αG and αKv
(b) Subaddress: αKs,i and αKv,i
2. Calculate the challenge
(a) Normal address:5
c = Hn(m, [rKv], [αG], [αKv], [Ttxprf2], [rG], [Kv], [0])
(b) Subaddress:
c = Hn(m, [rKv,i], [αKs,i], [αKv,i], [Ttxprf2], [rKs,i], [Kv,i], [Ks,i])
3. Define the response6 rresp = α − c ∗ r.
4. The signature is σoutproof = (c, rresp).
4 We can think of an ‘OutProof’ as showing an output is ‘outgoing’ from the prover. The corresponding ‘InProofs’ (Section 8.1.4) show outputs that are ‘incoming’ to the prover’s address. 5 Here the ‘0’ value is a 32-byte encoding of zero bytes. 6 Due to the limited number of available symbols, we unfortunately used r for both responses and the transaction private key. Superscript ‘resp’ for ‘response’ will be used to differentiate the two when necessary.


CHAPTER 8. MONERO TRANSACTION-RELATED KNOWLEDGE PROOFS 79
A prover src/wallet/
wallet2.cpp
get tx
proof()
can generate a bunch of OutProofs, and send them all together to a verifier. He con
catenates prefix string “OutProofV2” with a list of proofs, where each item (encoded in base-58)
consists of the sender-receiver shared secret rKv (or rKv,i for a subaddress), and its corresponding
σoutproof . We assume the verifier knows the appropriate address for each proof.
Verification
1. Calculate the challenge src/crypto/
crypto.cpp
check tx
proof()
(a) Normal address:
c′ = Hn(m, [rKv], [rrespG + c ∗ rG], [rrespKv + c ∗ rKv], [Ttxprf2], [rG], [Kv], [0])
(b) Subaddress:
c′ = Hn(m, [rKv,i], [rrespKs,i+c∗rKs,i], [rrespKv,i+c∗rKv,i], [Ttxprf2], [rKs,i], [Kv,i], [Ks,i])
2. If c = c′ then the prover knows r, and rKv is legitimately a shared secret between rG and
Kv (except with negligible probability).
3. The src/wallet/
wallet2.cpp
check tx
key hel
per()
verifier should check the recipient’s address provided can be used to make a one-time
address from the relevant transaction (it’s the same computation for normal addresses and
subaddresses)
Ks ?= Ko
t − Hn(rKv, t)
4. They should also decode the output amount bt, compute the output mask yt, and try to
reconstruct the corresponding output commitment7
Cb
t
?= ytG + btH
8.1.4 Prove ownership of an output (InProofV2)
An OutProof shows the prover sent an output to an address, while an InProof shows an output
was received to a certain address. It is essentially the other ‘side’ of the sender-receiver shared
secret rKv. This time the prover proves knowledge of kv in Kv, and that in combination with the
transaction public key rG the shared secret kv ∗ rG appears.
Once a verifier has rKv, they can check if the corresponding one-time address is owned by the
prover’s address with src/wallet/
wallet2.cpp
check tx
proof()
Ko − Hn(kv ∗ rG, t) ∗ G ?= Ks (Section 4.2.1). By making an InProof for all
transaction public keys on the blockchain, a prover will reveal all his owned outputs.
7 A valid OutProof signature doesn’t necessarily mean the recipient considered is the real recipient. A malicious prover could generate a random view key K′v, compute K′s = Ko − Hn(rK′v, t) ∗ G, and provide (K′v, K′s) as the nominal recipient. By recalculating the output commitment, verifiers can be more confident the recipient address in question is legitimate. However, a prover and recipient could collaborate to encode the output commitment using K′v, while the one-time address uses (Kv, Ks). Since the recipient would need to know the private key k′v (assuming the output amount is still meant to be spendable), there is questionable utility to that level of deception. Why wouldn’t the recipient just use (K′v, K′s) (or some other single-use address) for the entire output? Since the computation of Cb
t is related to the recipient, we consider the described OutProof verification process adequate. In other words, the prover can’t use it to deceive verifiers without coordinating with the recipient.


CHAPTER 8. MONERO TRANSACTION-RELATED KNOWLEDGE PROOFS 80
Giving the view key directly to a verifier would have the same effect, but once they have that
key the verifier would be able to identify ownership of outputs to be created in the future. With
InProofs the prover is able to retain control of his private keys, at the cost of the time it takes to
prove (and then verify) each output is owned or unowned.
The InProof
An InProof is constructed the same way as an OutProof src/crypto/
crypto.cpp
generate
tx proof()
, except the base keys are now J =
{G, rG}, the public keys are K = {Kv, rKv}, and the signing key is kv instead of r. We will show
just the verification step to clarify our meaning. Note that the order of key prefixing changes (rG
and Kv swap places) to coincide with the different role each key has.
A multitude of InProofs, related to many outputs owned by the same address, can be sent together
to the verifier. src/wallet/
wallet2.cpp
get tx
proof()
They are prefixed with the string “InProofV2”, and each item (encoded in base-58)
contains the sender-receiver shared secret rKv (or rKv,i), and its corresponding σinproof .
Verification
1. Calculate the challenge src/crypto/
crypto.cpp
check tx
proof()
(a) Normal address:
c′ = Hn(m, [rKv], [rrespG + c ∗ Kv], [rresp ∗ rG + c ∗ kv ∗ rG], [Ttxprf2], [Kv], [rG], [0])
(b) Subaddress:
c′ = Hn(m, [rKv,i], [rrespKs,i+c∗Kv,i], [rresp∗rKs,i+c∗kv∗rKs,i], [Ttxprf2], [Kv,i], [rKs,i], [Ks,i])
2. If c = c′ then the prover knows kv, and kv ∗ rG is legitimately a shared secret between Kv
and rG (except with negligible probability).
Prove ‘full’ ownership with the one-time address key
While an InProof shows a one-time address was constructed with a specific address (except with
negligible probability), it doesn’t necessarily mean the prover can spend that output. Only those
who can spend an output actually own it.
Proving ownership, once an InProof is complete, is as simple as signing a message with the spend
key.8
8 The ability to provide such a signature directly does not seem to be available in Monero, although as we will see ReserveProofs (Section 8.1.6) do include them.


CHAPTER 8. MONERO TRANSACTION-RELATED KNOWLEDGE PROOFS 81
8.1.5 Prove an owned output was not spent in a transaction (UnspentProof )
It would seem like proving an output is spent or unspent is as simple as recreating its key image
with a multi-base proof on J = {G, Hp(Ko)} and K = {Ko, K ̃ }. While this does obviously work,
verifiers must learn the key image, which also reveals when an unspent output is spent in the
future.
It turns out we can prove an output wasn’t spent in a specific transaction without revealing the key
image. Moreover, we can prove it is currently unspent full stop, by extending this UnspentProof
[130] to ‘all the transactions where it was included as a ring member’.9
More specifically, our UnspentProof says that a given key image from a transaction on the
blockchain does, or does not, correspond with a specific one-time address from its correspond
ing ring. Incidentally, as we will see, UnspentProofs go hand-in-hand with InProofs.
Setting up an UnspentProof
The verifier of an UnspentProof must know rKv, the sender-receiver shared secret for a given
owned output with one-time address Ko and transaction public key rG. He either knows the view
key kv, which allowed him to calculate kv ∗ rG and check Ko − Hn(kv ∗ rG, t) ∗ G ?= Ks so he knows
the output being tested belongs to the prover (recall Section 4.2), or the prover provided rKv.
This is where InProofs come in, since with an InProof the verifier can be assured rKv legitimately
came from the prover’s view key, and corresponds with an owned output, without learning the
private view key.
Before verifying an UnspentProof, the verifier will learn the key image to be tested K ̃?, and checks
that its corresponding ring includes the prover’s owned output’s one-time address Ko. He then
calculates the partial ‘spend’ image K ̃ s
?.
K ̃ s
? = K ̃? − Hn(rKv, t) ∗ Hp(Ko)
If the tested key image was created from Ko then the resultant point will be K ̃ s
? = ks ∗ Hp(Ko).
The UnspentProof
Our prover creates two multi-base proofs (recall Section 3.1). His address, which owns the output
in question, is (Kv, Ks) or (Kv,i, Ks,i).10
1. A 3-base proof, where the signing key is ks, and
J unspent
3 = {[G], [Ks], [K ̃ s
? ]}
Kunspent
3 = {[Ks], [ks ∗ Ks], [ks ∗ K ̃ s
? ]}
9 UnspentProofs have not been implemented in Monero. 10 UnspentProofs are made the same way for subaddresses and normal addresses. The full spend key of a subaddress is required, e.g. ks,i = ks + Hn(kv, i) (Section 4.3).


CHAPTER 8. MONERO TRANSACTION-RELATED KNOWLEDGE PROOFS 82
2. A 2-base proof, where the signing key is ks ∗ ks, and
J unspent
2 = {[G], [Hp(Ko)]}
Kunspent
2 = {[ks ∗ Ks], [ks ∗ ks ∗ Hp(Ko)]}
Along with proofs σunspent
3 and σunspent
2 , the prover makes sure to communicate the public keys
ks ∗ Ks, ks ∗ K ̃ s
? , and ks ∗ ks ∗ Hp(Ko).
Verification
1. Confirm σunspent
3 and σunspent
2 are legitimate.
2. Make sure the same public key ks ∗ Ks was used in both proofs.
3. Check whether ks ∗ K ̃ s
? and ks ∗ ks ∗ Hp(Ko) are the same. If they are, the output is spent,
and if not it is unspent (except with negligible probability).
Why it works
This seemingly roundabout approach prevents the verifier from learning ks ∗Hp(Ko) for an unspent
output, which he could use in combination with rKv to compute its real key image, while leaving
him confident the tested key image doesn’t correspond to that output.
Proof σunspent
2 can be reused for any number of UnspentProofs involving the same output, although
if it actually was spent then only one is really necessary (i.e. UnspentProofs can also be used to
demonstrate an output is spent). Performing UnspentProofs on all ring signatures where a given
unspent output was referenced should not be computationally expensive. An output is only likely,
over time, to be included as decoys in on the order of 11 (current ring size) different rings.
8.1.6 Prove an address has a minimum unspent balance (ReserveProofV2)
Despite the privacy leak of revealing an output’s key image when it isn’t spent yet, it’s still
a somewhat useful method and was implemented in Monero [126] before UnspentProofs were
invented [130]. Monero’s so-called ‘ReserveProof’ src/wallet/
wallet2.cpp
get rese
rve proof()
is used to prove an address owns a minimum
amount of money by creating key images for some unspent outputs.
More specifically, given a minimum balance, the prover finds enough unspent outputs to cover it,
demonstrates ownership with InProofs, makes key images for them and proves they are legitimately
based on those outputs with 2-base proofs (using a different key prefixing format), and then proves
knowledge of the private spend keys used with normal Schnorr signatures (there may be more than
one if some outputs are owned by different subaddresses). A verifier can check that the key images
have not appeared on the blockchain, and hence their outputs must be unspent.


CHAPTER 8. MONERO TRANSACTION-RELATED KNOWLEDGE PROOFS 83
The ReserveProof
All the sub-proofs within a ReserveProof sign a different message than other proofs (e.g. Out
Proofs, InProofs, or SpendProofs). This time it is m = Hn(message, address, K ̃1o, ..., K ̃no), where
address is the encoded form (see [5]) of the prover’s normal address (Kv, Ks), and the key images
correspond with unspent outputs to be included in the proof.
1. Each output has an InProof, which shows the prover’s address (or one of his subaddresses)
owns the output.
2. Each output’s key image is signed with a 2-base proof src/crypto/
crypto.cpp
generate
ring signa
ture()
, where the challenge is formatted like
this
c = Hn(m, [rG + c ∗ Ko], [rHp(Ko) + c ∗ K ̃ ])
3. Each address (and subaddress) that owns at least one output has a normal Schnorr signa
ture (Section 2.3.5), and the challenge looks like (it’s the same for normal addresses and
subaddresses) src/crypto/
crypto.cpp
generate
signature()
c = Hn(m, Ks,i, [rG + c ∗ Ks,i])
To send a ReserveProof to someone else src/wallet/
wallet2.cpp
get rese
rve proof()
, the prover concatenates prefix string “ReserveProofV2”
with two lists encoded in base-58 (e.g. “ReserveProofV2, list 1, list 2”). Each item in list 1 is
related to a specific output and contains its transaction hash (Section 7.4.1), output index in that
transaction (Section 4.2.1), the relevant shared secret rKv, its key image, its InProof σinproof ,
and its key image proof. List 2 items are the addresses that own those outputs along with their
Schnorr signatures.
Verification
1. Check the ReserveProof key images have not appeared in the blockchain. src/wallet/
wallet2.cpp
check rese
rve proof()
2. Verify the InProof for each output, and that one of the provided addresses owns each one.
3. Verify the 2-base key image signatures.
4. Use the sender-receiver shared secrets to decode the output amounts (Section 5.3).
5. Check each address’s signature.
If everything is legitimate, then the prover must own, unspent, at least the total amount contained
in the ReserveProof’s outputs (except with negligible probability).11
11 ReserveProofs, while demonstrating full ownership of funds, do not include proofs that given subaddresses actually correspond with the prover’s normal address.


CHAPTER 8. MONERO TRANSACTION-RELATED KNOWLEDGE PROOFS 84
8.2 Monero audit framework
In the USA most companies undergo yearly audits of their financial statements [129], which include
the income statement, balance sheet, and cash flow statement. Of these the former two involve
in large part a company’s internal record-keeping, while the last involves every transaction that
affects how much money the company currently has. Cryptocurrencies are digital cash, so any
audit of a cryptocurrency user’s cash flow statement must relate to transactions stored on the
blockchain.
The first task of an audited person is to identify all the outputs they currently own (spent and
unspent). This can be one with InProofs using all of their addresses. A large business may have
a multitude of subaddresses, especially retailers operating in online marketplaces (see Chapter
10). Creating InProofs on all transactions for every single subaddress may result in enormous
computational and storage requirements for both provers and verifiers.
Instead, we can make InProofs for just the prover’s normal addresses (on all transactions). The
auditor uses those sender-receiver shared secrets to check if any outputs are owned by the prover’s
main address or its related subaddresses. Recalling Section 4.3, a user’s view key is enough to
identify all outputs owned by an address’s subaddresses.
To ensure the prover is not hoodwinking an auditor by hiding the normal address for some of
his subaddresses, he also must prove all subaddresses correspond with one of his known normal
addresses.
8.2.1 Prove an address and subaddress correspond (SubaddressProof )
SubaddressProofs show that a normal address’s view key can be used to identify outputs owned
by a given subaddress.12
The SubaddressProof
SubaddressProofs can be made in much the same way as OutProofs and InProofs. Here the base
keys are J = {G, Ks,i}, public keys are K = {Kv, Kv,i}, and signing key is kv. Again, we show
just the verification step to clarify our meaning.
Verification
A verifier knows the prover’s address (Kv, Ks), subaddress (Kv,i, Ks,i), and has the Subad
dressProof σsubproof = (c, r).
12 SubaddressProofs have not been implemented in Monero.


CHAPTER 8. MONERO TRANSACTION-RELATED KNOWLEDGE PROOFS 85
1. Calculate the challenge
c′ = Hn(m, [Kv,i], [rG + c ∗ Kv], [rKs,i + c ∗ Kv,i], [Ttxprf2], [Kv], [Ks,i], [0])
2. If c = c′ then the prover knows kv for Kv, and Ks,i in combination with that view key makes
Kv,i (except with negligible probability).
8.2.2 The audit framework
Now we are prepared to learn as much as possible about a person’s transaction history.13
1. The prover gathers a list of all his accounts, where each account consists of a normal address
and various subaddresses. He makes SubaddressProofs for all subaddresses. Much like
ReserveProofs, he also makes a signature with the spend key of each address and subaddress,
demonstrating he has spend-rights over all outputs owned by those addresses.
2. The prover generates, for each of his normal addresses, InProofs on all transactions (e.g. all
transaction public keys) in the blockchain. This reveals to the auditor all outputs owned by
the prover’s addresses since they can check all one-time addresses with the sender-receiver
shared secrets. They can be sure outputs owned by subaddresses will be identified, because
of the SubaddressProofs.14
3. The prover generates, for each of his owned outputs, UnspentProofs on all transaction inputs
where they appear as ring members. Now the auditor will know the prover’s balance, and
can further investigate spent outputs.15
4. Optional: The prover generates, for each transaction where he spent an output, an OutProof
to show the auditor the recipient and amount. This step is only possible for transactions
where the prover saved the transaction private key(s).
Importantly, a prover has no way to show the origin of funds directly. His only recourse is to
request a set of proofs from people sending him money.
1. For a transaction sending money to the prover, its author makes a SpendProof demonstrating
they actually sent it.
2. The prover’s funder also makes a signature with an identifying public key, for example the
spend key of their normal address. Both the SpendProof and this signature should sign a
message containing that identifying public key, to ensure the SpendProof wasn’t stolen or in
fact made by someone else.
13 This audit framework is not completely available in Monero. SubaddressProofs and UnspentProofs are not implemented, InProofs are not prepared for the optimization related to subaddresses that we explained, and there is no real structure to easily get or organize all the necessary information for both provers and verifiers. 14 This step can also be completed by providing the private view keys, although it has obvious privacy implications. 15 Alternatively, he could make ReserveProofs for all owned outputs. Again, revealing the key images of unspent outputs has obvious privacy implications.


CHAPTER 9
Multisignatures in Monero
Cryptocurrency transactions are not reversible. If someone steals private keys or succeeds in a
scam, the money lost could be gone forever. Dividing signing power between people can weaken
the potential danger of a miscreant.
Say you deposit money into a joint account with a security company that monitors for suspicious
activity related to your account. Transactions can only be signed if both you and the company
cooperate. If someone steals your keys, you can notify the company there is a problem and the
company will stop signing transactions for your account. This is usually called an ‘escrow’ service.1
Cryptocurrencies use a ‘multisignature’ technique to achieve collaborative signing with so-called
‘M-of-N multisig’. In M-of-N, N people cooperate to make a joint key, and only M people (M ≤
N) are needed to sign with that key. We begin this chapter by introducing the basics of N-of-N
multisig, progress into N-of-N Monero multisig, generalize for M-of-N multisig, and then explain
how to nest multisig keys inside other multisig keys.
In this chapter we focus on how we feel multisig should be done, based on the recommendations
in [111], and various observations about efficient implementation. We try to point out in foot
notes where the current implementation deviates from what is described.2 Our contributions are
detailing M-of-N multisig, and a novel approach to nesting multisig keys.
1 Multisignatures have a diversity of applications, from corporate accounts to newspaper subscriptions to online marketplaces. 2 As of this writing we are aware of three multisig implementations. First is a very basic manual process using the CLI (command line interface) [114]. Second is the truly excellent MMS (Multisig Messaging System) which enables
86


CHAPTER 9. MULTISIGNATURES IN MONERO 87
9.1 Communicating with co-signers
Building joint keys and joint transactions requires communicating secret information between
people who could be located all around the globe. To keep that information secure from observers,
co-signers need to encrypt the messages they send each other.
Diffie-Hellman exchange (ECDH) is a very simple way to encrypt messages using elliptic curve
cryptography. We already mentioned this in Section 5.3, where Monero output amounts are
communicated to recipients via the shared secret rKv. It looked like this:
amount t = bt ⊕8 Hn(“amount”, Hn(rKv
B, t))
We could easily extend this to any message. First encode the message as a series of bits, then
break it into chunks equal in size to the output of Hn. Generate a random number r ∈ Zl and
perform a Diffie-Hellman exchange on all the message chunks using the recipient’s public key K.
Send those encrypted chunks along with the public key rG to the intended recipient, who can then
decrypt the message with the shared secret krG. Message senders should also create a signature
on their encrypted message (or just the encrypted message’s hash for simplicity) so receivers can
confirm messages weren’t tampered with (a signature is only verifiable on the correct message m).
Since encryption src/wallet/
wallet2.cpp
export
multisig()
is not essential to the operation of a cryptocurrency like Monero, we do not feel
it necessary to go into more detail. Curious readers can look at this excellent conceptual overview
[4], or see a technical description of the popular AES encryption scheme here [23]. Also, Dr.
Bernstein developed an encryption scheme known as ChaCha [37, 100], which the primary Monero
implementation uses to encrypt certain sensitive information src/wallet/
ringdb.cpp
related to users’ wallets (such as key
images for owned outputs).
9.2 Key aggregation for addresses
9.2.1 Naive approach
Let’s say N people want to create a group multisignature address, which we denote (Kv,grp, Ks,grp).
Funds can be sent to that address just like any normal address, but, as we will see later, to spend
those funds all N people have to work together to sign transactions.
Since all N participants should be able to view funds received by the group address, we can let
everyone know the group view key kv,grp (recall Sections 4.1 and 4.2). To give all participants
equal power, the view key can be a sum of view key components that all participants send each
secure, highly automated multisig via the CLI [115, 116]. Third is the commercially available ‘Exa Wallet’, which has initial release code available on their Github repository at https://github.com/exantech (it does not appear up to date with current release version). All three of these rely on the same fundamental core team’s codebase, which essentially means only one implementation exists.


CHAPTER 9. MULTISIGNATURES IN MONERO 88
other securely. For participant e ∈ {1, ..., N }, his base view key component is kv,base
e ∈R Zl, and
all participants can compute the group private view key src/multi
sig/multi
sig.cpp
generate
multisig
view sec
ret key()
kv,grp =
N
∑
e=1
kv,base
e
In a similar fashion, the group spend key Ks,grp = ks,grpG could be a sum of private spend key
base components. However, if someone knows all the private spend key components then they
know the total private spend key. Add in the private view key and he can sign transactions on his
own. It wouldn’t be multisignature, just a plain old signature.
Instead, src/multi
sig/multi
sig.cpp
generate
multisig
N N()
we get the same effect if the group spend key is a sum of public spend keys. Say the
participants have base public spend keys Ks,base
e which they send each other securely. Now let
them each compute
Ks,grp =
∑
e
K s,base
e
Clearly this is the same as
Ks,grp = (
∑
e
ks,base
e )∗G
9.2.2 Drawbacks to the naive approach
Using a sum of public spend keys is intuitive and seemingly straightforward, but leads to a couple
issues.
Key aggregation test
An outside adversary who knows all the base public spend keys Ks,base
e can trivially test a given
public address (Kv, Ks) for key aggregation by computing Ks,grp = ∑
e Ks,base
e and checking
Ks ?= Ks,grp. This ties in with a broader requirement that aggregated keys be indistinguishable
from normal keys, so observers can’t gain any insight into users’ activities based on the kind of
address they publish.3
We can get around this by creating new base spend keys for each multisignature address, or by
masking old keys. The former case is easy, but may be inconvenient.
The second case proceeds like this: given participant e’s old key pair (Kev, Kes) with private keys
(kev, kes) and random masks μev, μse,4 let his new base private key components for the group address
3 If at least one honest participant uses components selected randomly from a uniform distribution, then keys aggregated by a simple sum are indistinguishable [122] from normal keys. 4 The random masks could easily be derived from some password. For example, μs = Hn(password) and μv = Hn(μs). Or, as is done in Monero, mask the spend and view keys with a string src/multisig/ multisig.cpp get multisig blinded secret key()
e.g. μs, μv = “Multisig”. This implies Monero only supports one multisig base spend key per normal address, although in reality making a wallet multisig causes users to lose access to the original wallet [114]. Users must make a new wallet with their normal address to access its funds, assuming the multisig wasn’t made from a brand new normal address.


CHAPTER 9. MULTISIGNATURES IN MONERO 89
be
kv,base
e = Hn(kv
e , μv
e) ks,base
e = Hn(ks
e, μs
e)
If participants don’t want observers to gather the new keys and test for key aggregation, they
would have to communicate their new key components to each other securely.5
If key aggregation tests are not a concern, they could publish their public key base components
(K v,base
e , Ks,base
e ) as normal addresses. Any third party could then compute the group address
from those individual addresses and send funds to it, without interacting with any of the joint
recipients [90].
Key cancellation
If the group spend key is a sum of public keys, a dishonest participant who learns his collaborators’
spend key base components ahead of time can cancel them.
For example, say Alice and Bob want to make a group address. Alice, in good faith, tells Bob
her key components (kv,base
A , Ks,base
A ). Bob privately makes his key components (kv,base
B , Ks,base
B)
but doesn’t tell Alice right away. Instead, he computes K′s,base
B = Ks,base
B − Ks,base
A and tells Alice
(kv,base
B , K′s,base
B ). The group address is:
Kv,grp = (kv,base
A + kv,base
B )G
= kv,grpG
Ks,grp = Ks,base
A + K′s,base
B = Ks,base
A + (Ks,base
B − Ks,base
A)
= Ks,base
B
This leaves a group address (kv,grpG, Ks,base
B ) where Alice knows the private group view key, and
Bob knows both the private view key and private spend key! Bob can sign transactions on his own,
fooling Alice, who might believe funds sent to the address can only be spent with her permission.
We could solve this issue by requiring each participant, before aggregating keys, to make a signature
proving they know the private key to their spend key component [109].6 This is inconvenient and
vulnerable to implementation mistakes. Fortunately a solid alternative is available.
9.2.3 Robust key aggregation
To easily resist key cancellation we make a small change to spend key aggregation (leaving view
key aggregation the same). Let the set of N signers’ base spend key components be Sbase =
5 As we will see in Section 9.6, key aggregation does not work on M-of-N multisig when M < N due to the presence of shared secrets. 6 Monero’s current (and first) iteration of multisig, made available in April 2018 [62] (with M-of-N integration following in October 2018 [11]), used this naive key aggregation, and required users sign src/wallet/ wallet2.cpp get multisig info()
their spend key components.


CHAPTER 9. MULTISIGNATURES IN MONERO 90
{K s,base
1 , ..., Ks,base
N }, ordered according to some convention (such as smallest to largest numerically,
i.e. lexicographically).7 The robust aggregated spend key is [111]8,9
Ks,grp =
∑
e
Hn(Tagg, Sbase, Ks,base
e )Ks,base
e
Now if Bob tries to cancel Alice’s spend key, he gets stuck with a very difficult problem.
Ks,grp = Hn(Tagg, S, Ks
A )K s
A + Hn(Tagg, S, K′s
B )K′s
B
= Hn(Tagg, S, Ks
A )K s
A + Hn(Tagg, S, K′s
B )Ks
B − Hn(Tagg, S, K′s
B )Ks
A
= [Hn(Tagg, S, Ks
A) − Hn(Tagg, S, K′s
B )]Ks
A + Hn(Tagg, S, K′s
B )Ks
B
We leave Bob’s frustration to the reader’s imagination.
Just like with the naive approach, any third party who knows Sbase and the corresponding public
view keys can compute the group address.
Since participants don’t need to prove they know their private spend keys, or really interact at all
before signing transactions, our robust key aggregation meets the so-called plain public-key model,
where “the only requirement is that each potential signer has a public key”[90].10
Functions premerge and merge
More formally, and for the sake of clarity going forward, we can say there is an operation premerge
which takes in a set of base keys Sbase, and outputs a set of aggregation keys Kagg of equal size,
where element11
Kagg[e] = Hn(Tagg, Sbase, Ks,base
e )Ks,base
e
The aggregation private keys keagg are used in group signatures.12
There is another operation merge which takes the aggregation keys from premerge and constructs
the group signing key (e.g. spend key for Monero)
Kgrp =
∑
e
Kagg [e]
We generalize these functions for (N-1)-of-N and M-of-N in Section 9.6.2, and further generalize
them for nested multisig in Section 9.7.2.
7 Sbase needs to be ordered consistently so participants can be sure they are all hashing the same thing. 8 Recalling Section 3.6, hash functions should be domain separated by prefixing them with tags, e.g. Tagg = “Multisig Aggregation”. We leave tags out for examples like the next section’s Schnorr signatures. 9 It is important to include Sbase in the aggregation hashes to avoid sophisticated key cancellation attacks involving Wagner’s generalized solution to the birthday problem [137]. [139] [90] 10 As we will see later, key aggregation only meets the plain public-key model for N-of-N and 1-of-N multisig. 11 Notation: Kagg[e] is the eth element of the set. 12 Robust key aggregation has not yet been implemented in Monero, but since participants can store and use private key kagg
e (for naive key aggregation, kagg
e = kbase
e ), updating Monero to use robust key aggregation will only change the premerge process.


CHAPTER 9. MULTISIGNATURES IN MONERO 91
9.3 Thresholded Schnorr-like signatures
It takes a certain amount of signers for a multisignature to work, so we say there is a ‘threshold’ of
signers below which the signature can’t be produced. A multisignature with N participants that
requires all N people to build a signature, usually referred to as N-of-N multisig, would have a
threshold of N. Later we will extend this to M-of-N (M ≤ N) multisig where N participants create
the group address but only M people are needed to make signatures.
Let’s take a step back from Monero. All signature schemes in this document lead from Maurer’s
general zero-knowledge proof of knowledge [87], so we can demonstrate the essential form of
thresholded signatures using a simple Schnorr-like signature (recall Section 2.3.5) [109].
Signature
Say there are N people who each have a public key in the set Kagg, where each person e ∈ {1, ..., N }
knows the private key keagg. Their N-of-N group public key, which they will use to sign messages,
is Kgrp. Suppose they want to jointly sign a message m. They could collaborate on a basic
Schnorr-like signature like this
1. Each participant e ∈ {1, ..., N } does the following:
(a) picks random component αe ∈R Zl,
(b) computes αeG
(c) commits to it with Ceα = Hn(Tcom, αeG),
(d) and sends Ceα to the other participants securely.
2. Once all commitments Ceα have been collected, each participant sends their αeG to the other
participants securely. They must verify that Ceα
?= Hn(Tcom, αeG) for all other participants.
3. Each participant computes
αG =
∑
e
αeG
4. Each participant e ∈ {1, ..., N } does the following:13
(a) computes the challenge c = Hn(m, [αG]),
(b) defines their response component re = αe − c ∗ keagg (mod l),
(c) and sends re to the other participants securely.
5. Each participant computes
r=
∑
e
re
6. Any participant can publish the signature σ(m) = (c, r).
13 As in Section 2.3.4, it is important not to reuse αe for different challenges c. This means to reset a multisignature process where responses have been sent out, it should start again from the beginning with new αe values.


CHAPTER 9. MULTISIGNATURES IN MONERO 92
Verification
Given Kgrp, m, and σ(m) = (c, r):
1. Compute the challenge c′ = Hn(m, [rG + c ∗ Kgrp]).
2. If c = c′ then the signature is legitimate except with negligible probability.
We included the superscript grp for clarity, but in reality the verifier has no way to tell Kgrp
is a merged key unless a participant tells him, or unless he knows the base or aggregation key
components.
Why it works
Response r is the core of this signature. Participant e knows two secrets in re (αe and keagg), so
his private key keagg is information-theoretically secure from other participants (assuming he never
reuses αe). Moreover, verifiers use the group public key Kgrp, so all key components are needed
to build signatures.
rG = (
∑
e
re)G
=(
∑
e
(αe − c ∗ kagg
e ))G
=(
∑
e
αe)G − c ∗ (
∑
e
kagg
e )G
= αG − c ∗ Kgrp
αG = rG + c ∗ Kgrp
Hn(m, [αG]) = Hn(m, [rG + c ∗ Kgrp])
c = c′
Additional commit-and-reveal step
The reader may be wondering where Step 2 came from. Without commit-and-reveal [111], a
malicious co-signer could learn all αeG before the challenge is computed. This lets him control
the challenge produced to some degree, by modifying his own αeG prior to sending it out. He
can use the response components collected from multiple controlled signatures to derive other
signers’ private keys keagg in sub-exponential time [53], a serious security threat. This threat relies
on Wagner’s generalization [137] (see also [139] for a more intuitive explanation) of the birthday
problem [141].14
14 Commit-and-reveal is not used in the current implementation of Monero multisig, although it is being looked at for future releases. [102]